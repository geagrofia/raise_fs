---
title: Hierarchies of criteria in IRM
author: ""
date: "`r Sys.Date()`"
output:
  html_document:  
    code_folding: "hide"
    theme: united
    number_sections: no
    toc: yes
    toc_float: true
    toc_depth: 6
    css: js/style.css
params:
  INT: NA
  SYS: comparison
  Agg: 1
  MASK: 5000
  INN1: oil_palm_P1
  RES1: 3
  SOS1: 0
  FAOCLASS1: 2
  LIMITS1: 2
  SUBDIV1: NAME_1
  TRIAD1: Adoption
  TRIBA1: Aptitude
  TRISE1: Feasible
  INN2: oil_palm_new
  RES2: 3
  SOS2: 0
  FAOCLASS2: 2
  LIMITS2: 2
  SUBDIV2: NAME_1
  TRIAD2: Adoption
  TRIBA2: Aptitude
  TRISE2: Feasible


---

```{r}
# sets the style for the output
```

<style>
pre {
  overflow-x: auto;
}
pre code {
  word-wrap: normal;
  white-space: pre;
}

div.INN { background-color:#e6f0ff; border-radius: 5px; padding: 10px; font-size: 200%;  color: orange;}
div.Agg { background-color:#e6f0ff; border-radius: 5px; padding: 10px; font-size: 150%;  color: orange;}

</style>

<script src="js/hideOutput.js"></script>

```{r parameter_description, echo=FALSE, message=FALSE, warning=FALSE}

# The parameters above are set to NA here, but when this rmd script is run from the shiny app then the parameters are passed with values.

# The first four parameters are general: 

# INT defines whether interface provides the parameter values - any value other than NA passed from the interface will tell this rmd script to use all parameters. The interface passes a value of 1 automatically.

# SYS is only relevant when more than one innovation is being tested. It sets whether the system is an intercrop, a comparison between crops or a rotation. Allowed values are "comparison","intercrop" and  "rotation"

# Agg defines the aggregation factor. This can be set above in the header with an integer value, or can be passed from the interface. The larger the aggregation factor the quicker the computation. The minimum value is 1.

# MASK defines the spatial resolution of the mask in metres

# The following parameters are specific to each innovation: 

# INN denotes the innovation, this is a unique code for each location/innovation and is used to locate the data and parameters that are used in IRM

# SOS sets whether the season onset is spatially defined. If so, SOS has a value of 1 and the start of the growing period is set using a raster rather than the value in the growth stage csv file. Otherwise SOS is 0.

# RES defines whether 3-class adoption (2 class aptitude), or FAO style 5-class adoption (5-class aptitude with added maps on the limitations) or both classes are computed. Computing both classes will increase the time to run the script!

#A value of 1 will only compute the 3-class suitability maps. A value of 2 will only compute the 5-class suitability map. A value of 3 will compute both suitability class maps. Other classified maps will be shown but only require a re-classification of the other results.

# TRIAD is the field name used for the triangulation points for Adoption

# TRIBA is the field name used for the triangulation points for Biophysical Aptitude

# TRISE is the field name used for the triangulation points for Socio-economic Feasibility

# SUBDIV is the field name used to identify the subdivision polygons

# FAOCLASS defines how many levels in the hierarchy of rule bases to produce classified FAO maps

# LIMITS defines how many levels in the hierarchy of rule bases to produce classified limitation maps


```

```{r folding_outputs_chunks, echo=FALSE, message=FALSE, warning=FALSE}

# Folding outputs chunks

# hideOutput.js and style.css courtesy of Martin Schmelzer https://stackoverflow.com/users/1777111/martin-schmelzer
# https://stackoverflow.com/questions/37755037/how-to-add-code-folding-to-output-chunks-in-rmarkdown-html-documents
 

```

```{r setup, include=FALSE, echo=FALSE, message=FALSE, warning=FALSE}

# initialisation

library(dplyr)
library(tidyr)
library(data.tree)
library(knitr)
library(kableExtra)
library(here)
library(irm)
library(fuZR)
library(sf)
library(terra)
library(stringr)
library(purrr)
library(tidyterra)
library(tidyverse)
library(scales)
library(tinytex)
library(ggplot2)
library(conflicted)
library(leaflet)
library(tibble)
library(sf)
library(widgetframe)
library(patchwork)
library(here)
library(DiagrammeR)
library(lava)
library(svgPanZoom)
library(scales)
library(lubridate)

```

```{r initialise, echo=FALSE, message=FALSE, warning=FALSE}

r_filename <- function(filename) {
  here::here("code/r/", filename)
}

source(r_filename("irm_functions.R"))


#set (chunk) options - figure path is necessary to avoid an error message
opts_chunk$set(
  comment = NA,
  dpi = 96,
  echo = FALSE,
  fig.path = paste0("figures/", params$INN1,"/"),
  warning = FALSE,
  cache = FALSE,
  include = TRUE
)

options(width = 250, dplyr.width = 120)

knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      # record the current time before each chunk
      now <<- Sys.time()
    } else {
      # calculate the time difference after a chunk
      res <- difftime(Sys.time(), now, units = "secs")
      # return a character string to show the time
      paste("Time for the chunk",
            options$label,
            "to run:",
            round(res,
                  2),
            "seconds")
    }
  }
}))

```

```{r general_parameters, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

cat("\n\n# General Parameters\n\n")


cat("<div class='INN'>")
cat("\nSystem =", params$SYS, "\n\n")
cat("</div>")

cat("<div class='Agg'>")
cat("Mask Resolution =", params$MASK)
cat("\nSpatial Aggregation =", params$Agg)
cat("</div>")

```

```{r i1_innovation_parameters, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

cat("\n\n# First Innovation\n\n")
cat("<div class='INN'>")
cat("Innovation name =", params$INN1)
cat("</div>")
cat("<div class='Agg'>")
cat("\n\nSpatially Dynamic Growing Season = ", params$SOS1)
cat("</div>")

# season onset non-spatial?
# this enables the script to skip the non relevant chunks when using console

if (params$SOS1 != 1){
    nonsos_crit_i1 <- TRUE
} else {nonsos_crit_i1 <- FALSE}

# season onset spatial?
if (params$SOS1 == 1){
    sos_crit_i1 <- TRUE
} else {sos_crit_i1 <- FALSE}

```

# Basic Settings

## Critera Parameters

Here we load most of the parameters used in the IRM model. These parameters are stored in an external text file, in comma separated format (.csv). 

The parameters include the criteria names, the rule base stack which they contribute to, and information to construct the rule bases.

The lowest level rule bases will have a spatial data source, with threshold values, and where relevant their weights. These criteria will have information about the propositions _and_ conclusions that are used to construct the rule base.

Higher level rule bases are combinations of the lower level criteria and do not have associated spatial data, but will often have weights. These criteria will only have information about the conclusions that are used to construct the rule base - the propositions are derived from the lower level rule bases.

The file will also contain information about how to aggregate and resample the spatial data, whether the data are for soil texture, precipitation or temperature, whether the criterion contributes to the yield estimation, the temporal resolution of any climate data, and a code used for mapping the limitations.


The criteria are organised hierarchically and can be displayed as a table and in a graphical diagram. 

```{r i1_load_criteria}
priorities_new_columns_filename_i1 <-
  as.character(paste(
    "tab_data/input/priorities_new_columns_",
    params$INN1,
    ".csv",
    sep = ""
  ))

df_priorities_i1 <-
  read.csv(here(priorities_new_columns_filename_i1), na.strings = c("NA"))
```


```{r i1_create_tree}
# remove any rows without data in the rulebase_number or criterion

df_priorities_i1 <- df_priorities_i1[complete.cases(df_priorities_i1$rulebase_number, df_priorities_i1$criterion), ]


df_priorities_short_i1 <-
  df_priorities_i1 %>% select(stack, criterion, weight, threshold, threshold2,	width,	width2)


df_priorities_short_i1$stack[is.na(df_priorities_short_i1$stack)] <-
  "root2"

# Convert to tree
tree_plot_i1 <- FromDataFrameNetwork(df_priorities_short_i1, c("weight", "threshold",	"threshold2",	"width",	"width2"
))

# Display the tree
print(tree_plot_i1, "weight", "threshold",	"threshold2",	"width",	"width2", "level") %>% kable(digits = 3, caption = "Hierarchies") %>% kable_styling("striped", full_width = T) %>%  row_spec(0, angle = -45) %>%  scroll_box(height = "500px")

```


```{r i1_get_hierarchy, results='asis' }
## Get the tree hierarchy for plotting

tree_max_level_i1 <- max(tree_plot_i1$Get('level')) - 1
cat("\n\nNumber of hierarchy levels", tree_max_level_i1, "\n\n")

hierarchies_new_i1 <- ToDataFrameTree(
  tree_plot_i1,
  level1 = function(x)
    x$path[2],
  level2 = function(x)
    x$path[3],
  level3 = function(x)
    x$path[4],
  level4 = function(x)
    x$path[5],
  level5 = function(x)
    x$path[6],
  level6 = function(x)
    x$path[7],
  level7 = function(x)
    x$path[8],
  
  level_number = function(x)
    x$level - 1
  
)[-1, -1]

# Display the df
#hierarchies_new %>% kable(digits = 3, caption = "Hierarchies") %>% kable_styling("striped", full_width = T) %>%  row_spec(0, angle = -45) %>%  scroll_box(height = "500px")

```

## Lower level rule bases with spatial data

```{r i1_get_leaves, results='asis', out.width="100%" }

n_leaves_i1 <- tree_plot_i1$leafCount
df_leaves_i1 <- ToDataFrameTypeCol(tree_plot_i1)

df_leaves_criterion_i1 <- as.data.frame( df_leaves_i1[cbind(seq(nrow(df_leaves_i1)), max.col(!is.na(df_leaves_i1), ties.method = 'last'))])
names(df_leaves_criterion_i1) <- c("criterion")
  
df_leaves_i1 %>% select(- level_1) %>% kable(digits = 3, caption = "Criteria with spatial data") %>% kable_styling("striped", full_width = T) %>%  scroll_box(height = "500px")

```

## Rule base hierarchy diagram

```{r i1_plot_hierarchy_diagram, results='asis', out.width="100%" }
# 
SetGraphStyle(
  tree_plot_i1,
  rankdir = "RL",
  overlap = "scalexy",
  fontsize = 400,
  fontname = "Calibri",
  label = paste("Rule bases for",params$INN1),
  labelloc = "t",
  ranksep = 1
)

SetNodeStyle(
  tree_plot_i1,
  shape = "box",
  fontsize = 200,
  fontname = "Helvetica",
  fontcolor = "black",
  fixedsize = "false",
  color = "DarkOliveGreen4",
  fillcolor = "OliveDrab2",
  style = "filled,rounded",
  penwidth = 10,
  tooltip = GetDefaultTooltip
)

SetEdgeStyle(
  tree_plot_i1,
  arrowhead = "none",
  color = "blue",
  penwidth = function(node) (node$weight * 50),
  dir = "back",
  label = function(node) paste("weight = :",node$weight),
  fontsize = 150,
  fontcolor = "blue"
)

level1 <- Traverse(tree_plot_i1, filterFun = function(x) x$level == 1)

Do(level1, function(node)
  SetEdgeStyle(
    node,
    inherit = FALSE,
    arrowhead = "none",
    color = "white",
    penwidth = function(node)
      (node$weight * 50),
    dir = "back",
    label = function(node)
      paste("weight = :", node$weight),
    fontsize = 150,
    fontcolor = "white"
  ))

Do(level1, function(node)
  SetNodeStyle(
    node,
    inherit = FALSE,
    shape = "oval",
    fixedsize = "false",
    width = 0.9,
    color = "white",
    fillcolor = "white",
    fontsize = 1,
    fontname = "Helvetica",
    fontcolor = "white",
    style = "filled"
  ))

level2 <- Traverse(tree_plot_i1, filterFun = function(x) x$level == 2)

Do(level2, function(node)
  SetNodeStyle(
    node,
    inherit = FALSE,
    shape = "oval",
    fixedsize = "false",
    width = 0.9,
    color = "lightblue",
    fillcolor = "darkgreen",
    fontsize = 200,
    fontname = "Helvetica",
    fontcolor = "white",
    style = "filled",
    tooltip = GetDefaultTooltip
  ))

Do(level2, function(node)
  SetEdgeStyle(
    node,
    inherit = FALSE,
    arrowhead = "none",
    color = "white",
    penwidth = function(node)
      (node$weight * 50),
    dir = "back",
    label = function(node)
      paste("weight = :", node$weight),
    fontsize = 150,
    fontcolor = "white",
    tooltip = GetDefaultTooltip
  ))

level3 <- Traverse(tree_plot_i1, filterFun = function(x) x$level == 3)

Do(level3, function(node)
 SetEdgeStyle(
  node,
  inherit = TRUE,
  arrowhead = "none",
  color = "blue",
  penwidth = function(node) (node$weight * 50),
  dir = "back",
  label = function(node) paste("weight = :",node$weight),
  fontsize = 150,
  fontcolor = "blue",
  tooltip = GetDefaultTooltip
))

Do(level3, function(node)
  SetNodeStyle(
    node,
    inherit = TRUE,
    shape = "oval",
    fixedsize = "false",
    width = 0.9,
    color = "lightblue",
    fillcolor = "blue",
    fontsize = 200,
    fontname = "Helvetica",
    fontcolor = "white",
    style = "filled",
    tooltip = GetDefaultTooltip
  ))

Do(tree_plot_i1$leaves, function(node)
  SetNodeStyle(
    node,
    shape = "box",
    fontsize = 200,
    fontname = "Helvetica",
    fontcolor = "black",
    fixedsize = "false",
    color = "DarkOliveGreen4",
    fillcolor = "OliveDrab2",
    style = "filled,rounded",
    penwidth = 10,
    tooltip = GetDefaultTooltip
  ))

Do(tree_plot_i1$leaves, function(node)
  SetEdgeStyle(
  node,
  arrowhead = "none",
  color = "blue",
  penwidth = function(node) (node$weight * 50),
  dir = "back",
  label = function(node) paste("weight = :",node$weight),
  fontsize = 150,
  fontcolor = "blue",
  tooltip = GetDefaultTooltip
))

plot(tree_plot_i1)

```

```{r i1_criteria_codes}

df_priorities_short_i1 <-
  df_priorities_i1 %>% select(rulebase_stack, rulebase_number, weight, threshold, threshold2,	width,	width2)


df_priorities_short_i1$rulebase_stack[is.na(df_priorities_short_i1$rulebase_stack)] <-
  "root2"

# Convert to tree
tree_new_i1 <- FromDataFrameNetwork(df_priorities_short_i1, c("weight", "threshold",	"threshold2",	"width",	"width2"
))

# Display the tree
#print(tree_new, "weight", "threshold",	"threshold2",	"width",	"width2", "level")

```

```{r i1_criteria_codes_get_hierarchy}
## Get the tree hierarchy

tree_max_level_i1 <- max(tree_new_i1$Get('level')) - 1
#cat("\n\nNumber of levels", tree_max_level, "\n\n")

hierarchies_new_i1 <- ToDataFrameTree(
  tree_new_i1,
  level1 = function(x)
    x$path[2],
  level2 = function(x)
    x$path[3],
  level3 = function(x)
    x$path[4],
  level4 = function(x)
    x$path[5],
  level5 = function(x)
    x$path[6],
  level6 = function(x)
    x$path[7],
  level7 = function(x)
    x$path[8],
  
  level_number = function(x)
    x$level - 1
  
)[-1, -1]

# Display the df
# hierarchies_new %>% kable(digits = 3, caption = "Hierarchies") %>% kable_styling("striped", full_width = T) %>%  row_spec(0, angle = -45) %>%  scroll_box(height = "500px")

```

```{r i1_criteria_codes_get_leaves}
## Get the tree leaves

n_leaves_i1 <- tree_new_i1$leafCount
df_leaves_i1 <- ToDataFrameTypeCol(tree_new_i1)

df_leaves_criterion_i1 <- as.data.frame( df_leaves_i1[cbind(seq(nrow(df_leaves_i1)), max.col(!is.na(df_leaves_i1), ties.method = 'last'))])
names(df_leaves_criterion_i1) <- c("rulebase_number")
  
```

# Load Spatial Data

Here we load all the spatial data. The data are used in different chunks below but it is easier to modify file names if all the spatial data are imported in the same chunk.

## Vector Data

The vector data include the sub-divisions of the area that is being modelled, and triangulation points if available.

The vector data are not projected and in geojson format. Here they are loaded and projected to the working crs.

<div class="fold o">   
```{r i1_spatialdataload_vector_01, cache = FALSE, out.width="100%", include = TRUE, echo=FALSE}

wkt_geo <-  paste0( "
  GEOGCRS[\"WGS 84 (with axis order normalized for visualization)\",
          ENSEMBLE[\"World Geodetic System 1984 ensemble\",
                   MEMBER[\"World Geodetic System 1984 (Transit)\",
                          ID[\"EPSG\",1166]],
                   MEMBER[\"World Geodetic System 1984 (G730)\",
                          ID[\"EPSG\",1152]],
                   MEMBER[\"World Geodetic System 1984 (G873)\",
                          ID[\"EPSG\",1153]],
                   MEMBER[\"World Geodetic System 1984 (G1150)\",
                          ID[\"EPSG\",1154]],
                   MEMBER[\"World Geodetic System 1984 (G1674)\",
                          ID[\"EPSG\",1155]],
                   MEMBER[\"World Geodetic System 1984 (G1762)\",
                          ID[\"EPSG\",1156]],
                   MEMBER[\"World Geodetic System 1984 (G2139)\",
                          ID[\"EPSG\",1309]],
                   ELLIPSOID[\"WGS 84\",6378137,298.257223563,
                             LENGTHUNIT[\"metre\",1],
                             ID[\"EPSG\",7030]],
                   ENSEMBLEACCURACY[2.0],
                   ID[\"EPSG\",6326]],
          PRIMEM[\"Greenwich\",0,
                 ANGLEUNIT[\"degree\",0.0174532925199433],
                 ID[\"EPSG\",8901]],
          CS[ellipsoidal,2],
          AXIS[\"geodetic longitude (Lon)\",east,
               ORDER[1],
               ANGLEUNIT[\"degree\",0.0174532925199433,
                         ID[\"EPSG\",9122]]],
          AXIS[\"geodetic latitude (Lat)\",north,
               ORDER[2],
               ANGLEUNIT[\"degree\",0.0174532925199433,
                         ID[\"EPSG\",9122]]],
          USAGE[
            SCOPE[\"Horizontal component of 3D system.\"],
            AREA[\"World.\"],
            BBOX[-90,-180,90,180]],
          REMARK[\"Axis order reversed compared to EPSG:4326\"]]")

vect_subdiv_i1 <- load_vector_data(paste0("subdiv_", params$INN1))

vect_subdiv_i1$ID <- seq.int(nrow(vect_subdiv_i1))# add an id field
vect_subdiv_i1$id <- formatC(vect_subdiv_i1$ID, width = 2, format = "d", flag = "0") #format the id field

df_subdiv_area_i1 <- as.data.frame(expanse(vect_subdiv_i1, unit="ha"))
df_subdiv_area_i1 <- cbind(df_subdiv_area_i1, as.data.frame(vect_subdiv_i1)$ID)
names(df_subdiv_area_i1) <- c("ha","ID")
#names(df_subdiv_area) <- c("ha")
max_area_i1 <- max(df_subdiv_area_i1)
 
 
vect_subdiv_extent_i1 <- ext(vect_subdiv_i1) # get the extent
nudge_xval_i1 <-
  ((vect_subdiv_extent_i1[2] - vect_subdiv_extent_i1[1]) / (nrow(vect_subdiv_i1) * 2.5))
nudge_yval_i1 <-
  ((vect_subdiv_extent_i1[4] - vect_subdiv_extent_i1[3]) / (nrow(vect_subdiv_i1) * 2.5))

vect_subdiv_pt_i1 <- centroids(vect_subdiv_i1)
expr <- paste0("vect_subdiv_pt_i1$", params$SUBDIV1)
vect_subdiv_pt_i1$subdiv_label <- paste(vect_subdiv_pt_i1$id, "=", eval(parse(text=(expr))))
vect_subdiv_pt_i1$subdiv_label <- factor(vect_subdiv_pt_i1$subdiv_label)

g_i1 <- ggplot()
gsubdiv_i1 <- add_subdiv_plot(g_i1, vect_subdiv_i1, vect_subdiv_pt_i1, nudge_xval_i1, nudge_yval_i1)
gsubdiv_i1

```
</div>

<div class="fold o">   
```{r i1_spatialdataload_vector_02, cache = FALSE, out.width="100%", include = TRUE, echo=FALSE}

vect_triangulation_i1 <- load_vector_data( paste0("triangulation_", params$INN1))

vect_triangulation_i1$ID <- seq.int(nrow(vect_triangulation_i1))# add an id field
vect_triangulation_i1$id <- formatC(vect_triangulation_i1$ID, width = 2, format = "d", flag = "0") #format the id field

vect_triangulation_extent_i1 <- ext(vect_triangulation_i1) # get the extent
nudge_xvaltri_i1 <-
  ((vect_triangulation_extent_i1[2] - vect_triangulation_extent_i1[1]) /  (nrow(vect_triangulation_i1) * 2.5))
#cat("nudge_xvaltri =", nudge_xvaltri)
nudge_yvaltri_i1 <-
  ((vect_triangulation_extent_i1[4] - vect_triangulation_extent_i1[3]) /  (nrow(vect_triangulation_i1) * 2.5))
#cat("nudge_yvaltri =", nudge_yvaltri)


if (!is.na(params$TRIAD1)) {
  expr <- paste0("vect_triangulation_i1$", params$TRIAD1)
  vect_triangulation_i1$tri_label_ad <-
    paste(vect_triangulation_i1$id, "=", eval(parse(text = (expr))))
  vect_triangulation_i1$tri_label_ad <-
    factor(vect_triangulation_i1$tri_label_ad)
  g_ad_i1 <- ggplot() +
      labs(title = paste("\nAdoption Triangulation Points - ", params$INN1))
  gtriangulation_ad_i1 <- add_triangulation_plot_no_labels_ad(g_ad_i1, vect_triangulation_i1)
  gtriangulation_ad_i1 <- add_subdiv_simple_plot(gtriangulation_ad_i1, vect_triangulation_i1)
  gtriangulation_ad_i1
}

if (!is.na(params$TRIBA1)) {
  expr <- paste0("vect_triangulation_i1$", params$TRIBA1)
  vect_triangulation_i1$tri_label_ba <-
    paste(vect_triangulation_i1$id, "=", eval(parse(text = (expr))))
  vect_triangulation_i1$tri_label_ba <-
    factor(vect_triangulation_i1$tri_label_ba)
  g_ba_i1 <- ggplot() +
      labs(title = paste("\nBiophysical Aptitude\nTriangulation Points - ", params$INN1))
  gtriangulation_ba_i1 <- add_triangulation_plot_no_labels_ba(g_ba_i1, vect_triangulation_i1)
  gtriangulation_ba_i1 <- add_subdiv_simple_plot(gtriangulation_ba_i1, vect_triangulation_i1)
  gtriangulation_ba_i1
}

if (!is.na(params$TRISE1)) {
  expr <- paste0("vect_triangulation_i1$", params$TRISE1)
  vect_triangulation_i1$tri_label_se <-
    paste(vect_triangulation_i1$id, "=", eval(parse(text = (expr))))
  vect_triangulation_i1$tri_label_se <-
    factor(vect_triangulation_i1$tri_label_se)
  g_se_i1 <- ggplot() +
      labs(title = paste("\nSocio-economic Feasibility\nTriangulation Points - ", params$INN1))
  gtriangulation_se_i1 <- add_triangulation_plot_no_labels_se(g_se_i1, vect_triangulation_i1)
  gtriangulation_se_i1 <- add_subdiv_simple_plot(gtriangulation_se_i1, vect_triangulation_i1)
  gtriangulation_se_i1
}

```
</div>


## Raster Data

The raster spatial data are loaded first.
Only the mask need be in the working crs.

<div class="fold o">   
```{r i1_spatialdataload_raster_01, results='asis', warning=FALSE}

# set the working crs using WKT arguments

wkt_lam <-  paste0(
    "PROJCRS[\"unknown\",
    BASEGEOGCRS[\"unknown\",
        DATUM[\"World Geodetic System 1984\",
            ELLIPSOID[\"WGS 84\",6378137,298.257223563,
                LENGTHUNIT[\"metre\",1]],
            ID[\"EPSG\",6326]],
        PRIMEM[\"Greenwich\",0,
            ANGLEUNIT[\"degree\",0.0174532925199433],
            ID[\"EPSG\",8901]]],
    CONVERSION[\"unknown\",
        METHOD[\"Lambert Azimuthal Equal Area\",
            ID[\"EPSG\",9820]],
        PARAMETER[\"Latitude of natural origin\",",
vect_subdiv_extent_i1[3],
    ",ANGLEUNIT[\"degree\",0.0174532925199433],
            ID[\"EPSG\",8801]],
        PARAMETER[\"Longitude of natural origin\",",
vect_subdiv_extent_i1[1],
    ",ANGLEUNIT[\"degree\",0.0174532925199433],
            ID[\"EPSG\",8802]],
        PARAMETER[\"False easting\",1000000,
            LENGTHUNIT[\"metre\",1],
            ID[\"EPSG\",8806]],
        PARAMETER[\"False northing\",1000000,
            LENGTHUNIT[\"metre\",1],
            ID[\"EPSG\",8807]]],
    CS[Cartesian,2],
        AXIS[\"(E)\",east,
            ORDER[1],
            LENGTHUNIT[\"metre\",1,
                ID[\"EPSG\",9001]]],
        AXIS[\"(N)\",north,
            ORDER[2],
            LENGTHUNIT[\"metre\",1,
                ID[\"EPSG\",9001]]]]"
  )


# project the country boundary to LAM

vect_subdiv_proj_i1 <-  project(vect_subdiv_i1, wkt_lam)
vect_subdiv_proj_extent_i1 <- terra::ext(vect_subdiv_proj_i1)

# make a basic raster with dimensions with 100m resolution 
# and projected crs 

rast_subdiv_mask_proj_extent_i1 <- rast(crs = wkt_lam, extent = vect_subdiv_proj_extent_i1, resolution = params$MASK, vals=c(1))

# make the mask based on the country boundary

rast_subdiv_mask_proj_i1 <- terra::rasterize(
      vect_subdiv_proj_i1,
      rast_subdiv_mask_proj_extent_i1,
      field = 1,
      background = NA, 
      touches = T
    ) 


# subset the priorities dataframe to keep only the records that have distinct raster data files

df_raster_data_i1 <- droplevels(distinct(df_priorities_i1,
                                      data_file_prefix,
                                      .keep_all = T)) %>% drop_na(data_file_prefix)


# for each record in the df_raster_data data frame use the data file prefix and the raster or brick variable to load the raster data, the name of the raster is generated automatically from the data file name
# these rasters needn't have the same crs as the working crs but must have the crs in the metadata (e.g. geotiff format)

for (i in seq(from = 1,
              to = nrow(df_raster_data_i1),
              by = 1)) {
  assign(
    paste0("rast_", df_raster_data_i1[i, 12]),
    load_raster_data(
      as.character(df_raster_data_i1[i, 12]),
      paste0("rast_", df_raster_data_i1[i, 12])
    )
  )
  cat(paste0("\n **rast_", df_raster_data_i1[i, 12], "** :\n"))
  print(get(paste0(
    "rast_", df_raster_data_i1[i, 12]
  )))
  cat(paste0("\n"))
}


```
</div>


# Common spatial resolution and extent

## Mask

Let's start with creating a 'mask', _i.e._, a raster map of the area of interest (1 = area to be modelled, NA = ignored). 

The properties of this map are shown below:

<div class="fold o">  
```{r i1_mask_make_plot, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, results='asis'}

if (params$Agg == 1){rast_mask_proj_i1 <- rast_subdiv_mask_proj_i1 } else {
  rast_mask_proj_i1 <- aggregate(rast_subdiv_mask_proj_i1, fact = params$Agg, na.rm=TRUE)}

res_rast_mask_proj_comma_i1 <- scales::label_comma(accuracy = NULL)(res(rast_mask_proj_i1))

g_i1 <- base_raster_plot(rast_mask_proj_i1, "layer", 'red', 'blue', paste0("Aggregated mask - Resolution = ", res_rast_mask_proj_comma_i1, "m"))

gsubdivsimple_i1 <- add_subdiv_simple_plot(g_i1, vect_subdiv_i1)
gsubdivsimple_i1

```
</div>

A factor is calculated to determine the area of each raster cell in hectares.

```{r i1_mask_area, cache = FALSE, warning=FALSE, results='asis' }

Stat_factor_ha_i1 <- ((xres(rast_mask_proj_i1)^2) / 10000) # factor used for statistical calculations divides the area of a raster cell (in m2) by 10000 to give the area of the cell in hectares

Stat_factor_ha_comma_i1 <- scales::label_comma(accuracy = NULL)(Stat_factor_ha_i1)

cat(paste(Stat_factor_ha_comma_i1, "hectares in each cell"))

```

## Rough crop, Reproject, Aggregate and Resample

In this section the input spatial data are cropped to the extent of the sub-division boundary, projected if necessary and then aggregated and resampled if necessary.


```{r i1_agg_resample_01, message=FALSE, warning=FALSE, cache=TRUE, out.width="100%", results='hide'}

# do a rough crop of the thematic data for the country extent in the CRS of the thematic data

for (i in seq(from = 1,
              to = nrow(df_raster_data_i1),
              by = 1)) {
  
  temp_crs <- crs(get(paste0("rast_", df_raster_data_i1[i, 12])))
  assign("vect_subdiv_temp_crs_i1",
         terra::project(vect_subdiv_i1, temp_crs))
  assign("vect_subdiv_temp_crs_extent_i1",
         terra::ext(vect_subdiv_temp_crs_i1))
  
  rast_roughcrop_filename_i1 <-
    paste0("spatial_data/input/rast_", df_raster_data_i1[i, 12], "_roughcrop_i1.tif")
  
  writeRaster(
    crop(get(paste0(
      "rast_", df_raster_data_i1[i, 12]
    )),
    vect_subdiv_temp_crs_extent_i1, touches=TRUE, extend=TRUE, mask=TRUE, snap = 'out'),
    here(rast_roughcrop_filename_i1),
    overwrite = TRUE
  )
  
  assign(paste0("rast_", df_raster_data_i1[i, 12], "_roughcrop_i1"),
         rast(here(rast_roughcrop_filename_i1)))
      

  gc()
}

 
```



<div class="fold o">   
```{r i1_agg_resample_02, cache = TRUE, out.width="100%", results='asis', warning=FALSE, message=FALSE}

# initialise empty vector of rasters

c_raster_data_rsmp_i1 <- c()

# create an empty data frame for climatic variables
df_raster_data_clim_i1 <- df_raster_data_i1[0,]

# create an empty data frame for soil variables with multiple horizons
df_raster_data_soil_i1 <- df_raster_data_i1[0,]

# create an empty data frame for variables with single band data
df_raster_data_single_i1 <- df_raster_data_i1[0,]


# reproject the raster data if necessary

for (i in seq(from = 1,
              to = nrow(df_raster_data_i1),
              by = 1)) {
  
  cat("\n\n")
  cat(paste("### ", as.character(df_raster_data_i1[i, 4])))
  cat("\n\n")
  
  # compare the crs of the raster with the working crs
# when different project the raster  
  
  if ( paste(crs(get(paste0("rast_", df_raster_data_i1[i, 12])))) %ni% paste(wkt_lam)) {  
  
  cat("different crs - ")  
  assign(
    paste0("rast_", df_raster_data_i1[i, 12], "_prj_i1"),
    raster_project(
      get(paste0("rast_", df_raster_data_i1[i, 12], "_roughcrop_i1")),
      #proj4_lam,
      as.character(df_raster_data_i1[i, 15]), rast_mask_proj_i1
    )
  )  
  
  } else {

   cat("same crs - ") 
# when not different just create a new raster with the same prj suffix  
    assign(
    paste0("rast_", df_raster_data_i1[i, 12], "_prj_i1"),
    get(paste0("rast_", df_raster_data_i1[i, 12], "_roughcrop_i1"))
      )
  }

# calculate aggregate factor for each criterion for both dimensions of the raster (these are the same for a square cell shape)
  
#  cat(paste(df_raster_data[i, 10],"\n"))

  calc_agg_factor_i1 <-
    (res(rast_mask_proj_i1) / res(get(paste0(
      "rast_", df_raster_data_i1[i, 12], "_prj_i1"
    ))))
  cat(paste("calculated aggregate factor = ", calc_agg_factor_i1))
  cat("\n")

 if (calc_agg_factor_i1[1] < 1) {
    calc_agg_factor_i1[1] <- 1
    
    # this means that the mask has a higher resolution than the precipitation raster so aggregation is not necessary and the precipitation raster will stay the same resolution
    
#    cat(paste("revised calculated aggregate factor 1 = ", calc_agg_factor[1],"\n"))
  }
  
  
  
  if (calc_agg_factor_i1[2] < 1) {
    calc_agg_factor_i1[2] <- 1
    cat(paste("revised calculated aggregate factor 2 = ", calc_agg_factor_i1[2]))
  }
  
  # for each record in the df_raster_data data frame use the data file prefix to recreate the raster name, and the aggregation and resample functions
#  cat(paste("aggregate and resample"))
  assign(
    paste0("rast_", df_raster_data_i1[i, 12], "_rsmp_i1"),
    agg_resample(
      get(paste0("rast_", df_raster_data_i1[i, 12], "_prj_i1")),
      calc_agg_factor_i1,
      as.character(df_raster_data_i1[i, 14]),
      as.character(df_raster_data_i1[i, 15]),
      rast_mask_proj_i1
    )
  )

c_raster_data_rsmp_i1 <- append(c_raster_data_rsmp_i1, get(paste0("rast_", df_raster_data_i1[i, 12], "_rsmp_i1"))) 
#  plot_raster <-
    terra::plot(
      get(paste0("rast_", df_raster_data_i1[i, 12], "_rsmp_i1")),
      main = paste0(
        as.character(df_raster_data_i1[i, 11]),
        "\n( ",
        as.character(df_raster_data_i1[i, 14]),
        ", ",
        as.character(df_raster_data_i1[i, 15]),
        ")"
      ),
      breaks = 10
   )
  #print(plot_raster)
  
  dim_rast_i1 <<- dim(get(paste0("rast_", df_raster_data_i1[i, 12], "_rsmp_i1")))

  cat(paste("\nDim = ", dim_rast_i1))
  cat("\n\n")
  
  if (dim_rast_i1[[3]] > 1) {
    if (!is.na(df_raster_data_i1[i, 16])) {
      df_raster_data_clim_i1 <-
        rbind(df_raster_data_clim_i1, df_raster_data_i1[i,])
    } else {
      df_raster_data_soil_i1 <-
        rbind(df_raster_data_soil_i1, df_raster_data_i1[i,])
    }
  } else {
    df_raster_data_single_i1 <-
      rbind(df_raster_data_single_i1, df_raster_data_i1[i,])
  }
  
  gc()    

#  plot_raster
#  terra::plot(rast_mask_proj, title = "") # this is needed (even if it is not actually plotted) to enable the plot of the raster
  
}


```
</div>


<div class="fold o">
```{r i1_agg_resample_03, cache = TRUE, out.width="100%", results='asis', warning=FALSE, message=FALSE}

# ensure that all rasters have data for the same area
# create new mask for data areas

rast_mask_proj_data_i1 <- mask(rast_mask_proj_i1, anyNA(c_raster_data_rsmp_i1), maskvalue=TRUE)
rast_mask_proj_data_i1
plot(rast_mask_proj_data_i1)

```
</div>

This mask designates the locations where predictions should be made, and an empty dataframe (tibble) is created with records for all locations.


<div class="fold o">   
```{r i1_mask03, cache = TRUE, cache.whatever=params$Agg, warning=FALSE }

# only run the models for the areas in the mask

df_irm_i1 <- geom(terra::as.points(rast_mask_proj_data_i1)) %>% as_tibble()

x <-  pull(df_irm_i1, x)
y <-  pull(df_irm_i1, y)
xy_i1 <- cbind(x, y)

#str(df_irm)

if (params$INT == 1)
  shiny::setProgress(0.17, message = "Resampling data 1st Innovation")  # set progress to 17%
``` 
</div>


# Convert raw data to criteria values

Raster data with multiple bands will need to be processed before adding to the df_irm_i1 data frame.

If the criterion has a growth stage name then it is climatic and will need to undergo the climatic processing.

## Processing climatic data

```{r i1_clim_data_temporal, results='asis'}

clim_raster_data_prefix_i1 <- df_raster_data_clim_i1$data_file_prefix
df_priorities_clim_i1 <- df_priorities_i1[0,]

for (i in clim_raster_data_prefix_i1) { 
# if any of the clim raster data prefix values are in the priorities 
df_priorities_clim_i1 <-
        rbind(df_priorities_clim_i1, subset(df_priorities_i1, grepl(paste0("\\b",i,"\\b"), df_priorities_i1$data_file_prefix)))
}


n_clim_i1 <- nrow(df_priorities_clim_i1)
cat(paste("\n\nThere are ", n_clim_i1, "Climatic criteria: \n"))

  for (i in 1:n_clim_i1) {
  cat(paste("\n",df_priorities_clim_i1[i, 4]," - "))
  rast_clim_mask_i1 <- get(paste0("rast_",df_priorities_clim_i1[i, 12], "_rsmp_i1"))
  if (paste(df_priorities_clim_i1[i, 25]) == "m") {
  rast_clim_mask_m_i1 <- rast_clim_mask_i1
  names(rast_clim_mask_m_i1) <- c(month.name)
  cat("monthly data\n")
  } else {
  rast_clim_mask_d_i1 <- rast_clim_mask_i1
  names(rast_clim_mask_d_i1) <- c(1:36)
  cat("dekadal data\n")}
  }

cat("\n\n")

```


<div class="fold o">   
```{r i1_clim_data_clean, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE}

## division by zero rainfall is infinitive, thus edited by Atkilt

if (exists('rast_clim_mask_m_i1')) {
  values(rast_clim_mask_m_i1)[values(rast_clim_mask_m_i1) >= 0] = 0
  values(rast_clim_mask_m_i1)[values(rast_clim_mask_m_i1) < 0] = NA
}

if (exists('rast_clim_mask_d_i1')) {
  values(rast_clim_mask_d_i1)[values(rast_clim_mask_d_i1) >= 0] = 0
  values(rast_clim_mask_d_i1)[values(rast_clim_mask_d_i1) < 0] = NA
}

```
</div>


```{r i1_growth_stages_01, echo=FALSE, results='asis'}

cat("\n\n#### Growth Stages\n

Here we load the table of the growth stages.\n")

```


<div class="fold o"> 
```{r i1_growth_stages_02, results='asis'}

# get the growth stages filename using the innovation parameter
growth_stages_filename_i1 <-
  as.character(paste("tab_data/input/growth_stages_", params$INN1, ".csv", sep = ""))

df_growth_stages_i1 <-  read.csv(here(growth_stages_filename_i1))

df_growth_stages_i1 %>% dplyr::filter(name != "sow_date") %>% select(-day)  %>%
  kable(digits = 3, caption = "Growth Stage Lengths") %>% kable_styling("striped", full_width = T) #%>% print

# create a new table just for where growth stage has requirements
df_growth_stages_req_i1 <-
  dplyr::filter(df_growth_stages_i1, (prec_criteria == 1 |
                                  temp_criteria == 1))
df_growth_stages_req_prec_i1 <-
  dplyr::filter(df_growth_stages_i1, prec_criteria == 1)
df_growth_stages_req_temp_i1 <-
  dplyr::filter(df_growth_stages_i1, temp_criteria == 1)

```
</div>


<div class="fold o"> 
```{r i1_sowing_dates_static_01, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, results='asis', eval=nonsos_crit_i1}

# see if one of the criteria is for the total growing period, if so then generate distribution

# this uses two functions from the irm package called .growth_period_long (for monthly data) and .growth_period_long_dekad (for dekadal data)

# both functions take three arguments: day_begin, and day_end in day numbers (obtained from the growth_stages_req table) and num_years which is calculated based on whether the growing season is spread across more than one calendar year


# for each of the growth stages for which there are requirements create a new raster brick
if (nonsos_crit_i1) {

cat("\n\n\n")
cat("#### Spatially Static Growing Seasons\n") # add headings
cat("\n\n\n")

cat(paste("\n\nSowing Date:", df_growth_stages_i1$day[[1]],"\n\n"))

# get the number of variables in growth_stages (excluding sowing/planting date and total length)

# create a list of the growth stages and determine the start and end days of each growth period

phen_tmp_i1 <- list()
for (i in seq_len(nrow(df_growth_stages_i1) - 1)) {
  phen_tmp_i1[[as.character(df_growth_stages_i1[i + 1, 1])]] <-
    df_growth_stages_i1[i + 1, 3]
}

phen_stages_beg_i1 <-
  df_growth_stages_i1$day[1] + c(0, cumsum(phen_tmp_i1)[c(-length(phen_tmp_i1), -(length(phen_tmp_i1)-1))], 0)
phen_stages_length_i1 <- unlist(phen_tmp_i1)
phen_stages_end_i1 <- phen_stages_beg_i1 + phen_stages_length_i1
names(phen_stages_beg_i1) <- names(phen_tmp_i1)
names(phen_stages_end_i1) <- names(phen_tmp_i1)

rbind(start = phen_stages_beg_i1, end = phen_stages_end_i1) %>%
  as.data.frame %>%
  kable(caption = "Growth Stage Days") %>% kable_styling("striped", full_width = T)  %>% print

num_years_i1 <- ceiling(phen_stages_end_i1[["total"]] / 365)
cat(paste("Growth Stages span", num_years_i1, "calendar years"))
}

```
</div>

<div class="fold o"> 
```{r i1_sowing_dates_static_02, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=nonsos_crit_i1, results='asis'}

if (nonsos_crit_i1) {
  
# monthly distribution
if (exists('rast_clim_mask_m_i1')) {
  for (i in seq_len(nrow(df_growth_stages_req_i1))) {
    period_name_i1 <- as.character(df_growth_stages_req_i1[i, 1])
    cat(paste("\n", period_name_i1," - monthly\n"))
    v_m_i1 <-
      .growth_period_long(phen_stages_beg_i1[period_name_i1], phen_stages_end_i1[period_name_i1], num_years_i1)
    assign(paste0("rast_period_m_", df_growth_stages_req_i1[i, 1], "_i1"),
           rast_clim_mask_m_i1 %>%
             app(function(x) {
               ifelse(is.na(x), NA_real_, v_m_i1)
             }))
    
#    plot_raster <-
      plot(
        get(paste0("rast_period_m_", df_growth_stages_req_i1[i, 1], "_i1")),
        maxnl = 12,
        breaks = c(0, 0.25, 0.5, 0.75, 1),
        axes = F,
        plg = list(cex = 1, title = paste0(df_growth_stages_req_i1[i, 1], "_i1"))
      )
#    print(plot_raster)
  }
}
# dekadal distribution
if (exists('rast_clim_mask_d_i1')) {
  for (i in seq_len(nrow(df_growth_stages_req_i1))) {
    period_name_i1 <- as.character(df_growth_stages_req_i1[i, 1])
    cat(paste("\n", period_name_i1," - dekad\n"))
    v_d_i1 <-
      .growth_period_long_dekad(phen_stages_beg_i1[period_name_i1], phen_stages_end_i1[period_name_i1], num_years_i1)
    assign(paste0("rast_period_d_", df_growth_stages_req_i1[i, 1], "_i1"),
           rast_clim_mask_d_i1 %>%
             app(function(x) {
               ifelse(is.na(x), NA_real_, v_d_i1)
             }))
    
#    plot_raster <-
      plot(
        get(paste0("rast_period_d_", df_growth_stages_req_i1[i, 1], "_i1")),
        maxnl = 36,
        breaks = c(0, 0.25, 0.5, 0.75, 1),
        axes = F,
        plg = list(cex = 1, title = paste0(df_growth_stages_req_i1[i, 1], "_i1"))
      )

  }
}
}
``` 
</div>


```{r i1_sowing_dates_sos_title, echo=FALSE, results='asis', eval=sos_crit_i1}

cat("\n#### Spatially Dynamic Growing Seasons\n")

```

```{r i1_sowing_dates_sos_intro, echo=FALSE, results='asis',  eval=sos_crit_i1}

cat("For climatic criteria for specific growth stages which use monthly or dekadal data, and which have a spatially variable growth period the phenological stages need to be distributed over those periods and spatially.\n
\n
\n
The maps below give the distribution of each phenological stage over the months.\n
\n
I use the same function as Walvoort (here called growth_period_long_tbl and growth_period_long_dekad_tbl), and apply this on a cell-by-cell basis using the start and end days for each cell.\n
\n
When the function is applied to the tibble using 'apply' it produces a x *x* 12/36 matrix. I transpose this matrix, append it to the original tibble and create a temporary data frame. I save this as a csv, convert this to a spatvector object and create spatrasters for each month/dekad *x* growing period combination. I join the individual rasters in a SpatRaster brick for each growing period - to be used later.")

```


<div class="fold o">   
```{r i1_sowing_dates_sos_onsetdata_01, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=sos_crit_i1}

if (sos_crit_i1) {
# get onset for area of interest
rast_filename_onset_i1 <-
  as.character(paste("spatial_data/input/rast_onset_",
                     params$INN1,
                     ".tif",
                     sep = ""))
assign(paste0("rast_onset_i1"), rast(here(rast_filename_onset_i1)))
names(rast_onset_i1) <- c("onset")
# rast_onset
# 
# g <- base_raster_plot(rast_onset, "onset", 'red', 'blue', "Season onset day number (rast_onset)" )
# 
# gsubdivsimple <- add_subdiv_simple_plot(g)
# gsubdivsimple
}
```
</div>


<div class="fold o">   
```{r i1_sowing_dates_sos_onsetdata_02, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=sos_crit_i1}

if (sos_crit_i1) {
# project onset
rast_onset_proj_i1 <- project(rast_onset_i1, rast_mask_proj_i1, method = "near")
# rast_onset_proj
# 
# g <- base_raster_plot(rast_onset_proj, "onset", 'red', 'blue', "Season onset day number (rast_onset_proj)" )
# 
# gsubdivsimple <- add_subdiv_simple_plot(g)
# gsubdivsimple
}
```
</div>


<div class="fold o">   
```{r i1_sowing_dates_sos_onsetdata_03, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=sos_crit_i1}

if (sos_crit_i1) {
# do a rough crop to boundaries
rast_onset_crop_i1 <- crop(rast_onset_proj_i1, rast_mask_proj_i1, mask = T, touches = T, extend = T, snap = 'out')
# rast_onset_crop
# 
# g <- base_raster_plot(rast_onset_crop, "onset", 'red', 'blue', "Season onset day number (rast_onset_crop)" )
# 
# gsubdivsimple <- add_subdiv_simple_plot(g)
# gsubdivsimple
}

```
</div>


<div class="fold o">   
```{r i1_sowing_dates_sos_onsetdata_04, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=sos_crit_i1}
if (sos_crit_i1) {
rast_onset_crop_rsmp_i1 <- resample(rast_onset_crop_i1, rast_mask_proj_i1,  method="near")
rast_onset_crop_rsmp_i1


g_i1 <- base_raster_plot(rast_onset_crop_rsmp_i1, "onset", 'red', 'blue', "Season onset day number (rast_onset_crop_rsmp_i1)" )

gsubdivsimple_i1 <- add_subdiv_simple_plot(g_i1, vect_subdiv_i1)
gsubdivsimple_i1
}
```
</div>

<div class="fold o">   
```{r i1_sowing_dates_sos_onsetdata_05, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=sos_crit_i1}

if (sos_crit_i1) {
# convert to df
df_onset_i1 <- as.data.frame(rast_onset_crop_rsmp_i1, xy=TRUE, cells=TRUE, na.rm=NA)
df_onset_i1 <- mutate(df_onset_i1, onset = as.integer(onset))
}
```
</div>

<div class="fold o">   
```{r i1_sowing_dates_sos_transpose, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE,  eval=sos_crit_i1}

if (sos_crit_i1) {
df_growth_stages_lengths_i1 <- df_growth_stages_i1[-1, ]
#df_growth_stages_lengths

df_growth_stages_lengths1_i1 <- t(select(df_growth_stages_lengths_i1, name, length)) %>% data.frame()
#df_growth_stages_lengths1

df_growth_stages_lengths2_i1 <- setNames(df_growth_stages_lengths1_i1, df_growth_stages_lengths_i1[,1])
#df_growth_stages_lengths2

df_growth_stages_lengths3_i1 <- df_growth_stages_lengths2_i1[-1, ] 
#df_growth_stages_lengths3

df_growth_stages_lengths3_i1[] <- lapply(df_growth_stages_lengths3_i1, as.integer)
df_growth_stages_lengths3_i1 %>%
  kable(caption = "Growth Stage Days") %>% kable_styling("striped", full_width = T)  #%>% print
}
```
</div>

<div class="fold o">   
```{r i1_sowing_dates_sos_onsetdata_06, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE,  eval=sos_crit_i1}

if (sos_crit_i1) {
# add the growth stage lengths to the df
for (i in seq_len(nrow(df_growth_stages_lengths_i1))) {
  period_name_i1 <- as.character(df_growth_stages_lengths_i1[i, 1])
#  cat(paste(period_name))
#  cat(eval(parse(text = paste0("df_growth_stages_lengths3$", period_name))))
  df_onset_i1 <-  mutate(df_onset_i1, !!as.character(paste0(period_name_i1,"_l")) :=  eval(parse(text = paste0("df_growth_stages_lengths3_i1$", period_name_i1))), .keep = c("all"))
} 


# add the start day for the first growth stage (which is the onset)

first_period_name_i1 <- as.character(df_growth_stages_lengths_i1[1, 1])
#cat(paste(first_period_name))
df_onset_i1 <-
  mutate(df_onset_i1,!!as.character(paste0(first_period_name_i1, "_s")) :=  eval(parse(text = paste0(
    "df_onset_i1$onset"
  ))),
  .keep = c("all"))

# add the start days for each of the growth stages (excluding the first which is the onset)

for (i in seq_len(nrow(df_growth_stages_lengths_i1)- 2) ) {
  
#  cat(paste(i))
      
  previous_period_name_i1 <- as.character(df_growth_stages_lengths_i1[i, 1])
#  cat(paste("Prev = ", previous_period_name))
#  cat("\n")
  period_name_i1 <- as.character(df_growth_stages_lengths_i1[i + 1, 1])
#  cat(paste("Current = ", period_name))
#  cat("\n")
#  cat(paste0("df_growth_stages_lengths3$", period_name))
#  cat(paste(parse(text =paste0("df_onset$", previous_period_name,"_s"))))
#  cat("\n")
#  cat(paste(parse(text =paste0("df_onset$", previous_period_name,"_l"))))
#  cat("\n\n")
 
eval_expr_1 <- eval(parse(text =paste0("df_onset_i1$", previous_period_name_i1, "_s + df_onset_i1$", previous_period_name_i1,"_l")))

  df_onset_i1 <-
    mutate(df_onset_i1, !!as.character(paste0(period_name_i1, "_s")) :=  eval_expr_1,
           .keep = c("all"))

}

# add the end days for each of the growth stages

for (i in seq_len(nrow(df_growth_stages_lengths_i1) - 1) ) {
  
#  cat(paste(i))
      
#  previous_period_name <- as.character(df_growth_stages_lengths[i, 1])
#  cat(paste("Prev = ", previous_period_name))
#  cat("\n")
  period_name_i1 <- as.character(df_growth_stages_lengths_i1[i, 1])
#  cat(paste("Current = ", period_name))
#  cat("\n")
#  cat(paste0("df_growth_stages_lengths3$", period_name))
#  cat(paste(parse(text =paste0("df_onset$", period_name,"_s"))))
#  cat("\n")
#  cat(paste(parse(text =paste0("df_onset$", period_name,"_l"))))
#  cat("\n\n")
 
eval_expr_2 <- eval(parse(text =paste0("df_onset_i1$", period_name_i1, "_s + df_onset_i1$", period_name_i1,"_l - 1")))

  df_onset_i1 <-
    mutate(df_onset_i1, !!as.character(paste0(period_name_i1, "_e")) :=  eval_expr_2,
           .keep = c("all"))

}  
  
onset_max_i1 <- max(select(df_onset_i1, -cell, -x, -y)) # gets the maximum value of the julian day numbers
num_years_i1 <- max(ceiling(onset_max_i1 / 365))

cat(paste("Growth Stages span", num_years_i1, "calendar years"))
}
```
</div>

<div class="fold o">
```{r i1_sowing_dates_sos_maps_m, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=sos_crit_i1}

# to reduce unnecessary processing follow these steps
# for each growth stage:

# (1) does the monthly and/or dekad raster mask exist on file?
#   YES - (i) load raster file to env
#         (ii) plot raster file
#         (iii) move to next growth stage or next chunk
#   NO -  (i) go to (2)

# (2) does the monthly and/or dekad raster mask csv exist on file?
#   YES - (i) load csv file to env as vect
#         (ii) rasterize vect
#         (iii) write raster to file
#         (iv) go to (1)
#   NO -  (i) go to (3)

# (3) does the monthly and/or dekad raster mask df exist in the env?
#   YES - (i) write df to file as csv
#         (ii) go to (2)
#   NO -  (i) go to (4)

# (4) does the monthly and/or dekad raster mask matrix exist in the env?
#   YES - (i) join the matrix to the onset df
#         (ii) write df to file as csv
#         (iii) go to (3)
#   NO -  (i) create the matrix using the growth_period_long functions
#         (ii) join the matrix to the onset df
#         (iii) go to (4)

if (sos_crit_i1) {
if (exists('rast_clim_mask_m_i1')) {
  cat(paste("\n1 Monthly data exist"))
    
  # set static vectors of days and months
  days <- 1:365
  day_months <- days %>% as.character %>% as.Date("%j") %>% 
    format("%m") %>% as.integer
  months <- rep.int(day_months, num_years_i1)
  
  
  for (i in seq_len(nrow(df_growth_stages_lengths_i1))) {
    period_name_i1 <- as.character(df_growth_stages_lengths_i1[i, 1])
    cat(paste("\nCurrent growth stage = ", period_name_i1))
    
    rast_filename_m_i1 <-
      as.character(paste0(
        "spatial_data/output/rast_",
        period_name_i1,
        "_m_",
        params$INN1, "_", params$MASK,
        ".tif"
      ))
    
    if (!file.exists(here(rast_filename_m_i1))) {
      cat(paste("\n2 No spatraster"))
      
      if (!exists(paste0("vect_", period_name_i1, "_m_i1"))) {
        cat(paste("\n3 No spatvector"))
        
        csv_filename_m_i1 <-
          as.character(
            paste(
              "tab_data/output/df_onset_",
              period_name_i1,
              "_m_",
              params$INN1, "_", params$MASK,
              ".csv",
              sep = ""
            )
          )
        
        if (!file.exists(here(csv_filename_m_i1))) {
          cat(paste("\n4 No csv data"))
          
          if (!exists(paste0("df_onset_", period_name_i1, "_m_i1"))) {
            cat(paste("\n5 No df"))
            
            if (!exists(paste0(period_name_i1, "_matrix_days_m_i1"))) {
              cat(paste("\n6 No matrix"))
              
              if (period_name_i1 == "total") {
                expr_3_m <- parse(
                  text = paste0(
                    "t(apply(df_onset_i1, 1, .growth_period_long_tbl_short, day_begin = \"onset\", day_end = \"",
                    df_growth_stages_lengths_i1[nrow(df_growth_stages_lengths_i1) - 1, 1],
                    "_e\", num_years = num_years_i1))"
                  )
                )
              } else {
                expr_3_m <- parse(
                  text = paste0(
                    "t(apply(df_onset_i1, 1, .growth_period_long_tbl_short, day_begin = \"",
                    period_name_i1,
                    "_s\",
        day_end = \"",
        period_name_i1,
        "_e\", num_years = num_years_i1))"
                  )
                )
              }
              
              assign(paste0(period_name_i1, "_matrix_days_m_i1"),
                     eval(expr_3_m))
                            
                            expr_3_m2 <- parse(
                  text = paste0(period_name_i1, "_matrix_days_m_i1 * 1000"))
              
              assign(paste0(period_name_i1, "_matrix_days_m_i1"), eval(expr_3_m2))
              
              eval(parse(text = paste0(
                "mode(", period_name_i1, "_matrix_days_m_i1) <- \"integer\""
              )))
              
              cat(paste("\n-6"))
            }
            
            
            assign(paste0("df_onset_", period_name_i1, "_m_i1"),
                   data.frame(df_onset_i1, get(
                     paste0(period_name_i1, "_matrix_days_m_i1")
                   )))
            
            cat(paste("\n-5"))
          }
          
          rm(list = paste0(period_name_i1, "_matrix_days_m_i1")) # remove matrix when df created
          
          write.csv(get(paste0("df_onset_", period_name_i1, "_m_i1")),
                    here(csv_filename_m_i1))
          
          cat(paste("\n-4"))
        }
        rm(list = paste0("df_onset_", period_name_i1, "_m_i1")) # remove df when csv created
        # assign(paste0("vect_", period_name, "_m"),
        # vect(
        #   read_csv(here(csv_filename_m), show_col_types = FALSE, .name_repair = "unique_quiet"),
        #   geom = c("x", "y"),
        #   crs = wkt_lam
        # )) # gives an error due to unused argument (.name_repair = "unique_quiet")
        assign(paste0("vect_", period_name_i1, "_m_i1"),
               vect(
                 read_csv(here(csv_filename_m_i1), show_col_types = FALSE),
                 geom = c("x", "y"),
                 crs = wkt_lam
               )) 
        cat(paste("\n-3"))
      }
      
      
      assign(paste0("list_rast_", period_name_i1, "_m_i1"),
             list())
      
      #create an empty raster
      assign(paste0("rast_", period_name_i1, "_m_i1"), rast())
      
      for (j in 1:12) {
        assign(
          paste0("rast_", period_name_i1, "_m_i1_", j),
          rasterize(get(
            paste0("vect_", period_name_i1, "_m_i1")
          ), rast_clim_mask_m_i1, field = paste0("X", j))
        )
        
        assign(paste0("list_rast_", period_name_i1, "_m_i1"),
               append(get(
                 paste0("list_rast_", period_name_i1, "_m_i1")
               ), paste0("rast_", period_name_i1, "_m_i1_", j)))
        expr_5_m <-
          parse(text = paste0(
            "add(rast_",
            period_name_i1,
            "_m_i1) <- (rast_",
            period_name_i1,
            "_m_i1_",
            j,
            ")"
          ))
        
        eval(expr_5_m)
        rm(list = paste0("rast_", period_name_i1, "_m_i1_", j)) # remove month rast when added to brick
      }
      
      rm(list = paste0("vect_", period_name_i1, "_m_i1")) # remove vect when raster created
      writeRaster(get(paste0("rast_", period_name_i1, "_m_i1")), here(rast_filename_m_i1), overwrite = TRUE)
      cat(paste("\n-2"))
    }
    
    assign(paste0("rast_", period_name_i1, "_m_i1"), rast(here(rast_filename_m_i1)))
    cat(paste0("\n", rast_filename_m_i1))
    
    expr_6_m <-
      parse(
        text = paste0(
          "names(rast_",
          period_name_i1,
          "_m_i1) <- c(\"January\", \"February\", \"March\", \"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\")"
        )
      )
    
    eval(expr_6_m)
    
#    plot(
#      get(paste0("rast_", period_name, "_m")),
#      maxnl = 12,
#      breaks = c(0, 0.25, 0.5, 0.75, 1),
#      axes = F,
#      plg = list(cex = 1, title = paste0(period_name))
#    )
    
  }
  cat(paste("\n-1"))
}
}
```
</div>

<div class="fold o">
```{r i1_sowing_dates_sos_maps_d, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=sos_crit_i1}

# to reduce unnecessary processing follow these steps
# for each growth stage:

# (1) does the monthly and/or dekad raster mask exist on file?
#   YES - (i) load raster file to env
#         (ii) plot raster file
#         (iii) move to next growth stage or next chunk
#   NO -  (i) go to (2)

# (2) does the monthly and/or dekad raster mask csv exist on file?
#   YES - (i) load csv file to env as vect
#         (ii) rasterize vect
#         (iii) write raster to file
#         (iv) go to (1)
#   NO -  (i) go to (3)

# (3) does the monthly and/or dekad raster mask df exist in the env?
#   YES - (i) write df to file as csv
#         (ii) go to (2)
#   NO -  (i) go to (4)

# (4) does the monthly and/or dekad raster mask matrix exist in the env?
#   YES - (i) join the matrix to the onset df
#         (ii) write df to file as csv
#         (iii) go to (3)
#   NO -  (i) create the matrix using the growth_period_long functions
#         (ii) join the matrix to the onset df
#         (iii) go to (4)

if (sos_crit_i1) {
if (exists('rast_clim_mask_d_i1')) {
  cat(paste("\n1 Dekad data exist"))
  
  # set static vectors of days and dekads
  days <- 1:365
  day_dekads <- days %>% as.character %>% as.Date("%j") %>%
    dekad(type = "year") %>% as.integer
  dekads <- rep.int(day_dekads, num_years_i1)
  
  
  for (i in seq_len(nrow(df_growth_stages_lengths_i1))) {
    period_name_i1 <- as.character(df_growth_stages_lengths_i1[i, 1])
    cat(paste("\nCurrent growth stage = ", period_name_i1))
    
    
    rast_filename_d_i1 <-
      as.character(paste0(
        "spatial_data/output/rast_",
        period_name_i1,
        "_d_",
        params$INN1, "_", params$MASK, 
        ".tif"
      ))
    
    if (!file.exists(here(rast_filename_d_i1))) {
      cat(paste("\n2 No spatraster"))
      
      if (!exists(paste0("vect_", period_name_i1, "_d"))) {
        cat(paste("\n3 No spatvector"))
        
        csv_filename_d_i1 <-
          as.character(
            paste(
              "tab_data/output/df_onset_",
              period_name_i1,
              "_d_",
              params$INN1, "_", params$MASK,
              ".csv",
              sep = ""
            )
          )
        
        if (!file.exists(here(csv_filename_d_i1))) {
          cat(paste("\n4 No csv data"))
          
          if (!exists(paste0("df_onset_", period_name_i1, "_d"))) {
            cat(paste("\n5 No df"))
            
            if (!exists(paste0(period_name_i1, "_matrix_days_d"))) {
              cat(paste("\n6 No matrix"))
              
              if (period_name_i1 == "total") {
                expr_3_d <- parse(
                  text = paste0(
                    "t(apply(df_onset_i1, 1, .growth_period_long_dekad_tbl_short, day_begin = \"onset\", day_end = \"",
                    df_growth_stages_lengths_i1[nrow(df_growth_stages_lengths_i1) - 1, 1],
                    "_e\", num_years = num_years_i1))"
                  )
                )
              } else {
                expr_3_d <- parse(
                  text = paste0(
                    "t(apply(df_onset_i1, 1, .growth_period_long_dekad_tbl_short, day_begin = \"",
                    period_name_i1,
                    "_s\",
        day_end = \"",
        period_name_i1,
        "_e\", num_years = num_years_i1))"
                  )
                )
              }
              
              assign(paste0(period_name_i1, "_matrix_days_d_i1"),
                     eval(expr_3_d))
              expr_3_d2 <- parse(
                  text = paste0(period_name_i1, "_matrix_days_d_i1 * 1000"))
              
              assign(paste0(period_name_i1, "_matrix_days_d_i1"), eval(expr_3_d2))
              
              eval(parse(text = paste0(
                "mode(", period_name_i1, "_matrix_days_d_i1) <- \"integer\""
              )))
              
              cat(paste("\n-6"))
            }
            
            assign(paste0("df_onset_", period_name_i1, "_d_i1"),
                   data.frame(df_onset_i1, get(
                     paste0(period_name_i1, "_matrix_days_d_i1")
                   )))
            
            cat(paste("\n-5"))
          }
          rm(list = paste0(period_name_i1, "_matrix_days_d_i1")) # remove matrix when df created
          write.csv(get(paste0("df_onset_", period_name_i1, "_d_i1")),
                    here(csv_filename_d_i1))
          
          cat(paste("\n-4"))
        }
        rm(list = paste0("df_onset_", period_name_i1, "_d_i1")) # remove df when csv created
        # assign(paste0("vect_", period_name, "_d"),
        #        vect(
        #          read_csv(
        #            here(csv_filename_d),
        #            show_col_types = FALSE,
        #            .name_repair = "unique_quiet"
        #          ),
        #          geom = c("x", "y"),
        #          crs = wkt_lam
        #        ))# gives an error due to unused argument (.name_repair = "unique_quiet")
        assign(paste0("vect_", period_name_i1, "_d_i1"),
               vect(
                 read_csv(
                   here(csv_filename_d_i1),
                   show_col_types = FALSE
                 ),
                 geom = c("x", "y"),
                 crs = wkt_lam
               ))
        cat(paste("\n-3"))
      }
      assign(paste0("list_rast_", period_name_i1, "_d_i1"),
             list())
      
      #create an empty raster
      assign(paste0("rast_", period_name_i1, "_d_i1"), rast())
      
      for (j in 1:36) {
        assign(
          paste0("rast_", period_name_i1, "_d_i1_", j),
          rasterize(get(
            paste0("vect_", period_name_i1, "_d_i1")
          ), rast_clim_mask_d_i1, field = paste0("X", j))
        )
        
        assign(paste0("list_rast_", period_name_i1, "_d_i1"),
               append(get(
                 paste0("list_rast_", period_name_i1, "_d_i1")
               ), paste0("rast_", period_name_i1, "_d_i1_", j)))
        expr_5_d <-
          parse(text = paste0(
            "add(rast_",
            period_name_i1,
            "_d_i1) <- (rast_",
            period_name_i1,
            "_d_i1_",
            j,
            ")"
          ))
        
        eval(expr_5_d)
        rm(list = paste0("rast_", period_name_i1, "_d_i1_", j)) # remove dekad rast when added to brick
        
      }
      
      rm(list = paste0("vect_", period_name_i1, "_d_i1")) # remove vect when raster created
      writeRaster(get(paste0("rast_", period_name_i1, "_d_i1")), here(rast_filename_d_i1), overwrite = TRUE)
      cat(paste("\n-2"))
    }
    
    assign(paste0("rast_", period_name_i1, "_d_i1"), rast(here(rast_filename_d_i1)))
    cat(paste0("\n", rast_filename_d_i1))
    
    expr_6_d <-
      parse(
        text = paste0(
          "names(rast_",
          period_name_i1,
          "_d_i1) <- c(\"Ja1\", \"Ja2\", \"Ja3\", \"Fe1\", \"Fe2\", \"Fe3\",\"Mr1\", \"Mr2\", \"Mr3\",\"Ap1\", \"Ap2\", \"Ap3\",\"My1\", \"My2\", \"My3\",\"Jn1\", \"Jn2\", \"Jn3\",\"Jl1\",\"Jl2\", \"Jl3\",\"Ag1\",\"Ag2\", \"Ag3\",\"Sp1\",\"Sp2\", \"Sp3\",\"Oc1\",\"Oc2\", \"Oc3\",\"No1\",\"No2\", \"No3\",\"De1\",\"De2\", \"De3\")"
        )
      )
    
    eval(expr_6_d)
    
#    plot(
#      get(paste0("rast_", period_name, "_d")),
#      maxnl = 36,
#      breaks = c(0, 0.25, 0.5, 0.75, 1),
#      axes = F,
#      plg = list(cex = 1, title = paste0(period_name))
#    )
    
  }
  cat(paste("\n-1"))
}
}
```
</div>

<div class="fold o">   
```{r i1_sowing_dates_sos_distribute_m, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=sos_crit_i1}

##-- monthly distribution --
if (sos_crit_i1) {
if (exists('rast_clim_mask_m_i1')) {
  for (i in seq_len(nrow(df_growth_stages_req_i1))) {
    period_name_i1 <- as.character(df_growth_stages_req_i1[i, 1])
    cat("period_name = ", period_name_i1, "\n")
    
    
    # load growth period rasters
    rast_filename_m_i1 <-
      as.character(paste0(
        "spatial_data/output/rast_",
        period_name_i1,
        "_m_",
        params$INN1, "_", params$MASK,
        ".tif"
      ))
    
    assign(paste0("rast_period_m_", period_name_i1, "_original_i1"),
           rast(here(rast_filename_m_i1))/1000) # divide by 1000 because the values were multiplied by 1000 when creating the matrix
    
    # reproject growth period rasters
    
    assign(
      paste0("rast_period_m_", period_name_i1, "_prj_i1"),
      terra::project(get(
        paste0("rast_period_m_", period_name_i1, "_original_i1")
      ),   rast_mask_proj_i1, "near")
    )
    
    # aggregate if necessary
    
    #calc_agg_factor_m <-
    #    (res(rast_mask_proj) / res(rast_period_m_total_prj))
    #  cat(paste("calculated aggregate factor m = ", calc_agg_factor_m))
    
    calc_agg_factor_m_i1 <-
      (res(rast_mask_proj_i1) / res(get(
        paste0("rast_period_m_", period_name_i1, "_prj_i1")
      )))
    
    cat(paste("calculated aggregate factor m = ", calc_agg_factor_m_i1))
    
    
    if (calc_agg_factor_m_i1[1] < 1) {
      calc_agg_factor_m_i1[1] <- 1
      
      # this means that the mask has a higher resolution than the precipitation raster so aggregation is not necessary and the precipitation raster will stay the same resolution
      
      cat(paste(
        "revised calculated aggregate factor m1 = ",
        calc_agg_factor_m_i1[1]
      ))
    }
    cat("\n")
    
    if (calc_agg_factor_m_i1[2] < 1) {
      calc_agg_factor_m_i1[2] <- 1
      cat(paste(
        "revised calculated aggregate factor m2 = ",
        calc_agg_factor_m_i1[2]
      ))
    }
    
    # resample
    
    cat(paste("aggregate and resample"))
    
    #    rast_period_m_total <-
    #    agg_resample(
    #      rast_period_m_total_prj,
    #      calc_agg_factor_m, "modal", "near")
    
    assign(
      paste0("rast_period_m_", period_name_i1, "_i1"),
      agg_resample(get(
        paste0("rast_period_m_", period_name_i1, "_prj_i1")
      ),
      calc_agg_factor_m_i1, "modal", "near", rast_mask_proj_i1)
    )
    
    # plot
    
    expr_7_m <-
      parse(
        text = paste0(
          "names(rast_period_m_",
          period_name_i1,
          "_i1) <- c(\"January\", \"February\", \"March\", \"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\")"
        )
      )
    
    eval(expr_7_m)
    plot(
      get(paste0("rast_period_m_", period_name_i1, "_i1")),
      maxnl = 12,
      breaks = c(0, 0.25, 0.5, 0.75, 1),
      axes = F,
      plg = list(cex = 1, title = paste0(period_name_i1))
    )
    
  }
}
}
```  
</div>    
 
<div class="fold o">   
```{r i1_sowing_dates_sos_distribute_d, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=sos_crit_i1}

# dekadal growth stages have been pre-modelled for the spatial onset of season

# for each of the growth stages for which there are requirements create a new raster brick

##-- dekadal distribution --

if (sos_crit_i1) {
if (exists('rast_clim_mask_d_i1')) {
  for (i in seq_len(nrow(df_growth_stages_req_i1))) {
    period_name_i1 <- as.character(df_growth_stages_req_i1[i, 1])
    cat("period_name = ", period_name_i1, "\n")
    
    
    # load growth period rasters
    rast_filename_d_i1 <-
      as.character(paste0(
        "spatial_data/output/rast_",
        period_name_i1,
        "_d_",
        params$INN1, "_", params$MASK,
        ".tif"
      ))
    
    assign(paste0("rast_period_d_", period_name_i1, "_original_i1"),
           rast(here(rast_filename_d_i1))/1000) # divide by 1000 because the values were multiplied by 1000 when creating the matrix
    
    # reproject growth period rasters
    
    assign(
      paste0("rast_period_d_", period_name_i1, "_prj_i1"),
      terra::project(get(
        paste0("rast_period_d_", period_name_i1, "_original_i1")
      ),   rast_mask_proj_i1, "near")
    )
    
    # aggregate if necessary
    
    #calc_agg_factor_d <-
    #    (res(rast_mask_proj) / res(rast_period_d_total_prj))
    #  cat(paste("calculated aggregate factor m = ", calc_agg_factor_d))
    
    calc_agg_factor_d_i1 <-
      (res(rast_mask_proj_i1) / res(get(
        paste0("rast_period_d_", period_name_i1, "_prj_i1")
      )))
    
    cat(paste("calculated aggregate factor d = ", calc_agg_factor_d_i1))
    
    
    if (calc_agg_factor_d_i1[1] < 1) {
      calc_agg_factor_d_i1[1] <- 1
      
      # this means that the mask has a higher resolution than the precipitation raster so aggregation is not necessary and the precipitation raster will stay the same resolution
      
      cat(paste(
        "revised calculated aggregate factor d1 = ",
        calc_agg_factor_d_i1[1]
      ))
    }
    cat("\n")
    
    if (calc_agg_factor_d_i1[2] < 1) {
      calc_agg_factor_d_i1[2] <- 1
      cat(paste(
        "revised calculated aggregate factor d2 = ",
        calc_agg_factor_d_i1[2]
      ))
    }
    
    # resample
    
    cat(paste("aggregate and resample"))
    
    #    rast_period_d_total <-
    #    agg_resample(
    #      rast_period_d_total_prj,
    #      calc_agg_factor_d, "modal", "near")
    
    assign(
      paste0("rast_period_d_", period_name_i1, "_i1"),
      agg_resample(get(
        paste0("rast_period_d_", period_name_i1, "_prj_i1")
      ),
      calc_agg_factor_d_i1, "modal", "near", rast_mask_proj_i1)
    )
    
    # plot
    
    expr_7_d <-
      parse(
        text = paste0(
          "names(rast_period_d_",
          period_name_i1,
          "_i1) <- c(\"Ja1\", \"Ja2\", \"Ja3\", \"Fe1\", \"Fe2\", \"Fe3\",\"Mr1\", \"Mr2\", \"Mr3\",\"Ap1\", \"Ap2\", \"Ap3\",\"My1\", \"My2\", \"My3\",\"Jn1\", \"Jn2\", \"Jn3\",\"Jl1\",\"Jl2\", \"Jl3\",\"Ag1\",\"Ag2\", \"Ag3\",\"Sp1\",\"Sp2\", \"Sp3\",\"Oc1\",\"Oc2\", \"Oc3\",\"No1\",\"No2\", \"No3\",\"De1\",\"De2\", \"De3\")"
        )
      )
    
    eval(expr_7_d)
    plot(
      get(paste0("rast_period_d_", period_name_i1, "_i1")),
      maxnl = 36,
      breaks = c(0, 0.25, 0.5, 0.75, 1),
      axes = F,
      plg = list(cex = 1, title = paste0(period_name_i1))
    )
    
  }
}
}
```     
</div> 

### Processing precipitation data

<div class="fold o">   
```{r i1_requirements_prec02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE}

df_priorities_clim_prec_m_i1 <-
  dplyr::filter(df_priorities_clim_i1, prec_temp == "p" &
                  temp_resolution == "m") # filter precipitation criteria

for (i in seq_len(nrow(df_growth_stages_req_prec_i1))) {
  period_name_i1 <- as.character(df_growth_stages_req_prec_i1[i, 1])
  print(paste("Criterion = ", df_priorities_clim_prec_m_i1[i, 4]))
  #      print(period_name)
  
  for (j in seq_len(nrow(df_priorities_clim_prec_m_i1))) {
    if (sum(df_priorities_clim_prec_m_i1[j, 'phen_stage'] == period_name_i1, na.rm = TRUE) == 1) {
      print(paste0("period_name = ", as.character(period_name_i1)))
      # crit_rownum <-
      #   which(df_priorities_clim_prec_m$phen_stage == period_name)
      assign(
        paste0(
          "rast_",
          df_priorities_clim_prec_m_i1[j, 12],
          "_rsmp_",
          df_growth_stages_req_prec_i1[i, 1], "_i1"
        ),
        sum(get(
          paste0("rast_", df_priorities_clim_prec_m_i1[j, 12], "_rsmp_i1")
        ) * get(
          paste0("rast_period_m_", df_growth_stages_req_prec_i1[i, 1], "_i1") #changed 14/05/2024
        ))
      )
      print(
        paste0(
          "rast_",
          df_priorities_clim_prec_m_i1[j, 12],
          "_rsmp_",
          df_growth_stages_req_prec_i1[i, 1], "_i1"
        )
      )
      #        plot_raster <-
      plot(get(
        paste0(
          "rast_",
          df_priorities_clim_prec_m_i1[j, 12],
          "_rsmp_",
          df_growth_stages_req_prec_i1[i, 1], "_i1"
        )
      ),
      main = paste0(
        "rast_period_m_",
        as.character(df_growth_stages_req_prec_i1[i, 1]), "_i1" 
      ))
      #        print(plot_raster)
      
      
      new_col_i1 <-
        get(
          paste0(
            "rast_",
            df_priorities_clim_prec_m_i1[j, 12],
            "_rsmp_",
            df_growth_stages_req_prec_i1[i , 1], "_i1"
          )
        ) %>% terra::extract(xy_i1) # extract the raster values using xy points
      
      new_col_i1 <- new_col_i1[[1]]
      
      df_irm_i1 <-
        dplyr::select(df_irm_i1,-any_of(c(as.character(
          paste0(df_priorities_clim_prec_m_i1[j, 3])
        )))) # remove column if name already exists
      
      df_irm_i1 <-
        mutate(df_irm_i1,!!as.character(paste0(df_priorities_clim_prec_m_i1[j, 3])) := new_col_i1,
               .keep = c("all"))   # add the raster values to the df_irm_i1 tibble, this needs to be dynamic so uses the !! and := operators
      
      
    } else {
      #    print(sum(df_priorities_clim_prec_m[, 'phen_stage'] == period_name, na.rm = TRUE))
    }
  }
}

df_priorities_clim_prec_d_i1 <-
  dplyr::filter(df_priorities_clim_i1, prec_temp == "p" &
                  temp_resolution == "d") # filter precipitation criteria

for (i in seq_len(nrow(df_growth_stages_req_prec_i1))) {
  period_name_i1 <- as.character(df_growth_stages_req_prec_i1[i, 1])
  print(paste("Criterion = ", df_priorities_clim_prec_d_i1[i, 4]))
  # print(paste("i =", i))
  # print(period_name)
  for (j in seq_len(nrow(df_priorities_clim_prec_d_i1))) {
      # print(paste("j =", j))
        if (sum(df_priorities_clim_prec_d_i1[j, 'phen_stage'] == period_name_i1, na.rm = TRUE) == 1) {
      print(paste0("period_name = ", as.character(period_name_i1)))
      
      # crit_rownum <-
      #   which(df_priorities_clim_prec_d$phen_stage == period_name)
      assign(
        paste0(
          "rast_",
          df_priorities_clim_prec_d_i1[j, 12],
          "_rsmp_",
          df_growth_stages_req_prec_i1[i, 1], "_i1"
        ),
        sum(get(
          paste0("rast_", df_priorities_clim_prec_d_i1[j, 12], "_rsmp_i1")
        ) * get(
          paste0("rast_period_d_", df_growth_stages_req_prec_i1[i, 1], "_i1")
        ))
      )
      print(
        paste0(
          "rast_",
          df_priorities_clim_prec_d_i1[j, 12],
          "_rsmp_",
          df_growth_stages_req_prec_i1[i, 1], "_i1"
        )
      )
      #        plot_raster <-
      plot(get(
        paste0(
          "rast_",
          df_priorities_clim_prec_d_i1[j, 12],
          "_rsmp_",
          df_growth_stages_req_prec_i1[i, 1], "_i1"
        )
      ),
      main = paste0(
        "rast_period_d_",
        as.character(df_growth_stages_req_prec_i1[i, 1]), "_i1" #changed 14/05/2024
      ))
      #        print(plot_raster)
      
      
      new_col_i1 <-
        get(
          paste0(
            "rast_",
            df_priorities_clim_prec_d_i1[j, 12],
            "_rsmp_",
            df_growth_stages_req_prec_i1[i , 1], "_i1"
          )
        ) %>% terra::extract(xy_i1) # extract the raster values using xy points
      
      new_col_i1 <- new_col_i1[[1]]
      
      df_irm_i1 <-
        dplyr::select(df_irm_i1, -any_of(c(as.character(
          paste0(df_priorities_clim_prec_d_i1[j, 3])
        )))) # remove column if name already exists
      
      df_irm_i1 <-
        mutate(df_irm_i1,
               !!as.character(paste0(df_priorities_clim_prec_d_i1[j, 3])) := new_col_i1,
               .keep = c("all"))   # add the raster values to the df_irm_i1 tibble, this needs to be dynamic so uses the !! and := operators
      
      
    } else {
      #   print(sum(df_priorities_clim_prec_d[, 'phen_stage'] == period_name, na.rm = TRUE))
    }
  }
}

df_priorities_clim_prec_i1 <-
  rbind(df_priorities_clim_prec_m_i1, df_priorities_clim_prec_d_i1)

``` 
</div>

### Processing temperature data

<div class="fold o">   
```{r i1_requirements_temp02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE}

# A Farrow 01/06/2023 the following assumes that there is only one temperature criterion per growth stage
# In fact there may be multiple so a different way of looping through the criteria is needed


# for monthly temperature data

# logic
# for each temperature criterion i
# for each phen stage for which there is a criterion j
# do the appropriate calculation


df_priorities_clim_temp_m_i1 <-
  dplyr::filter(df_priorities_clim_i1, prec_temp == "t" &
                  temp_resolution == "m") # filter temperature criteria

if (nrow(df_priorities_clim_temp_m_i1) > 0) {
  #1
  for (i in seq_len(nrow(df_priorities_clim_temp_m_i1))) {
    #2
    #print(paste("i = ", i))
    print(paste("Criterion = ", df_priorities_clim_temp_m_i1[i, 4]))
    for (j in seq_len(nrow(df_growth_stages_req_temp_i1))) {
      #3
      #print(paste("j = ", j))
      period_name_i1 <- as.character(df_growth_stages_req_temp_i1[j, 1])
      print(paste0("m period_name = ", as.character(period_name_i1)))
      if (sum(df_priorities_clim_temp_m_i1[i, 'phen_stage'] == period_name_i1, na.rm = TRUE) == 1) {
        #4
        if (df_priorities_clim_temp_m_i1[i, 14] == "mean") {
          #5
          print("mean")
          assign(
            paste0(
              "rast_",
              df_priorities_clim_temp_m_i1[i, 12],
              "_rsmp_",
              df_growth_stages_req_temp_i1[j, 1], "_i1"
            ),
            (sum(get(
              paste0("rast_", df_priorities_clim_temp_m_i1[i, 12], "_rsmp_i1")
            ) * get(
              paste0("rast_period_m_", df_growth_stages_req_temp_i1[j, 1], "_i1")
            )) / sum(get(
              paste0("rast_period_m_", df_growth_stages_req_temp_i1[j, 1], "_i1")
            )))
          )
        } else {
          #-5 5a
          if (df_priorities_clim_temp_m_i1[i, 14] == "min") {
            #6
            print("min")
            assign(
              paste0(
                "rast_",
                df_priorities_clim_temp_m_i1[i, 12],
                "_rsmp_",
                df_growth_stages_req_temp_i1[j, 1], "_i1"
              ),
              (min(get(
                paste0("rast_", df_priorities_clim_temp_m_i1[i, 12], "_rsmp_i1")
              ) / round(
                get(
                  paste0("rast_period_m_", df_growth_stages_req_temp_i1[j, 1], "_i1")
                )
              )))
            )
            
          } else {
            #-6 6a
            if (df_priorities_clim_temp_m_i1[i, 14] == "max") {
              #7
              print("max")
              assign(
                paste0(
                  "rast_",
                  df_priorities_clim_temp_m_i1[i, 12],
                  "_rsmp_",
                  df_growth_stages_req_temp_i1[j, 1], "_i1"
                ),
                (max(
                  get(
                    paste0("rast_", df_priorities_clim_temp_m_i1[i, 12], "_rsmp_i1")
                  ) * get(
                    paste0("rast_period_m_", df_growth_stages_req_temp_i1[j, 1], "_i1")
                  )
                ))
              )
              
            } else {
              #-7 7a
            } #-7a
          } #-6a
        } #-5a
        plot(get(
          paste0(
            "rast_",
            df_priorities_clim_temp_m_i1[i, 12],
            "_rsmp_",
            df_growth_stages_req_temp_i1[j, 1], "_i1"
          )
        ),
        main = paste0(
          "rast_period_m_",
          as.character(df_growth_stages_req_temp_i1[j, 1], "_i1")
        ))
        
        new_col_i1 <-
          get(
            paste0(
              "rast_",
              df_priorities_clim_temp_m_i1[i, 12],
              "_rsmp_",
              df_growth_stages_req_temp_i1[j , 1], "_i1"
            )
          ) %>% terra::extract(xy_i1) # extract the raster values using xy points
        
        new_col_i1 <- new_col_i1[[1]]
        
        df_irm_i1 <-
          dplyr::select(df_irm_i1,-any_of(c(as.character(
            paste0(df_priorities_clim_temp_m_i1[i, 3])
          )))) # remove column if name already exists
        
        df_irm_i1 <-
          mutate(df_irm_i1,
                 !!as.character(paste0(df_priorities_clim_temp_m_i1[i, 3])) := new_col_i1,
                 .keep = c("all"))   # add the raster values to the df_irm_i1 tibble, this needs to be dynamic so uses the !! and := operators
      } #-4
    }
  }
}




# for dekadal temperature data

df_priorities_clim_temp_d_i1 <-
  dplyr::filter(df_priorities_clim_i1, prec_temp == "t" &
                  temp_resolution == "d") # filter temperature criteria

if (nrow(df_priorities_clim_temp_d_i1) > 0) {
  #1
  for (i in seq_len(nrow(df_priorities_clim_temp_d_i1))) {
    #2
    #print(paste("i = ", i))
    print(paste("Criterion = ", df_priorities_clim_temp_d_i1[i, 4]))
    for (j in seq_len(nrow(df_growth_stages_req_temp_i1))) {
      #3
      print(paste("j = ", j))
      period_name_i1 <- as.character(df_growth_stages_req_temp_i1[j, 1])
      print(paste0("d period_name = ", as.character(period_name_i1)))
      if (sum(df_priorities_clim_temp_d_i1[i, 'phen_stage'] == period_name_i1, na.rm = TRUE) == 1) {
        #4
        if (df_priorities_clim_temp_d_i1[i, 14] == "mean") {
          #5
          print("mean")
          assign(
            paste0(
              "rast_",
              df_priorities_clim_temp_d_i1[i, 12],
              "_rsmp_",
              df_growth_stages_req_temp_i1[j, 1], "_i1"
            ),
            (sum(get(
              paste0("rast_", df_priorities_clim_temp_d_i1[i, 12], "_rsmp")
            ) * get(
              paste0("rast_period_d_", df_growth_stages_req_temp_i1[j, 1], "_i1")
            )) / sum(get(
              paste0("rast_period_d_", df_growth_stages_req_temp_i1[j, 1], "_i1")
            )))
          )
        } else {
          #-5 5a
          if (df_priorities_clim_temp_d_i1[i, 14] == "min") {
            #6
            print("min")
            assign(
              paste0(
                "rast_",
                df_priorities_clim_temp_d_i1[i, 12],
                "_rsmp_",
                df_growth_stages_req_temp_i1[j, 1], "_i1"
              ),
              (min(get(
                paste0("rast_", df_priorities_clim_temp_d_i1[i, 12], "_rsmp")
              ) / round(
                get(
                  paste0("rast_period_d_", df_growth_stages_req_temp_i1[j, 1], "_i1")
                )
              )))
            )
            
          } else {
            #-6 6a
            if (df_priorities_clim_temp_d_i1[i, 14] == "max") {
              #7
              print("max")
              assign(
                paste0(
                  "rast_",
                  df_priorities_clim_temp_d_i1[i, 12],
                  "_rsmp_",
                  df_growth_stages_req_temp_i1[j, 1], "_i1"
                ),
                (max(
                  get(
                    paste0("rast_", df_priorities_clim_temp_d_i1[i, 12], "_rsmp")
                  ) * get(
                    paste0("rast_period_d_", df_growth_stages_req_temp_i1[j, 1], "_i1")
                  )
                ))
              )
              
            } else {
              #-7 7a
            } #-7a
          } #-6a
        } #-5a
        plot(get(
          paste0(
            "rast_",
            df_priorities_clim_temp_d_i1[i, 12],
            "_rsmp_",
            df_growth_stages_req_temp_i1[j, 1], "_i1"
          )
        ),
        main = paste0(
          "rast_period_d_",
          as.character(df_growth_stages_req_temp_i1[j, 1], "_i1")
        ))
        
        new_col_i1 <-
          get(
            paste0(
              "rast_",
              df_priorities_clim_temp_d_i1[i, 12],
              "_rsmp_",
              df_growth_stages_req_temp_i1[j , 1], "_i1"
            )
          ) %>% terra::extract(xy_i1) # extract the raster values using xy points
        
        new_col_i1 <- new_col_i1[[1]]
        
        df_irm_i1 <-
          dplyr::select(df_irm_i1,-any_of(c(as.character(
            paste0(df_priorities_clim_temp_d_i1[i, 3])
          )))) # remove column if name already exists
        
        df_irm_i1 <-
          mutate(df_irm_i1,
                 !!as.character(paste0(df_priorities_clim_temp_d_i1[i, 3])) := new_col_i1,
                 .keep = c("all"))   # add the raster values to the df_irm_i1 tibble, this needs to be dynamic so uses the !! and := operators
      } #-4
    }
  }
}

df_priorities_clim_temp_i1 <-
  rbind(df_priorities_clim_temp_m_i1, df_priorities_clim_temp_d_i1)

```
</div> 


## Processing soil data

### Soil texture

If soil texture is a criterion then the USDA codes are reclassified quantitatively so that the fuzzy partitions can be applied.

Soil texture classes are reclassified in with 1, corresponding to S1 in Sys _et al._ (1993, p.159), 0.5 corresponding to S2, and 0 corresponding to S3, N1, N2 in Sys _et al._. 


```{r i1_reclass_soil_texture, results='asis'}

soil_texture_filename_i1 <-
  as.character(paste("tab_data/input/usda_texture_", params$INN1, ".csv", sep = ""))

if (file.exists(here(soil_texture_filename_i1))) {
  df_soil_texture_i1 <- read.csv(here(soil_texture_filename_i1))
  df_soil_texture_i1 %>%
    kable(digits = 3, caption = "Soil Texture ") %>% kable_styling("striped", full_width = T) %>% print
  
  df_priorities_texture_i1 <-
    dplyr::filter(df_raster_data_soil_i1, texture == 1) # filter temperature criteria
  # reclass using df_soil_texture table
  
  if (nrow(df_priorities_texture_i1) > 0) {
    
    #reclassify the texture raster (ensure that it is integer)
    rast_txt_clas_rsmp_i1 <- get(paste0("rast_", df_priorities_texture_i1[1, 12], "_rsmp_i1")) %>% as.int() %>% classify(as.matrix(
      dplyr::select(df_soil_texture_i1, USDA_Texture_Class, IRM_Value)
    ))
    
    #replace the texture raster in df_raster_data_soil
    text_rownum_i1 <- which(df_raster_data_soil_i1$texture == 1)
    
    df_raster_data_soil_i1[1, 12] <- "txt_clas"
    
    }
}

```



### Processing soil data horizons

If the criterion does not have a growth stage it is a soil property, and the values will need to be averaged, and weighted by the depth of each horizon, and possibly any other weights (e.g. Maghami Moghim, 2024). The simplest is to assume that each horizon has decreasing importance with depth, instead of applying a weight we assume that the depth of each horizon is the same - so we just calculate a simple average. Typical horizons in ISRIC data are:  

Depth             | Interval I | Interval II | Interval III | Interval IV | Interval V | Interval VI
------------------|------------|-------------|--------------|-------------|------------|-----------
Top depth (cm)    |	0          |	5          |	15          |	30          |	60         |	100
Bottom depth (cm  |	5          |	15         |	30          |	60          | 100        |	200


```{r i1_soil_horizon_weights_01, results='asis', warning=FALSE}

# averaging the values in the sifferent horizons
# there are two methods 1) use the thickness of each layer 2) assume that each layer contributes equally

for (i in seq_len(nrow(df_raster_data_soil_i1))) {
  cat(paste(df_raster_data_soil_i1[i, 3], "\n", df_raster_data_soil_i1[i, 4], "\n"))
  
  # method 1
  
  # # standard depths for interpolation
  # standard_depths <- c(0.025, 0.10, 0.225, 0.45, 0.80, 1.50)
  # 
  # # thicknesses of individual layers
  # bottom_layer <- c(0.05, 0.15, 0.30, 0.60, 1.0)
  # thickness <- diff(c(0, bottom_layer))
  # stopifnot(max(abs(
  #   bottom_layer - 0.5 *  thickness - standard_depths[1:5]
  # )) < 1.0e-6)
  # 
  # # horizon depth weighted
  # assign(
  #   paste0("rast_", df_raster_data_soil[i, 12], "_rsmp_1"),
  #   get(paste0("rast_", df_raster_data_soil[i, 12], "_rsmp")) %>% app(function(x) {
  #     sum((x * thickness) / sum(thickness))
  #   })
  # )
  # 
  # plot(get(paste0(
  #   "rast_", df_raster_data_soil[i, 12], "_rsmp_1"
  # )),
  # main = paste0("rast_", df_raster_data_soil[i, 12], "_rsmp_1"))
  # 
  # print("method 1")
  
  # method 2
  
  n_band_i1 <- dim(get(paste0("rast_", df_raster_data_soil_i1[i, 12], "_rsmp_i1")))[[3]]
  print(n_band_i1)
  
  # averaged equally across horizons
  assign(
    paste0("rast_", df_raster_data_soil_i1[i, 12], "_rsmp_i1"),
    get(paste0("rast_", df_raster_data_soil_i1[i, 12], "_rsmp_i1")) %>% app(function(x) {
      sum((x) / n_band_i1)
    })
  )
  
  plot(get(paste0(
    "rast_", df_raster_data_soil_i1[i, 12], "_rsmp_i1"
  )),
  main = paste0("rast_", df_raster_data_soil_i1[i, 12], "_rsmp_i1"))
  
  print("uses simple method")
}


```

<div class="fold o">   
```{r i1_soil_horizon_weights_02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE}

for (i in seq_len(nrow(df_raster_data_soil_i1))) {
  new_col_i1 <-
    get(paste0("rast_", df_raster_data_soil_i1[i, 12], "_rsmp_i1")) %>% terra::extract(xy_i1) # extract the raster values using xy points
  
  new_col_i1 <- new_col_i1[[1]]
  
  df_irm_i1 <-
    mutate(df_irm_i1,!!as.character(paste0(df_raster_data_soil_i1[i, 3])) := new_col_i1, .keep = c("all"))   # add the raster values to the df_irm_i1 tibble, this needs to be dynamic so uses the !! and := operators
  
}

```
</div>


```{r i1_extract_other_data}
## Add all other criteria data to the IRM spatial database
# some criteria use the same raster data so need to get those rows from df_priorities

df_priorities_single_i1 <- inner_join(df_priorities_i1, select(df_raster_data_single_i1, data_file_prefix), by = "data_file_prefix")

for (i in seq_len(nrow(df_priorities_single_i1))) {
  new_col_i1 <-
    get(paste0("rast_", df_priorities_single_i1[i, 12], "_rsmp_i1")) %>% terra::extract(xy_i1) # extract the raster values using xy points
  
  new_col_i1 <- new_col_i1[[1]]
  
  df_irm_i1 <-
    mutate(df_irm_i1,!!as.character(paste0(df_priorities_single_i1[i, 3])) := new_col_i1, .keep = c("all"))   # add the raster values to the df_irm_i1 tibble, this needs to be dynamic so uses the !! and := operators
  
}

```

# Evaluate lower level rule bases

```{r i1_get_lower_level_data, results = "asis"}

# join to original table using the criterion name

df_leaves_data_i1 <-
  left_join(df_leaves_criterion_i1,
            df_priorities_i1,
            by = c("rulebase_number"))

```



```{r i1_evaluate_lower_level_rules, time_it = TRUE, out.width="100%", results = "asis"}

# Function to populate a list of proposition and conclusion levels

prop_conc_i1 <- function(df_leaves_row_i1) {
  if (!is.na(df_leaves_row_i1["prop_level_3"])) {
    # for those criteria with three proposition values
    prop_levels_i1 <-
      as.character(df_leaves_row_i1[c("prop_level_1", "prop_level_2", "prop_level_3")])
    conc_levels_i1 <-
      df_leaves_row_i1[c("conclusion_1", "conclusion_2", "conclusion_3")]
  } else {
    # for those criteria with two proposition values
    prop_levels_i1 <-
      as.character(df_leaves_row_i1[c("prop_level_1", "prop_level_2")])
    conc_levels_i1 <- df_leaves_row_i1[c("conclusion_1", "conclusion_2")]
  }
  
  return(list(prop_levels_i1 = prop_levels_i1, conc_levels_i1 = conc_levels_i1))
}

result_list_i1 <- list()

cat("\n\n\n")
cat("## Fuzzy Partitions\n") # add headings
cat("\n\n\n")
  
  
# Main function
apply(df_leaves_data_i1, 1, function(df_leaves_row_i1) {

  # Calculate the value list within the main function
  prop_conc_list_i1 <- prop_conc_i1(df_leaves_row_i1)
  prop_levels_i1 <- prop_conc_list_i1$prop_levels_i1
  conc_levels_i1 <- prop_conc_list_i1$conc_levels_i1
  conc_suffixes_i1 <- lapply(conc_levels_i1, function(x)
    substr(x, 1, 1))
  
  cross_points_i1 <-
    as.numeric(c(df_leaves_row_i1["threshold"], ifelse(!is.na(df_leaves_row_i1["threshold2"]), df_leaves_row_i1["threshold2"], NA)))
  
  cross_points_i1 <- cross_points_i1[!is.na(cross_points_i1)]
  
  trans_width_i1 <-
    as.numeric(c(as.numeric(df_leaves_row_i1["width"]), ifelse(
      !is.na(as.numeric(df_leaves_row_i1["width2"])), as.numeric(df_leaves_row_i1["width2"]), NA
    )))
  
  trans_width_i1 <- trans_width_i1[!is.na(trans_width_i1)]
  
  cat("\n\n\n")
  cat("###", df_leaves_row_i1[["criterion"]], "\n") # add headings
  cat("\n\n\n")
      
  plot_xlim_i1 <-
    as.numeric(c((as.numeric(df_leaves_row_i1["threshold"]) - as.numeric(df_leaves_row_i1["width"])), (as.numeric(df_leaves_row_i1["threshold"]) + as.numeric(df_leaves_row_i1["width"]))))
  
  # construct the fuzzy partition
  assign(
    paste0("fp_", as.character(df_leaves_row_i1["rulebase_number"])),
    LinearFuzzyPartition(
      level = prop_levels_i1,
      crossoverPoint = cross_points_i1,
      transitionWidth = trans_width_i1
    ),
    .GlobalEnv
  )
  
  # construct the fuzzy partition plot
  plot_fp_i1 <- plot(
    get(paste0("fp_", as.character(df_leaves_row_i1["rulebase_number"]))),
    xlim = plot_xlim_i1,
    xlab = as.character(df_leaves_row_i1["criterion"]),
    title = "fuzzy partition"
  )
  
  # print the fuzzy partition plot
  print(plot_fp_i1)
  
  # construct the rule bases
  # set the proposition name
  
  Prop_name_i1 <-
    paste0(as.character(df_leaves_row_i1["rulebase_number"]))
  
  # set the conclusion name
  Conc_name_i1 <-
    paste0(as.character(df_leaves_row_i1["rulebase_number"]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop_i1 <- tibble(!!Prop_name_i1 := c(prop_levels_i1))
  # set the conclusion values
  df_conc_i1 <- tibble(!!Conc_name_i1 := c(conc_levels_i1))
  
  # new proposition and conclusion class objects are made here
  new_prop_i1 <- new("Proposition", table = df_prop_i1)
  new_conc_i1 <- new("Conclusion", table = df_conc_i1)
  
  assign(paste0("rb_",
                as.character(df_leaves_row_i1["rulebase_number"])),
         RuleBase(new_prop_i1, new_conc_i1),
         .GlobalEnv)
  
  cat("\n\nRule Base = \n")
  knitr::normal_print(
  print(get(paste0("rb_",
                   as.character(df_leaves_row_i1["rulebase_number"])))))
  
  # apply the fuzzy partitions to the data
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    as.character(df_leaves_row_i1["rulebase_number"]),
    ", newdata = df_irm_i1,",
    as.character(df_leaves_row_i1["rulebase_number"]),
    "=",
    "fp_",
    as.character(df_leaves_row_i1["rulebase_number"]),
    ")"
  )
  
  assign(paste0("fpm_",
                as.character(df_leaves_row_i1["rulebase_number"])), eval(parse(text = x)), .GlobalEnv)
  #print(conc_levels[1])
  
  # Define a function to print each element
  #print_element <- function(x) {
  #  print(x)
  #}
  
  
  # Function to get the membership values of the fuzzy partition matrix for each conclusion value
  # this only works when nested in main function
  
  fpm_values_i1 <- function(conc_value_i1) {
    
  fpm_name_i1 <-
     paste0("fpm_", df_leaves_row_i1["rulebase_number"], "$", conc_value_i1)
    #print(fpm_name)
    conc_col_name_i1 <-
      paste0(df_leaves_row_i1["rulebase_number"], "_", substr(conc_value_i1, 1, 1))
    #print(paste0("suffix = _", substr(conc_value, 1, 1)))
    x <- paste0("getMembership(", fpm_name_i1, ")")
    #print(x)
    #print(eval(parse(text = x)))
    
    # this works
     #result_list <<-
    #   c(result_list, setNames(list(eval(parse(
    #     text = x
    #   ))), conc_col_name))
     
     # construct the fuzzy partition
  assign(paste("result_list_i1"),
     c(result_list_i1, setNames(list(eval(parse(
         text = x
       ))), conc_col_name_i1)),
    .GlobalEnv
  )
    cat(conc_col_name_i1)
    #return(result_list)
  }
  
  # apply the fpm_values to the list of conclusion levels and generate a list of values (result_list)
  lapply(unique(conc_levels_i1), fpm_values_i1)
  #print("done 2")
  #return(result_list)
  
})


# Convert the result list to a data frame
result_df_i1 <- data.frame(matrix(unlist(result_list_i1), ncol = length(result_list_i1), byrow = FALSE))
colnames(result_df_i1) <- names(result_list_i1)

# Bind the result data frame to the original data frame
df_irm_i1 <- cbind(df_irm_i1, result_df_i1)

# Print the updated data frame
#print(df_irm_i1)
cat("\n\n\n")
cat("## Evaluate Rules\n") # add headings
cat("\n\n\n")


# Plot function for evaluated fuzzy partition using main data frame - rowwise across criteria
apply(df_leaves_data_i1, 1, function(df_leaves_row_i1) {
  
  cat("\n\n\n")
  cat("###", df_leaves_row_i1[["criterion"]], "\n") # add headings
  cat("\n\n\n")
  
  prop_conc_list_i1 <- prop_conc_i1(df_leaves_row_i1)
  conc_levels_i1 <- prop_conc_list_i1$conc_levels_i1
  conc_suffixes_i1 <- lapply(conc_levels_i1, function(x)
    substr(x, 1, 1))
  
  # Function to print each conclusion value - per unique object in list of conclusion values
  # this only works when nested in print function
  
  plot_fpm_i1 <- function(conc_value_i1) {
    conc_col_name_i1 <-
      paste0(df_leaves_row_i1["rulebase_number"], "_", substr(conc_value_i1, 1, 1))
    fpm_conc_var_i1 <- c(conc_col_name_i1, "x" , "y")
    fpm_conc_name_i1 <- conc_value_i1

    # spatialise the results
    sf_fpm_i1 <- df_irm_i1 %>%
      dplyr::select(unlist(as.character(noquote(fpm_conc_var_i1)))) %>%
      na.omit() %>%
      st_as_sf(coords = c("x", "y")) %>% na.omit()
    
    # rasterize
    rast_fpm_i1 <-  rasterize(sf_fpm_i1, rast_mask_proj_i1, fpm_conc_var_i1[[1]]) 
    
    # give the rast sensible names
    names(rast_fpm_i1) <- fpm_conc_name_i1
    
    # plot rast using title
    #plot_conc <-
    cat(paste(conc_col_name_i1, "\n\n")) 
    rast_fpm_i1 %>% plot(
      breaks = c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1),
      axes = F,
      main = paste(df_leaves_row_i1[["criterion"]], "-", conc_value_i1)
    )
    cat("\n\n") 
  }
  
  # apply the plot_fpm to the list of conclusion levels and generate plots
  lapply(unique(conc_levels_i1), plot_fpm_i1)
  
  #print("done 4")
  #return(plot_fpm)

})

```

# Higher-level rule base evaluation


``` {r i1_evaluate_higher_level_rules, out.width="100%", results = 'asis' }

# inverse join df_leaves_data to df_priorities

df_rulebases_i1 <-
  anti_join(df_priorities_i1,
            df_leaves_data_i1,
            by = 'rulebase_number',
            copy = FALSE)

#  join df_rulebases to hierarchies_new

# first split hierarchies_new based on hierarchy level

# get highest level

hierarchy_level_max_i1 <- max(unique(hierarchies_new_i1$level_number))
cat(paste("Highest hierarchy level = ", hierarchy_level_max_i1, "\n"))

# initialise FAO limits raster list
list_rast_clas_FAO_cat <- list()

# initialise FAO limits raster list
list_rast_limits_max_FAO <- list()


# for loop to run through all hierarchy levels from biggest to smallest
for (i in hierarchy_level_max_i1:1) {
  cat(paste0('\nLevel', i, "\n"))
  
  # join to the rulebases
  assign(paste0("df_hierarchy_i1_", i),
         inner_join(
           select(df_rulebases_i1, rulebase_number, conclusion_1, conclusion_2, conclusion_3),
           dplyr::filter(select(
             hierarchies_new_i1, level_number, paste0('level', i)
           ), level_number == i),
           by = c('rulebase_number' = paste0('level', i))
         ))
  
  # if no data move to next
  if (nrow(get(paste0("df_hierarchy_i1_", i)) != 0)) {
    cat(paste0("\nLevel", i, " has higher rule bases"))
    
    #Custom function to perform one-to-many join for each row and evaluate rule base
    eval_rule_base_i1 <- function(row) {
      
      # conc_options <-
      #   c(row[["conclusion_1"]], row[["conclusion_2"]], row[["conclusion_3"]])
      # print(conc_options)
      # print(paste("conc_options = ", conc_options))
      
      df_row_i1 <- data.frame(rulebase_number = row[["rulebase_number"]])
      df_one_many_i1 <-
        left_join(
          df_row_i1,
          df_priorities_i1,
          by = c('rulebase_number' = 'rulebase_stack'),
          keep = TRUE
        )
      
      cat("\n\n\n")
      cat("##", unique(df_one_many_i1[["stack"]]), "\n")
      cat("\n\n\n")
      conc_name_i1 <- unique(df_one_many_i1[["rulebase_stack"]])
      
      # cat("\n\nStack = ", df_one_many[["rulebase_stack"]], df_one_many[["stack"]])
      cat("\n\nCriterion = ", df_one_many_i1[["criterion"]])
      # cat("\n\nconc_name = ", conc_name)
      
      
      ### GET OR ADD TO THE FUZZY PARTITION LIST ###
      
      fp_list_i1 <- fn_fill_fp_list(df_one_many_i1) # function gets the fp list
      
      assign(paste0("fp_", conc_name_i1, "_list"),
             fp_list_i1,
             .GlobalEnv) # make a globally available named list
      
      ### GET WEIGHTS ###
      
      weights_i1 <- df_one_many_i1$weight
      weights_glob_i1 <<- weights_i1
      cat(paste0("\n\nWeights = ", weights_i1))
      
      ### CONSTRUCT THE NEW RULE BASE ###    
      
      rb_prefix <- "rb_"
      df_one_many_i1$rb <-
        paste(rb_prefix, df_one_many_i1$rulebase_number.y, sep = "")

      lower_rb_i1 <- df_one_many_i1$rb      # get the rule bases
      # get and print the lower rule bases to ensure that these are available
      #cat(paste("lower_rb = ", lower_rb))
      #str(lower_rb)
      lower_rb_glob_i1 <<-
        lower_rb_i1      # save to global env for debugging
      
      lower_rb_concs_i1 <- lapply(lower_rb_i1, fn_get_rb_conc)
      lower_rb_concs_glob_i1 <<- (lower_rb_concs_i1)      
      lower_rb_props_i1 <- lapply(lower_rb_i1, fn_get_rb_prop)
      lower_rb_props_glob_i1 <<- (lower_rb_props_i1) 
       
      # print(paste("str(lower_rb_concs) =", str(lower_rb_concs)))
      # print(paste("lower_rb_concs =", lower_rb_concs))

      results_rb_i1  <- fn_create_rb(lower_rb_concs_i1, weights_i1, conc_name_i1)
      #str(results_rb)
      result_rb_i1 <- unlist(results_rb_i1[[1]])
      cat("\n\nRule Base = \n")
      #cat(paste(result_rb, "\n"))
      print(result_rb_i1)
      result_rb_conc_i1 <- unlist(results_rb_i1[[2]])
      #cat("\nresult_rb_conc = \n")
      #print(result_rb_conc)

                  
      assign(paste0("rb_", conc_name_i1), result_rb_i1, .GlobalEnv)
      
      
      ### GET OR ADD TO THE RULE BASE STACK ###
      
      rb_list <- fn_fill_rb_list(df_one_many_i1)
      rb_list <-  append(rb_list, paste0("rb_", conc_name_i1))
      rb_list_glob_i1 <<- rb_list
      #cat("\nrb_list = \n")
      #print(rb_list)   
      
      assign(paste0("rb_list_", conc_name_i1), rb_list,
             .GlobalEnv) # convert to rule base list

      newList_i1 <- list("df" = df_one_many_i1, "fp" = fp_list_i1 , "rb" = result_rb_i1, rbs = rb_list)

      
 
      
      # print(get(paste0("rb_list_", conc_name)))
      # str(get(paste0("rb_list_", conc_name)))
      
      # # create the rule base stack from the list
      x <-
        paste("stack(", gsub(",$", "", paste0(
          get(paste0("rb_list_", conc_name_i1)), sep = ",", collapse = ""
        )), ")")
      
      #cat("\nx = \n")
      #print(x)
      
      assign(paste0("rbs_", conc_name_i1, "_i1"), eval(parse(text = x)),
             .GlobalEnv)
      #print(get(paste0("rbs_", conc_name)))
      
      # # evaluate the rule base stack
      
      w <-
        paste0("predict(",
              "rbs_",
              conc_name_i1,
              "_i1, newdata = df_irm_i1,",
              gsub(",$", "", paste0(
                fp_list_i1, sep = ",", collapse = ""
              )),
              ")")
      
      #cat("\nw = \n")
      #print(w)
      assign(paste0("fpm_", conc_name_i1, "_i1"), eval(parse(text = w)),
             .GlobalEnv)

      
      # columns defined by conclusions to rule base
      
      fpm_colnames_i1 <<- pull(distinct(result_rb_conc_i1@table))
      
      #cat("\nfpm_colnames = \n")
      #print(fpm_colnames)
      
      for (j in 1:length(fpm_colnames_i1)) {
        
      col_suffix_i1 <-   substr( fpm_colnames_i1[[j]] , start = 1 , stop = 1 )
      #cat("\ncol_suffix = \n")
      #print(col_suffix)
      
      mem_text_i1 <- paste0("getMembership(","fpm_", conc_name_i1, "_i1$", fpm_colnames_i1[[j]],")")
      #print(mem_text)
      membership_i1 <- eval(parse(text = mem_text_i1))
      
      df_irm_i1 <<-
        mutate(df_irm_i1,!!as.character(paste0(conc_name_i1, "_", col_suffix_i1)) := membership_i1, .keep = c("all"))
        
      }
   
      n_i1 = length(fpm_colnames_i1)
      fpm_conc_var_i1 <- c()
      for (j in 1:length(fpm_colnames_i1)) {
        col_suffix_i1 <-   substr(fpm_colnames_i1[[j]] , start = 1 , stop = 1)
        fpm_conc_var_i1 <-
          c(fpm_conc_var_i1, paste0(conc_name_i1, "_", col_suffix_i1))
      }
      
      fpm_conc_var_i1 <-    c(fpm_conc_var_i1, "x" , "y")
      fpm_conc_name_i1 <- fpm_colnames_i1
      fpm_plot_title_i1 <-    paste(unique(df_one_many_i1[["stack"]]))
      
      plot_fpm_i1 <-
        rasterize_plot_fpm(
          n_i1,
          fpm_conc_var_i1,
          fpm_conc_name_i1,
          df_irm_i1,
          fpm_plot_title_i1,
          rast_mask_proj_i1
        )
      
      print(plot_fpm_i1)
 
      if (i <= params$FAOCLASS1) {
        FAO_leaflet_widget_i1 <<-
          classify_maps_FAO(
            n_i1,
            fpm_conc_var_i1,
            fpm_conc_name_i1,
            df_irm_i1,
            fpm_plot_title_i1,
            df_one_many_i1,
            rast_mask_proj_i1,
            list_rast_clas_FAO_cat,
            vect_subdiv_i1,
            params$INN1
          )
        
      }
      
      if (i <= params$LIMITS1) {
        FAO_limits_leaflet_widget_i1 <<-
          classify_maps_limits(
            n_i1,
            fpm_conc_var_i1,
            fpm_conc_name_i1,
            df_irm_i1,
            fpm_plot_title_i1,
            df_one_many_i1,
            weights_i1,
            rast_mask_proj_i1,
            vect_subdiv_i1,
            list_rast_limits_max_FAO,
            params$INN1
          )
        
      }
      
      return(newList_i1)
      
     }
    
    # Apply the rule base evaluation function to each row of df1
    assign(paste0("df_one_many_i1_", i),
           apply(get(paste0("df_hierarchy_i1_", i)), 1, eval_rule_base_i1))
    
  }
}


```

```{r i1_leaflet_FAO, results = 'asis', out.width="100%"}
if ( params$FAOCLASS1 > 0){
  cat(paste("\n\n## Interactive Classified Map - FAO Suitability Classes \n\n"))
  frameWidget(FAO_leaflet_widget_i1, height = '500')}

```

```{r i1_leaflet_FAOlimits, results = 'asis', out.width="100%"}
if ( params$LIMITS1 > 0){
  cat(paste("\n\n## Interactive Classified Map - FAO Limitations Classes \n\n"))
  frameWidget(FAO_limits_leaflet_widget_i1, height = '500')}

```

# Sub-division statistics

This section gets the statistics for each sub-division, taking into account the dynamically created limitations for adoption, suitability and feasibility.


The existing function expects arguments showing:

1) the number of maps to produce - one per class (of whatever output)
2) a vector of the variables (classes) that need to be mapped (1 and 2 are linked and 1 is not really necessary)
3) a palette of colours with the same number of colours as classes - these are 

The palettes in the current IRM do not match with the any of the colours used in the classified maps.
Instead they are just a distinct colour.

The variables and colour palette names are currently hard coded. The names of the palettes are from the ggplot2 package but derive from colorbrewer, all palettes are sequential. There are 18 named sequential palettes, they can be referenced by name or as an index from the list.

The index works as long as the values do not exceed 18, so need to wrap.

## Area

### FAO Classes

```{r i1_subdiv_area_FAO, results = 'asis', out.width="100%"}

# create a list of valid names of colorbrewer palettes for sequential data
palettes_i1 <-
  c("Blues",
    "YlGn",
    "Greys",
    "Oranges",
    "YlOrRd"
  )


# loop through the FAO class rasters created above

for (i in 1:length(list_rast_clas_FAO_cat))   {
  # get the name of the criteria from the raster name - this is used in the plotting
  subdiv_criteria_name_i1 <- list_rast_clas_FAO_cat[i]
  subdiv_criteria_name_i1 <-
    sub(paste0(".*", "fao_cat"), "", subdiv_criteria_name_i1)
  
  cat("\n\n\n")
  cat("###", subdiv_criteria_name_i1, "\n") # add headings
  cat("\n\n\n")
  
  # get the raster for which statistics are derived for each limitation
  rast_to_plot_i1 <- get(paste0(list_rast_clas_FAO_cat[i]))
  
  # get the cellsize for each raster
  rast_to_plot_cellsize_i1 <- cellSize(rast_to_plot_i1, unit = "ha")
  
  
  # extract the raster class to a data frame using the subdivisions
  df_extr_i1 <-
    terra::extract(rast_to_plot_i1, vect_subdiv_i1, na.rm = TRUE, ID = T, weights = T)
  
    # extract the raster cellsize to a data frame using the subdivisions
  df_extr_cellsize_i1 <-
    terra::extract(rast_to_plot_cellsize_i1, vect_subdiv_i1, na.rm = TRUE, ID = T, weights = T)
  
  df_extr_i1 <- mutate(df_extr_i1, df_extr_cellsize_i1)
  
   # summarise the class for each subdivision raster ID
  df_extr_summary_i1 <- df_extr_i1 %>%
    group_by(ID) %>%
    count(FAO, wt = (area * weight), .drop = FALSE)
  
  # join the summary data frame to the original subdivision data spatvector
  vect_subdiv_extr_i1 <<-
    left_join(vect_subdiv_i1, df_extr_summary_i1, by = 'ID')
  
  # loop through each existing class type 
  for (class_type in unique(vect_subdiv_extr_i1$FAO)) {
    
    # Get the current iteration number
    j_i1 <- match(class_type, unique(vect_subdiv_extr_i1$FAO))

    # get the palette using the iteration number
    colour_index_i1 <- j_i1
    colour_index_mod_i1 <- (colour_index_i1 %% 18)
    colour_index_mod_i1 <-
      ifelse(colour_index_mod_i1 == 0, 18, colour_index_mod_i1)
    result_i1 <- palettes_i1[colour_index_mod_i1]
    
    # Filter the joined data for the current limitation
    filtered_data_i1 <-
      vect_subdiv_extr_i1[vect_subdiv_extr_i1$FAO == class_type,]
    #print(filtered_data)
    
    if (nrow(filtered_data_i1) == 0) {next} 

  
    # Create a ggplot for count value per subdivision for the current class type using the palette from above
    subdiv_plot_i1 <- ggplot() +
      geom_spatvector(data = filtered_data_i1, aes(group = params$SUBDIV1, fill = n)) +
      labs(
        title = paste(subdiv_criteria_name_i1, "\nClass = ", class_type),
        fill = "Area (ha)"
      ) +
      scale_fill_distiller(
        type = "seq",
        palette = result_i1,
        direction = 1,
        limits = c(0, max_area_i1),
        guide = "legend", labels = comma
      ) 
    
    print(subdiv_plot_i1)
  }
}  


```

### FAO Limitations

```{r i1_subdiv_area_FAOlimits, results = 'asis', out.width="100%"}

# create a list of valid names of colorbrewer palettes for sequential data
palettes_i1 <-
  c(
    "Blues",
    "BuGn",
    "BuPu",
    "GnBu",
    "Greens",
    "Greys",
    "Oranges",
    "OrRd",
    "PuBu",
    "PuBuGn",
    "PuRd",
    "Purples",
    "RdPu",
    "Reds",
    "YlGn",
    "YlGnBu",
    "YlOrBr",
    "YlOrRd"
  )


# loop through the limitation rasters created above

for (i in 1:length(list_rast_limits_max_FAO))   {
  # get the name of the criteria from the raster name - this is used in the plotting
  subdiv_criteria_name_i1 <- list_rast_limits_max_FAO[i]
  subdiv_criteria_name_i1 <-
    sub(paste0(".*", "FAO_"), "", subdiv_criteria_name_i1)
  
  cat("\n\n\n")
  cat("###", subdiv_criteria_name_i1, "\n") # add headings
  cat("\n\n\n")
  
  # get the raster for which statistics are derived for each limitation
  rast_to_plot_i1 <- get(paste0(list_rast_limits_max_FAO[i]))
  
  # get the cellsize for each raster
  rast_to_plot_cellsize_i1 <- cellSize(rast_to_plot_i1, unit = "ha")
  
  
  # extract the raster limitations to a data frame using the subdivisions
  df_extr_i1 <-
    terra::extract(rast_to_plot_i1, vect_subdiv_i1, na.rm = TRUE, ID = T, weights = T)
  
    # extract the raster cellsize to a data frame using the subdivisions
  df_extr_cellsize_i1 <-
    terra::extract(rast_to_plot_cellsize_i1, vect_subdiv_i1, na.rm = TRUE, ID = T, weights = T)
  
  df_extr_i1 <- mutate(df_extr_i1, df_extr_cellsize_i1)
  
   # summarise the limitations for each subdivision raster ID
  df_extr_summary_i1 <- df_extr_i1 %>%
    group_by(ID) %>%
    count(FAO_limit, wt = (area * weight), .drop = FALSE)
  
  # join the summary data frame to the original subdivision data spatvector
  vect_subdiv_extr_i1 <<-
    left_join(vect_subdiv_i1, df_extr_summary_i1, by = 'ID')
  
  # loop through each existing limitation type 
  for (limitation_type_i1 in unique(vect_subdiv_extr_i1$FAO_limit)) {
    
    # Get the current iteration number
    j <- match(limitation_type_i1, unique(vect_subdiv_extr_i1$FAO_limit))

    # get the palette using the iteration number
    colour_index_i1 <- j_i1
    colour_index_mod_i1 <- (colour_index_i1 %% 18)
    colour_index_mod_i1 <-
      ifelse(colour_index_mod_i1 == 0, 18, colour_index_mod_i1)
    result_i1 <- palettes_i1[colour_index_mod_i1]
    
    # Filter the joined data for the current limitation
    filtered_data_i1 <-
      vect_subdiv_extr_i1[vect_subdiv_extr_i1$FAO_limit == limitation_type_i1,]
    #print(filtered_data)
    if (nrow(filtered_data_i1) == 0) {next} 
    

    
    # Create a ggplot for count value per subdivision for the current limitation type using the palette from above
    subdiv_plot_i1 <- ggplot() +
      geom_spatvector(data = filtered_data_i1, aes(group = params$SUBDIV1, fill = n)) +
      labs(
        title = paste(subdiv_criteria_name_i1, "\nLimit = ", limitation_type_i1),
        fill = "Area (ha)"
      ) +
      scale_fill_distiller(
        type = "seq",
        palette = result_i1,
        direction = 1,
        limits = c(0, max_area_i1),
        guide = "legend", labels = comma
      ) 
    
    print(subdiv_plot_i1)
  }
}  


```

## Percentage

### FAO Classes

```{r i1_subdiv_pc_FAO, results = 'asis', out.width="100%"}

# create a list of valid names of colorbrewer palettes for sequential data
palettes_i1 <-
  c("Blues",
    "YlGn",
    "Greys",
    "Oranges",
    "YlOrRd"
  )


# loop through the FAO class rasters created above

for (i in 1:length(list_rast_clas_FAO_cat))   {
  # get the name of the criteria from the raster name - this is used in the plotting
  subdiv_criteria_name_i1 <- list_rast_clas_FAO_cat[i]
  subdiv_criteria_name_i1 <-
    sub(paste0(".*", "fao_cat"), "", subdiv_criteria_name_i1)
  
  cat("\n\n\n")
  cat("###", subdiv_criteria_name_i1, "\n") # add headings
  cat("\n\n\n")
  
  # get the raster for which statistics are derived for each limitation
  rast_to_plot_i1 <- get(paste0(list_rast_clas_FAO_cat[i]))
  
  # get the cellsize for each raster
  rast_to_plot_cellsize_i1 <- cellSize(rast_to_plot_i1, unit = "ha")
  
  
  # extract the raster class to a data frame using the subdivisions
  df_extr_i1 <-
    terra::extract(rast_to_plot_i1, vect_subdiv_i1, na.rm = TRUE, ID = T, weights = T)
  
    # extract the raster cellsize to a data frame using the subdivisions
  df_extr_cellsize_i1 <-
    terra::extract(rast_to_plot_cellsize_i1, vect_subdiv_i1, na.rm = TRUE, ID = T, weights = T)
  
  df_extr_i1 <- mutate(df_extr_i1, df_extr_cellsize_i1)
  
   # summarise the class for each subdivision raster ID
  df_extr_summary_i1 <- df_extr_i1 %>%
    group_by(ID) %>%
    count(FAO, wt = (area * weight), .drop = FALSE)
  
  # join the summary data frame to the original subdivision data spatvector
  vect_subdiv_extr_i1 <<-
    left_join(vect_subdiv_i1, df_extr_summary_i1, by = 'ID')
  
   # join the summary data frame to the subdivision area data frame
  vect_subdiv_extr_i1 <<-
    left_join(vect_subdiv_extr_i1, df_subdiv_area_i1, by = 'ID') 
  
  vect_subdiv_extr_i1 <<-
    mutate(vect_subdiv_extr_i1, area_pc = (n/ha)*100) 
  
  # loop through each existing class type 
  for (class_type in unique(vect_subdiv_extr_i1$FAO)) {
    
    # Get the current iteration number
    j_i1 <- match(class_type, unique(vect_subdiv_extr_i1$FAO))

    # get the palette using the iteration number
    colour_index_i1 <- j_i1
    colour_index_mod_i1 <- (colour_index_i1 %% 18)
    colour_index_mod_i1 <-
      ifelse(colour_index_mod_i1 == 0, 18, colour_index_mod_i1)
    result_i1 <- palettes_i1[colour_index_mod_i1]
    
    # Filter the joined data for the current limitation
    filtered_data_i1 <-
      vect_subdiv_extr_i1[vect_subdiv_extr_i1$FAO == class_type,]
    #print(filtered_data)
    if (nrow(filtered_data_i1) == 0) {next} 

    # Create a ggplot for count value per subdivision for the current class type using the palette from above
    
    filtered_data_global_i1 <<- filtered_data_i1
      
    subdiv_plot_i1 <- ggplot() +
      geom_spatvector(data = filtered_data_i1, aes(group = params$SUBDIV1, fill = area_pc)) +
      labs(
        title = paste(subdiv_criteria_name_i1, "\nClass = ", class_type),
        fill = "Area (%)"
      ) +
      scale_fill_distiller(
        type = "seq",
        palette = result_i1,
        direction = 1,
        limits = c(0, 101),
        guide = "legend", labels = comma
      ) 
    
    print(subdiv_plot_i1)
  }
}  


```

### FAO Limitations

```{r i1_subdiv_pc_FAOlimits, results = 'asis', out.width="100%"}

# create a list of valid names of colorbrewer palettes for sequential data
palettes_i1 <-
  c(
    "Blues",
    "BuGn",
    "BuPu",
    "GnBu",
    "Greens",
    "Greys",
    "Oranges",
    "OrRd",
    "PuBu",
    "PuBuGn",
    "PuRd",
    "Purples",
    "RdPu",
    "Reds",
    "YlGn",
    "YlGnBu",
    "YlOrBr",
    "YlOrRd"
  )


# loop through the limitation rasters created above

for (i in 1:length(list_rast_limits_max_FAO))   {
  # get the name of the criteria from the raster name - this is used in the plotting
  subdiv_criteria_name_i1 <- list_rast_limits_max_FAO[i]
  subdiv_criteria_name_i1 <-
    sub(paste0(".*", "FAO_"), "", subdiv_criteria_name_i1)
  
  cat("\n\n\n")
  cat("###", subdiv_criteria_name_i1, "\n") # add headings
  cat("\n\n\n")
  
  # get the raster for which statistics are derived for each limitation
  rast_to_plot_i1 <- get(paste0(list_rast_limits_max_FAO[i]))
  
  # get the cellsize for each raster
  rast_to_plot_cellsize_i1 <- cellSize(rast_to_plot_i1, unit = "ha")
  
  
  # extract the raster limitations to a data frame using the subdivisions
  df_extr_i1 <-
    terra::extract(rast_to_plot_i1, vect_subdiv_i1, na.rm = TRUE, ID = T, weights = T)
  
    # extract the raster cellsize to a data frame using the subdivisions
  df_extr_cellsize_i1 <-
    terra::extract(rast_to_plot_cellsize_i1, vect_subdiv_i1, na.rm = TRUE, ID = T, weights =T)
  
  df_extr_i1 <- mutate(df_extr_i1, df_extr_cellsize_i1)
  
   # summarise the limitations for each subdivision raster ID
  df_extr_summary_i1 <- df_extr_i1 %>%
    group_by(ID) %>%
    count(FAO_limit, wt = (area * weight), .drop = FALSE)
  
  # join the summary data frame to the original subdivision data spatvector
  vect_subdiv_extr_i1 <<-
    left_join(vect_subdiv_i1, df_extr_summary_i1, by = 'ID')
  
  # join the summary data frame to the subdivision area data frame
  vect_subdiv_extr_i1 <<-
    left_join(vect_subdiv_extr_i1, df_subdiv_area_i1, by = 'ID')
  
  vect_subdiv_extr_i1 <<-
    mutate(vect_subdiv_extr_i1, area_pc = (n / ha) * 100)  
  
  # loop through each existing limitation type 
  for (limitation_type_i1 in unique(vect_subdiv_extr_i1$FAO_limit)) {
    
    # Get the current iteration number
    j_i1 <- match(limitation_type_i1, unique(vect_subdiv_extr_i1$FAO_limit))

    # get the palette using the iteration number
    colour_index_i1 <- j_i1
    colour_index_mod_i1 <- (colour_index_i1 %% 18)
    colour_index_mod_i1 <-
      ifelse(colour_index_mod_i1 == 0, 18, colour_index_mod_i1)
    result_i1 <- palettes_i1[colour_index_mod_i1]
    
    # Filter the joined data for the current limitation
    filtered_data_i1 <-
      vect_subdiv_extr_i1[vect_subdiv_extr_i1$FAO_limit == limitation_type_i1,]
    #print(filtered_data)
    if (nrow(filtered_data_i1) == 0) {next} 
    
    # Create a ggplot for count value per subdivision for the current limitation type using the palette from above
    subdiv_plot_i1 <- ggplot() +
      geom_spatvector(data = filtered_data_i1, aes(group = params$SUBDIV1, fill = area_pc)) +
      labs(
        title = paste(subdiv_criteria_name_i1, "\nLimit = ", limitation_type_i1),
        fill = "Area (%)"
      ) +
      scale_fill_distiller(
        type = "seq",
        palette = result_i1,
        direction = 1,
        limits = c(0, 101),
        guide = "legend", labels = comma
      ) 
    
    print(subdiv_plot_i1)
  }
}  


```

# Calculate yields and production

## Yield proportion

The IRM script already calculates the optimality of the individual criteria as well as the climatic, landscape, soil fertility and soil physical properties groups of criteria.

The first method of calculating yield will calculate the product of the optimality of selected criteria.

<div class="fold o"> 
```{r i1_calc_yield_pc, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", include = TRUE, echo=FALSE, message=FALSE, warning=FALSE}

# get the criteria that contribute to yield

df_yield_rb_1_i1 <- dplyr::select(df_priorities_i1, "rulebase_number","criterion","yield") %>% dplyr::filter(!is.na(yield))

df_yield_rb_1_i1 %>% kable(digits = 3) %>% kable_styling("striped", full_width = T)  %>%  scroll_box(height = "500px")
# make an expression using the rule base numbers

yield_expr_i1 <- paste("df_irm_i1$yieldpc <- (")

for (i in seq(from = 1,
              to = nrow(df_yield_rb_1_i1),
              by = 1)) {
  yield_expr_i1 <- paste0(yield_expr_i1, "df_irm_i1$" , as.character(df_yield_rb_1_i1[i, 1]), "_o * ")
  
}
yield_expr_i1 <- paste(yield_expr_i1, " 100)")
yield_expr_i1

# evaluate the expression
eval(str2expression(yield_expr_i1))
# str(df_irm_i1$yieldpc)
if (summarise(df_irm_i1, Average = mean(yieldpc, na.rm = T)) > 0) {

# df_irm_i1 <- dplyr::select(df_irm_i1,-yield)

vect_yieldpc_i1 <- select(df_irm_i1, x, y, yieldpc) %>% na.omit %>% vect(geom = c("x", "y"))

rast_yieldpc_i1 <- rasterize(vect_yieldpc_i1, rast_mask_proj_i1, field="yieldpc")
names(rast_yieldpc_i1) <- c('yieldpc')

# export
output_geotiff(rast_yieldpc_i1, paste0("yieldpc_", params$INN1))

#  dy <- rast_yield %>%
#    as.data.frame(xy = TRUE) %>%
#    na.omit

  
  gy_i1 <- ggplot() +
    geom_spatraster(data = rast_yieldpc_i1, aes(fill = yieldpc)) +
    scale_fill_stepsn(
      paste0("Yield % \n", params$INN1),
      n.breaks = 10,
      limits = c(0, 100),
      colours = hcl.colors(palette = "Greens", 10, rev = TRUE),
      guide = "legend",  na.value = "transparent"
    ) +
#    scale_x_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
#    scale_y_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
    coord_sf()
  
  gy2_i1 <- add_subdiv_proj_simple_plot(gy_i1, vect_subdiv_i1)
gy2_i1
}
```
</div>

## Calculate yield

The IRM script converts yield proportion to yield using the yield values for sole crop or intercrop.

<div class="fold o"> 
```{r i1_calc_yield, cache = TRUE, cache.whatever=params$Agg, out.width="100%", include = TRUE, echo=FALSE, message=FALSE, warning=FALSE}

# get the criteria that contribute to yield

filename_yield_i1 <-
  as.character(paste("tab_data/input/yield_", params$INN1, ".csv", sep = ""))
df_yield_values_i1 <- read.csv(here(filename_yield_i1), na.strings = c("NA"))

df_yield_values_i1 %>% kable(digits = 3) %>% kable_styling("striped", full_width = T)  %>%  scroll_box(height = "100px")


if (params$INN2 == "NA") {
  df_irm_i1$yield <- df_irm_i1$yieldpc / 100 * df_yield_values_i1$YW
  cat("Sole crop yield")
} else {
  if (params$SYS == "comparison") {
    df_irm_i1$yield <- df_irm_i1$yieldpc / 100 * df_yield_values_i1$YW
    cat("Sole crop 1 yield (comparison)")
  } else {
    if (params$SYS == "intercrop") {
      df_irm_i1$yield <- df_irm_i1$yieldpc / 100 * df_yield_values_i1$YI
      cat("Intercrop 1 yield")
    } else {
      if (params$SYS == "rotation") {
        df_irm_i1$yield <- df_irm_i1$yieldpc / 100 * df_yield_values_i1$YW
        cat("Rotation crop 1 yield")
      }
    }
  }
}

if (summarise(df_irm_i1, Average = mean(yield, na.rm = T)) > 0) {
  
  vect_yield_i1 <-
    select(df_irm_i1, x, y, yield) %>% na.omit %>% vect(geom = c("x", "y"))
  
  rast_yield_i1 <- rasterize(vect_yield_i1, rast_mask_proj_i1, field = "yield")
  names(rast_yield_i1) <-  c('yield')

# export
output_geotiff(rast_yield_i1, paste0("yield_", params$INN1))

#dyd <- dByd %>%
#  as.data.frame(xy = TRUE) %>%
#  na.omit


gyd_i1 <- ggplot() +
  geom_spatraster(data = rast_yield_i1, aes(fill = yield)) +
  scale_fill_stepsn(
    paste0("Yield (kg/ha) \n", params$INN1),
    n.breaks = 10,
    colours = hcl.colors(palette = "OrRd", 10, rev = TRUE),
    guide = "legend",
    labels = comma,  na.value = "transparent"
  ) +
#  scale_x_continuous(
#    name = "",
#    labels = function(x) {
#      1.0e-3 * x
#    }
#  ) +
#  scale_y_continuous(
#    name = "",
#    labels = function(x) {
#      1.0e-3 * x
#    }
#  ) +
  coord_sf()

  gyd2_i1 <- add_subdiv_proj_simple_plot(gyd_i1, vect_subdiv_i1)
gyd2_i1
}
```
</div>

## Calculate production

The IRM script converts yield proportion to production using the yield values for sole crop or intercrop.

<div class="fold o">
```{r i1_calc_production, cache = TRUE, cache.whatever=params$Agg, out.width="100%", include = TRUE, echo=FALSE, message=FALSE, warning=FALSE}

# get the criteria that contribute to yield

#yield_filename <-
#  as.character(paste("tab_data/input/yield_", params$INN1, ".csv", sep = ""))
#yield_tab <- read.csv(here(yield_filename), na.strings = c("NA"))

#yield_tab %>% kable(digits = 3) %>% kable_styling("striped", full_width = T)  %>%  scroll_box(height = "150px")

df_irm_i1$production <- df_irm_i1$yieldpc *  Stat_factor_ha_i1

if (summarise(df_irm_i1, Average = mean(production, na.rm = T)) > 0) {
  vect_production_i1 <-
    select(df_irm_i1, x, y, production) %>% na.omit %>% vect(geom = c("x", "y"))
  
  rast_production_i1 <-
    rasterize(vect_production_i1, rast_mask_proj_i1, field = "production")
  names(rast_production_i1) <- c('production')
  
  # export
  output_geotiff(rast_production_i1, paste0("production_", params$INN1))
  
  #  dp <- dBp %>%
  #    as.data.frame(xy = TRUE) %>%
  #    na.omit
  
  gp_i1 <- ggplot() +
    geom_spatraster(data = rast_production_i1, aes(fill = production)) +
    scale_fill_stepsn(
      paste0("Production (kg) \n", params$INN1),
      n.breaks = 10,
      colours = hcl.colors(palette = "BuPu", 10, rev = TRUE),
      guide = "legend",
      labels = comma,
      na.value = "transparent"
    ) +
#    scale_x_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
#    scale_y_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
    coord_sf()
  
  gp2_i1 <- add_subdiv_proj_simple_plot(gp_i1, vect_subdiv_i1)
  gp2_i1
}
```
</div>


```{r innovation_name_i2_check01, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

if (params$INN2 == "NA") {
  cat("# Session Information
      ")
  
  si_1 <- sessionInfo()
  si_1
  
  
  cat(
    "# Acknowledgements

Javascript code and css style used in this script by Martin Schmelzer

https://stackoverflow.com/questions/37755037/how-to-add-code-folding-to-output-chunks-in-rmarkdown-html-documents


Timing for chunks by Yihui Xie
https://stackoverflow.com/questions/24595280/timing-for-chunks  "
  )
  
  knit_exit()
  
}  

```


```{r i2_initialise, echo=FALSE, message=FALSE, warning=FALSE}

#set (chunk) options - figure path is necessary to avoid an error message
opts_chunk$set(
  comment = NA,
  dpi = 96,
  echo = FALSE,
  fig.path = paste0("figures/", params$INN2,"/"),
  warning = FALSE,
  cache = FALSE,
  include = TRUE
)

```


```{r i2_innovation_parameters, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

cat("\n\n# Second Innovation\n\n")
cat("<div class='INN'>")
cat("Innovation name =", params$INN2)
cat("</div>")
cat("<div class='Agg'>")
cat("\n\nSpatially Dynamic Growing Season = ", params$SOS2)
cat("</div>")

# season onset non-spatial?
# this enables the script to skip the non relevant chunks when using console

if (params$SOS2 != 1){
    nonsos_crit_i2 <- TRUE
} else {nonsos_crit_i2 <- FALSE}

# season onset spatial?
if (params$SOS2 == 1){
    sos_crit_i2 <- TRUE
} else {sos_crit_i2 <- FALSE}

```

# Basic Settings

## Critera Parameters

Here we load most of the parameters used in the IRM model. These parameters are stored in an external text file, in comma separated format (.csv). 

The parameters include the criteria names, the rule base stack which they contribute to, and information to construct the rule bases.

The lowest level rule bases will have a spatial data source, with threshold values, and where relevant their weights. These criteria will have information about the propositions _and_ conclusions that are used to construct the rule base.

Higher level rule bases are combinations of the lower level criteria and do not have associated spatial data, but will often have weights. These criteria will only have information about the conclusions that are used to construct the rule base - the propositions are derived from the lower level rule bases.

The file will also contain information about how to aggregate and resample the spatial data, whether the data are for soil texture, precipitation or temperature, whether the criterion contributes to the yield estimation, the temporal resolution of any climate data, and a code used for mapping the limitations.


The criteria are organised hierarchically and can be displayed as a table and in a graphical diagram. 

```{r i2_load_criteria}
priorities_new_columns_filename_i2 <-
  as.character(paste(
    "tab_data/input/priorities_new_columns_",
    params$INN2,
    ".csv",
    sep = ""
  ))

df_priorities_i2 <-
  read.csv(here(priorities_new_columns_filename_i2), na.strings = c("NA"))
```


```{r i2_create_tree}
# remove any rows without data in the rulebase_number or criterion

df_priorities_i2 <- df_priorities_i2[complete.cases(df_priorities_i2$rulebase_number, df_priorities_i2$criterion), ]


df_priorities_short_i2 <-
  df_priorities_i2 %>% select(stack, criterion, weight, threshold, threshold2,	width,	width2)


df_priorities_short_i2$stack[is.na(df_priorities_short_i2$stack)] <-
  "root2"

# Convert to tree
tree_plot_i2 <- FromDataFrameNetwork(df_priorities_short_i2, c("weight", "threshold",	"threshold2",	"width",	"width2"
))

# Display the tree
print(tree_plot_i2, "weight", "threshold",	"threshold2",	"width",	"width2", "level") %>% kable(digits = 3, caption = "Hierarchies") %>% kable_styling("striped", full_width = T) %>%  row_spec(0, angle = -45) %>%  scroll_box(height = "500px")

```


```{r i2_get_hierarchy, results='asis' }
## Get the tree hierarchy for plotting

tree_max_level_i2 <- max(tree_plot_i2$Get('level')) - 1
cat("\n\nNumber of hierarchy levels", tree_max_level_i2, "\n\n")

hierarchies_new_i2 <- ToDataFrameTree(
  tree_plot_i2,
  level1 = function(x)
    x$path[2],
  level2 = function(x)
    x$path[3],
  level3 = function(x)
    x$path[4],
  level4 = function(x)
    x$path[5],
  level5 = function(x)
    x$path[6],
  level6 = function(x)
    x$path[7],
  level7 = function(x)
    x$path[8],
  
  level_number = function(x)
    x$level - 1
  
)[-1, -1]

# Display the df
#hierarchies_new %>% kable(digits = 3, caption = "Hierarchies") %>% kable_styling("striped", full_width = T) %>%  row_spec(0, angle = -45) %>%  scroll_box(height = "500px")

```

## Lower level rule bases with spatial data

```{r i2_get_leaves, results='asis', out.width="100%" }

n_leaves_i2 <- tree_plot_i2$leafCount
df_leaves_i2 <- ToDataFrameTypeCol(tree_plot_i2)

df_leaves_criterion_i2 <- as.data.frame( df_leaves_i2[cbind(seq(nrow(df_leaves_i2)), max.col(!is.na(df_leaves_i2), ties.method = 'last'))])
names(df_leaves_criterion_i2) <- c("criterion")
  
df_leaves_i2 %>% select(- level_1) %>% kable(digits = 3, caption = "Criteria with spatial data") %>% kable_styling("striped", full_width = T) %>%  scroll_box(height = "500px")

```

## Rule base hierarchy diagram

```{r i2_plot_hierarchy_diagram, results='asis', out.width="100%" }
# 
SetGraphStyle(
  tree_plot_i2,
  rankdir = "RL",
  overlap = "scalexy",
  fontsize = 400,
  fontname = "Calibri",
  label = paste("Rule bases for",params$INN2),
  labelloc = "t",
  ranksep = 1
)

SetNodeStyle(
  tree_plot_i2,
  shape = "box",
  fontsize = 200,
  fontname = "Helvetica",
  fontcolor = "black",
  fixedsize = "false",
  color = "DarkOliveGreen4",
  fillcolor = "OliveDrab2",
  style = "filled,rounded",
  penwidth = 10,
  tooltip = GetDefaultTooltip
)

SetEdgeStyle(
  tree_plot_i2,
  arrowhead = "none",
  color = "blue",
  penwidth = function(node) (node$weight * 50),
  dir = "back",
  label = function(node) paste("weight = :",node$weight),
  fontsize = 150,
  fontcolor = "blue"
)

level1 <- Traverse(tree_plot_i2, filterFun = function(x) x$level == 1)

Do(level1, function(node)
  SetEdgeStyle(
    node,
    inherit = FALSE,
    arrowhead = "none",
    color = "white",
    penwidth = function(node)
      (node$weight * 50),
    dir = "back",
    label = function(node)
      paste("weight = :", node$weight),
    fontsize = 150,
    fontcolor = "white"
  ))

Do(level1, function(node)
  SetNodeStyle(
    node,
    inherit = FALSE,
    shape = "oval",
    fixedsize = "false",
    width = 0.9,
    color = "white",
    fillcolor = "white",
    fontsize = 1,
    fontname = "Helvetica",
    fontcolor = "white",
    style = "filled"
  ))

level2 <- Traverse(tree_plot_i2, filterFun = function(x) x$level == 2)

Do(level2, function(node)
  SetNodeStyle(
    node,
    inherit = FALSE,
    shape = "oval",
    fixedsize = "false",
    width = 0.9,
    color = "lightblue",
    fillcolor = "darkgreen",
    fontsize = 200,
    fontname = "Helvetica",
    fontcolor = "white",
    style = "filled",
    tooltip = GetDefaultTooltip
  ))

Do(level2, function(node)
  SetEdgeStyle(
    node,
    inherit = FALSE,
    arrowhead = "none",
    color = "white",
    penwidth = function(node)
      (node$weight * 50),
    dir = "back",
    label = function(node)
      paste("weight = :", node$weight),
    fontsize = 150,
    fontcolor = "white",
    tooltip = GetDefaultTooltip
  ))

level3 <- Traverse(tree_plot_i2, filterFun = function(x) x$level == 3)

Do(level3, function(node)
 SetEdgeStyle(
  node,
  inherit = TRUE,
  arrowhead = "none",
  color = "blue",
  penwidth = function(node) (node$weight * 50),
  dir = "back",
  label = function(node) paste("weight = :",node$weight),
  fontsize = 150,
  fontcolor = "blue",
  tooltip = GetDefaultTooltip
))

Do(level3, function(node)
  SetNodeStyle(
    node,
    inherit = TRUE,
    shape = "oval",
    fixedsize = "false",
    width = 0.9,
    color = "lightblue",
    fillcolor = "blue",
    fontsize = 200,
    fontname = "Helvetica",
    fontcolor = "white",
    style = "filled",
    tooltip = GetDefaultTooltip
  ))

Do(tree_plot_i2$leaves, function(node)
  SetNodeStyle(
    node,
    shape = "box",
    fontsize = 200,
    fontname = "Helvetica",
    fontcolor = "black",
    fixedsize = "false",
    color = "DarkOliveGreen4",
    fillcolor = "OliveDrab2",
    style = "filled,rounded",
    penwidth = 10,
    tooltip = GetDefaultTooltip
  ))

Do(tree_plot_i2$leaves, function(node)
  SetEdgeStyle(
  node,
  arrowhead = "none",
  color = "blue",
  penwidth = function(node) (node$weight * 50),
  dir = "back",
  label = function(node) paste("weight = :",node$weight),
  fontsize = 150,
  fontcolor = "blue",
  tooltip = GetDefaultTooltip
))

plot(tree_plot_i2)

```

```{r i2_criteria_codes}

df_priorities_short_i2 <-
  df_priorities_i2 %>% select(rulebase_stack, rulebase_number, weight, threshold, threshold2,	width,	width2)


df_priorities_short_i2$rulebase_stack[is.na(df_priorities_short_i2$rulebase_stack)] <-
  "root2"

# Convert to tree
tree_new_i2 <- FromDataFrameNetwork(df_priorities_short_i2, c("weight", "threshold",	"threshold2",	"width",	"width2"
))

# Display the tree
#print(tree_new, "weight", "threshold",	"threshold2",	"width",	"width2", "level")

```

```{r i2_criteria_codes_get_hierarchy}
## Get the tree hierarchy

tree_max_level_i2 <- max(tree_new_i2$Get('level')) - 1
#cat("\n\nNumber of levels", tree_max_level, "\n\n")

hierarchies_new_i2 <- ToDataFrameTree(
  tree_new_i2,
  level1 = function(x)
    x$path[2],
  level2 = function(x)
    x$path[3],
  level3 = function(x)
    x$path[4],
  level4 = function(x)
    x$path[5],
  level5 = function(x)
    x$path[6],
  level6 = function(x)
    x$path[7],
  level7 = function(x)
    x$path[8],
  
  level_number = function(x)
    x$level - 1
  
)[-1, -1]

# Display the df
# hierarchies_new %>% kable(digits = 3, caption = "Hierarchies") %>% kable_styling("striped", full_width = T) %>%  row_spec(0, angle = -45) %>%  scroll_box(height = "500px")

```

```{r i2_criteria_codes_get_leaves}
## Get the tree leaves

n_leaves_i2 <- tree_new_i2$leafCount
df_leaves_i2 <- ToDataFrameTypeCol(tree_new_i2)

df_leaves_criterion_i2 <- as.data.frame( df_leaves_i2[cbind(seq(nrow(df_leaves_i2)), max.col(!is.na(df_leaves_i2), ties.method = 'last'))])
names(df_leaves_criterion_i2) <- c("rulebase_number")
  
```

# Load Spatial Data

Here we load all the spatial data. The data are used in different chunks below but it is easier to modify file names if all the spatial data are imported in the same chunk.

## Vector Data

The vector data include the sub-divisions of the area that is being modelled, and triangulation points if available.

The vector data are not projected and in geojson format. Here they are loaded and projected to the working crs.

<div class="fold o">   
```{r i2_spatialdataload_vector_01, cache = FALSE, out.width="100%", include = TRUE, echo=FALSE}

wkt_geo <-  paste0( "
  GEOGCRS[\"WGS 84 (with axis order normalized for visualization)\",
          ENSEMBLE[\"World Geodetic System 1984 ensemble\",
                   MEMBER[\"World Geodetic System 1984 (Transit)\",
                          ID[\"EPSG\",1166]],
                   MEMBER[\"World Geodetic System 1984 (G730)\",
                          ID[\"EPSG\",1152]],
                   MEMBER[\"World Geodetic System 1984 (G873)\",
                          ID[\"EPSG\",1153]],
                   MEMBER[\"World Geodetic System 1984 (G1150)\",
                          ID[\"EPSG\",1154]],
                   MEMBER[\"World Geodetic System 1984 (G1674)\",
                          ID[\"EPSG\",1155]],
                   MEMBER[\"World Geodetic System 1984 (G1762)\",
                          ID[\"EPSG\",1156]],
                   MEMBER[\"World Geodetic System 1984 (G2139)\",
                          ID[\"EPSG\",1309]],
                   ELLIPSOID[\"WGS 84\",6378137,298.257223563,
                             LENGTHUNIT[\"metre\",1],
                             ID[\"EPSG\",7030]],
                   ENSEMBLEACCURACY[2.0],
                   ID[\"EPSG\",6326]],
          PRIMEM[\"Greenwich\",0,
                 ANGLEUNIT[\"degree\",0.0174532925199433],
                 ID[\"EPSG\",8901]],
          CS[ellipsoidal,2],
          AXIS[\"geodetic longitude (Lon)\",east,
               ORDER[1],
               ANGLEUNIT[\"degree\",0.0174532925199433,
                         ID[\"EPSG\",9122]]],
          AXIS[\"geodetic latitude (Lat)\",north,
               ORDER[2],
               ANGLEUNIT[\"degree\",0.0174532925199433,
                         ID[\"EPSG\",9122]]],
          USAGE[
            SCOPE[\"Horizontal component of 3D system.\"],
            AREA[\"World.\"],
            BBOX[-90,-180,90,180]],
          REMARK[\"Axis order reversed compared to EPSG:4326\"]]")

vect_subdiv_i2 <- load_vector_data(paste0("subdiv_", params$INN2))

vect_subdiv_i2$ID <- seq.int(nrow(vect_subdiv_i2))# add an id field
vect_subdiv_i2$id <- formatC(vect_subdiv_i2$ID, width = 2, format = "d", flag = "0") #format the id field

df_subdiv_area_i2 <- as.data.frame(expanse(vect_subdiv_i2, unit="ha"))
df_subdiv_area_i2 <- cbind(df_subdiv_area_i2, as.data.frame(vect_subdiv_i2)$ID)
names(df_subdiv_area_i2) <- c("ha","ID")
#names(df_subdiv_area) <- c("ha")
max_area_i2 <- max(df_subdiv_area_i2)
 
 
vect_subdiv_extent_i2 <- ext(vect_subdiv_i2) # get the extent
nudge_xval_i2 <-
  ((vect_subdiv_extent_i2[2] - vect_subdiv_extent_i2[1]) / (nrow(vect_subdiv_i2) * 2.5))
nudge_yval_i2 <-
  ((vect_subdiv_extent_i2[4] - vect_subdiv_extent_i2[3]) / (nrow(vect_subdiv_i2) * 2.5))

vect_subdiv_pt_i2 <- centroids(vect_subdiv_i2)
expr <- paste0("vect_subdiv_pt_i2$", params$SUBDIV2)
vect_subdiv_pt_i2$subdiv_label <- paste(vect_subdiv_pt_i2$id, "=", eval(parse(text=(expr))))
vect_subdiv_pt_i2$subdiv_label <- factor(vect_subdiv_pt_i2$subdiv_label)

g_i2 <- ggplot()
gsubdiv_i2 <- add_subdiv_plot(g_i2, vect_subdiv_i2, vect_subdiv_pt_i2, nudge_xval_i2, nudge_yval_i2)
gsubdiv_i2

```
</div>

<div class="fold o">   
```{r i2_spatialdataload_vector_02, cache = FALSE, out.width="100%", include = TRUE, echo=FALSE}

vect_triangulation_i2 <- load_vector_data( paste0("triangulation_", params$INN2))

vect_triangulation_i2$ID <- seq.int(nrow(vect_triangulation_i2))# add an id field
vect_triangulation_i2$id <- formatC(vect_triangulation_i2$ID, width = 2, format = "d", flag = "0") #format the id field

vect_triangulation_extent_i2 <- ext(vect_triangulation_i2) # get the extent
nudge_xvaltri_i2 <-
  ((vect_triangulation_extent_i2[2] - vect_triangulation_extent_i2[1]) /  (nrow(vect_triangulation_i2) * 2.5))
#cat("nudge_xvaltri =", nudge_xvaltri)
nudge_yvaltri_i2 <-
  ((vect_triangulation_extent_i2[4] - vect_triangulation_extent_i2[3]) /  (nrow(vect_triangulation_i2) * 2.5))
#cat("nudge_yvaltri =", nudge_yvaltri)


if (!is.na(params$TRIAD2)) {
  expr <- paste0("vect_triangulation_i2$", params$TRIAD2)
  vect_triangulation_i2$tri_label_ad <-
    paste(vect_triangulation_i2$id, "=", eval(parse(text = (expr))))
  vect_triangulation_i2$tri_label_ad <-
    factor(vect_triangulation_i2$tri_label_ad)
  g_ad_i2 <- ggplot() +
      labs(title = paste("\nAdoption Triangulation Points - ", params$INN2))
  gtriangulation_ad_i2 <- add_triangulation_plot_no_labels_ad(g_ad_i2, vect_triangulation_i2)
  gtriangulation_ad_i2 <- add_subdiv_simple_plot(gtriangulation_ad_i2, vect_triangulation_i2)
  gtriangulation_ad_i2
}

if (!is.na(params$TRIBA2)) {
  expr <- paste0("vect_triangulation_i2$", params$TRIBA2)
  vect_triangulation_i2$tri_label_ba <-
    paste(vect_triangulation_i2$id, "=", eval(parse(text = (expr))))
  vect_triangulation_i2$tri_label_ba <-
    factor(vect_triangulation_i2$tri_label_ba)
  g_ba_i2 <- ggplot() +
      labs(title = paste("\nBiophysical Aptitude\nTriangulation Points - ", params$INN2))
  gtriangulation_ba_i2 <- add_triangulation_plot_no_labels_ba(g_ba_i2, vect_triangulation_i2)
  gtriangulation_ba_i2 <- add_subdiv_simple_plot(gtriangulation_ba_i2, vect_triangulation_i2)
  gtriangulation_ba_i2
}

if (!is.na(params$TRISE2)) {
  expr <- paste0("vect_triangulation_i2$", params$TRISE2)
  vect_triangulation_i2$tri_label_se <-
    paste(vect_triangulation_i2$id, "=", eval(parse(text = (expr))))
  vect_triangulation_i2$tri_label_se <-
    factor(vect_triangulation_i2$tri_label_se)
  g_se_i2 <- ggplot() +
      labs(title = paste("\nSocio-economic Feasibility\nTriangulation Points - ", params$INN2))
  gtriangulation_se_i2 <- add_triangulation_plot_no_labels_se(g_se_i2, vect_triangulation_i2)
  gtriangulation_se_i2 <- add_subdiv_simple_plot(gtriangulation_se_i2, vect_triangulation_i2)
  gtriangulation_se_i2
}

```
</div>


## Raster Data

The raster spatial data are loaded first.
Only the mask need be in the working crs.

<div class="fold o">   
```{r i2_spatialdataload_raster_01, results='asis', warning=FALSE}

# set the working crs using WKT arguments

wkt_lam <-  paste0(
    "PROJCRS[\"unknown\",
    BASEGEOGCRS[\"unknown\",
        DATUM[\"World Geodetic System 1984\",
            ELLIPSOID[\"WGS 84\",6378137,298.257223563,
                LENGTHUNIT[\"metre\",1]],
            ID[\"EPSG\",6326]],
        PRIMEM[\"Greenwich\",0,
            ANGLEUNIT[\"degree\",0.0174532925199433],
            ID[\"EPSG\",8901]]],
    CONVERSION[\"unknown\",
        METHOD[\"Lambert Azimuthal Equal Area\",
            ID[\"EPSG\",9820]],
        PARAMETER[\"Latitude of natural origin\",",
vect_subdiv_extent_i2[3],
    ",ANGLEUNIT[\"degree\",0.0174532925199433],
            ID[\"EPSG\",8801]],
        PARAMETER[\"Longitude of natural origin\",",
vect_subdiv_extent_i2[1],
    ",ANGLEUNIT[\"degree\",0.0174532925199433],
            ID[\"EPSG\",8802]],
        PARAMETER[\"False easting\",1000000,
            LENGTHUNIT[\"metre\",1],
            ID[\"EPSG\",8806]],
        PARAMETER[\"False northing\",1000000,
            LENGTHUNIT[\"metre\",1],
            ID[\"EPSG\",8807]]],
    CS[Cartesian,2],
        AXIS[\"(E)\",east,
            ORDER[1],
            LENGTHUNIT[\"metre\",1,
                ID[\"EPSG\",9001]]],
        AXIS[\"(N)\",north,
            ORDER[2],
            LENGTHUNIT[\"metre\",1,
                ID[\"EPSG\",9001]]]]"
  )


# project the country boundary to LAM

vect_subdiv_proj_i2 <-  project(vect_subdiv_i2, wkt_lam)
vect_subdiv_proj_extent_i2 <- terra::ext(vect_subdiv_proj_i2)

# make a basic raster with dimensions with 100m resolution 
# and projected crs 

rast_subdiv_mask_proj_extent_i2 <- rast(crs = wkt_lam, extent = vect_subdiv_proj_extent_i2, resolution = params$MASK, vals=c(1))

# make the mask based on the country boundary

rast_subdiv_mask_proj_i2 <- terra::rasterize(
      vect_subdiv_proj_i2,
      rast_subdiv_mask_proj_extent_i2,
      field = 1,
      background = NA, 
      touches = T
    ) 


# subset the priorities dataframe to keep only the records that have distinct raster data files

df_raster_data_i2 <- droplevels(distinct(df_priorities_i2,
                                      data_file_prefix,
                                      .keep_all = T)) %>% drop_na(data_file_prefix)


# for each record in the df_raster_data data frame use the data file prefix and the raster or brick variable to load the raster data, the name of the raster is generated automatically from the data file name
# these rasters needn't have the same crs as the working crs but must have the crs in the metadata (e.g. geotiff format)

for (i in seq(from = 1,
              to = nrow(df_raster_data_i2),
              by = 1)) {
  assign(
    paste0("rast_", df_raster_data_i2[i, 12]),
    load_raster_data(
      as.character(df_raster_data_i2[i, 12]),
      paste0("rast_", df_raster_data_i2[i, 12])
    )
  )
  cat(paste0("\n **rast_", df_raster_data_i2[i, 12], "** :\n"))
  print(get(paste0(
    "rast_", df_raster_data_i2[i, 12]
  )))
  cat(paste0("\n"))
}


```
</div>


# Common spatial resolution and extent

## Mask

Let's start with creating a 'mask', _i.e._, a raster map of the area of interest (1 = area to be modelled, NA = ignored). 

The properties of this map are shown below:

<div class="fold o">  
```{r i2_mask_make_plot, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, results='asis'}

if (params$Agg == 1){rast_mask_proj_i2 <- rast_subdiv_mask_proj_i2 } else {
  rast_mask_proj_i2 <- aggregate(rast_subdiv_mask_proj_i2, fact = params$Agg, na.rm=TRUE)}

res_rast_mask_proj_comma_i2 <- scales::label_comma(accuracy = NULL)(res(rast_mask_proj_i2))

g_i2 <- base_raster_plot(rast_mask_proj_i2, "layer", 'red', 'blue', paste0("Aggregated mask - Resolution = ", res_rast_mask_proj_comma_i2, "m"))

gsubdivsimple_i2 <- add_subdiv_simple_plot(g_i2, vect_subdiv_i2)
gsubdivsimple_i2

```
</div>

A factor is calculated to determine the area of each raster cell in hectares.

```{r i2_mask_area, cache = FALSE, warning=FALSE, results='asis' }

Stat_factor_ha_i2 <- ((xres(rast_mask_proj_i2)^2) / 10000) # factor used for statistical calculations divides the area of a raster cell (in m2) by 10000 to give the area of the cell in hectares

Stat_factor_ha_comma_i2 <- scales::label_comma(accuracy = NULL)(Stat_factor_ha_i2)

cat(paste(Stat_factor_ha_comma_i2, "hectares in each cell"))

```

## Rough crop, Reproject, Aggregate and Resample

In this section the input spatial data are cropped to the extent of the sub-division boundary, projected if necessary and then aggregated and resampled if necessary.


```{r i2_agg_resample_01, message=FALSE, warning=FALSE, cache=TRUE, out.width="100%", results='hide'}

# do a rough crop of the thematic data for the country extent in the CRS of the thematic data

for (i in seq(from = 1,
              to = nrow(df_raster_data_i2),
              by = 1)) {
  
  temp_crs <- crs(get(paste0("rast_", df_raster_data_i2[i, 12])))
  assign("vect_subdiv_temp_crs_i2",
         terra::project(vect_subdiv_i2, temp_crs))
  assign("vect_subdiv_temp_crs_extent_i2",
         terra::ext(vect_subdiv_temp_crs_i2))
  
  rast_roughcrop_filename_i2 <-
    paste0("spatial_data/input/rast_", df_raster_data_i2[i, 12], "_roughcrop_i2.tif")
  
  writeRaster(
    crop(get(paste0(
      "rast_", df_raster_data_i2[i, 12]
    )),
    vect_subdiv_temp_crs_extent_i2, touches=TRUE, extend=TRUE, mask=TRUE, snap = 'out'),
    here(rast_roughcrop_filename_i2),
    overwrite = TRUE
  )
  
  assign(paste0("rast_", df_raster_data_i2[i, 12], "_roughcrop_i2"),
         rast(here(rast_roughcrop_filename_i2)))
      

  gc()
}

 
```



<div class="fold o">   
```{r i2_agg_resample_02, cache = TRUE, out.width="100%", results='asis', warning=FALSE, message=FALSE}

# initialise empty vector of rasters

c_raster_data_rsmp_i2 <- c()

# create an empty data frame for climatic variables
df_raster_data_clim_i2 <- df_raster_data_i2[0,]

# create an empty data frame for soil variables with multiple horizons
df_raster_data_soil_i2 <- df_raster_data_i2[0,]

# create an empty data frame for variables with single band data
df_raster_data_single_i2 <- df_raster_data_i2[0,]


# reproject the raster data if necessary

for (i in seq(from = 1,
              to = nrow(df_raster_data_i2),
              by = 1)) {
  
  cat("\n\n")
  cat(paste("### ", as.character(df_raster_data_i2[i, 4])))
  cat("\n\n")
  
  # compare the crs of the raster with the working crs
# when different project the raster  
  
  if ( paste(crs(get(paste0("rast_", df_raster_data_i2[i, 12])))) %ni% paste(wkt_lam)) {  
  
  cat("different crs - ")  
  assign(
    paste0("rast_", df_raster_data_i2[i, 12], "_prj_i2"),
    raster_project(
      get(paste0("rast_", df_raster_data_i2[i, 12], "_roughcrop_i2")),
      #proj4_lam,
      as.character(df_raster_data_i2[i, 15]), rast_mask_proj_i2
    )
  )  
  
  } else {

   cat("same crs - ") 
# when not different just create a new raster with the same prj suffix  
    assign(
    paste0("rast_", df_raster_data_i2[i, 12], "_prj_i2"),
    get(paste0("rast_", df_raster_data_i2[i, 12], "_roughcrop_i2"))
      )
  }

# calculate aggregate factor for each criterion for both dimensions of the raster (these are the same for a square cell shape)
  
#  cat(paste(df_raster_data[i, 10],"\n"))

  calc_agg_factor_i2 <-
    (res(rast_mask_proj_i2) / res(get(paste0(
      "rast_", df_raster_data_i2[i, 12], "_prj_i2"
    ))))
  cat(paste("calculated aggregate factor = ", calc_agg_factor_i2))
  cat("\n")

 if (calc_agg_factor_i2[1] < 1) {
    calc_agg_factor_i2[1] <- 1
    
    # this means that the mask has a higher resolution than the precipitation raster so aggregation is not necessary and the precipitation raster will stay the same resolution
    
#    cat(paste("revised calculated aggregate factor 1 = ", calc_agg_factor[1],"\n"))
  }
  
  
  
  if (calc_agg_factor_i2[2] < 1) {
    calc_agg_factor_i2[2] <- 1
    cat(paste("revised calculated aggregate factor 2 = ", calc_agg_factor_i2[2]))
  }
  
  # for each record in the df_raster_data data frame use the data file prefix to recreate the raster name, and the aggregation and resample functions
#  cat(paste("aggregate and resample"))
  assign(
    paste0("rast_", df_raster_data_i2[i, 12], "_rsmp_i2"),
    agg_resample(
      get(paste0("rast_", df_raster_data_i2[i, 12], "_prj_i2")),
      calc_agg_factor_i2,
      as.character(df_raster_data_i2[i, 14]),
      as.character(df_raster_data_i2[i, 15]),
      rast_mask_proj_i2
    )
  )

c_raster_data_rsmp_i2 <- append(c_raster_data_rsmp_i2, get(paste0("rast_", df_raster_data_i2[i, 12], "_rsmp_i2"))) 
#  plot_raster <-
    terra::plot(
      get(paste0("rast_", df_raster_data_i2[i, 12], "_rsmp_i2")),
      main = paste0(
        as.character(df_raster_data_i2[i, 11]),
        "\n( ",
        as.character(df_raster_data_i2[i, 14]),
        ", ",
        as.character(df_raster_data_i2[i, 15]),
        ")"
      ),
      breaks = 10
   )
  #print(plot_raster)
  
  dim_rast_i2 <<- dim(get(paste0("rast_", df_raster_data_i2[i, 12], "_rsmp_i2")))

  cat(paste("\nDim = ", dim_rast_i2))
  cat("\n\n")
  
  if (dim_rast_i2[[3]] > 1) {
    if (!is.na(df_raster_data_i2[i, 16])) {
      df_raster_data_clim_i2 <-
        rbind(df_raster_data_clim_i2, df_raster_data_i2[i,])
    } else {
      df_raster_data_soil_i2 <-
        rbind(df_raster_data_soil_i2, df_raster_data_i2[i,])
    }
  } else {
    df_raster_data_single_i2 <-
      rbind(df_raster_data_single_i2, df_raster_data_i2[i,])
  }
  
  gc()    

#  plot_raster
#  terra::plot(rast_mask_proj, title = "") # this is needed (even if it is not actually plotted) to enable the plot of the raster
  
}


```
</div>


<div class="fold o">
```{r i2_agg_resample_03, cache = TRUE, out.width="100%", results='asis', warning=FALSE, message=FALSE}

# ensure that all rasters have data for the same area
# create new mask for data areas

rast_mask_proj_data_i2 <- mask(rast_mask_proj_i2, anyNA(c_raster_data_rsmp_i2), maskvalue=TRUE)
rast_mask_proj_data_i2
plot(rast_mask_proj_data_i2)

```
</div>

This mask designates the locations where predictions should be made, and an empty dataframe (tibble) is created with records for all locations.


<div class="fold o">   
```{r i2_mask03, cache = TRUE, cache.whatever=params$Agg, warning=FALSE }

# only run the models for the areas in the mask

df_irm_i2 <- geom(terra::as.points(rast_mask_proj_data_i2)) %>% as_tibble()

x <-  pull(df_irm_i2, x)
y <-  pull(df_irm_i2, y)
xy_i2 <- cbind(x, y)

#str(df_irm)

if (params$INT == 1)
  shiny::setProgress(0.17, message = "Resampling data 1st Innovation")  # set progress to 17%
``` 
</div>


# Convert raw data to criteria values

Raster data with multiple bands will need to be processed before adding to the df_irm_i2 data frame.

If the criterion has a growth stage name then it is climatic and will need to undergo the climatic processing.

## Processing climatic data

```{r i2_clim_data_temporal, results='asis'}

clim_raster_data_prefix_i2 <- df_raster_data_clim_i2$data_file_prefix
df_priorities_clim_i2 <- df_priorities_i2[0,]

for (i in clim_raster_data_prefix_i2) { 
# if any of the clim raster data prefix values are in the priorities 
df_priorities_clim_i2 <-
        rbind(df_priorities_clim_i2, subset(df_priorities_i2, grepl(paste0("\\b",i,"\\b"), df_priorities_i2$data_file_prefix)))
}


n_clim_i2 <- nrow(df_priorities_clim_i2)
cat(paste("\n\nThere are ", n_clim_i2, "Climatic criteria: \n"))

  for (i in 1:n_clim_i2) {
  cat(paste("\n",df_priorities_clim_i2[i, 4]," - "))
  rast_clim_mask_i2 <- get(paste0("rast_",df_priorities_clim_i2[i, 12], "_rsmp_i2"))
  if (paste(df_priorities_clim_i2[i, 25]) == "m") {
  rast_clim_mask_m_i2 <- rast_clim_mask_i2
  names(rast_clim_mask_m_i2) <- c(month.name)
  cat("monthly data\n")
  } else {
  rast_clim_mask_d_i2 <- rast_clim_mask_i2
  names(rast_clim_mask_d_i2) <- c(1:36)
  cat("dekadal data\n")}
  }

cat("\n\n")

```


<div class="fold o">   
```{r i2_clim_data_clean, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE}

## division by zero rainfall is infinitive, thus edited by Atkilt

if (exists('rast_clim_mask_m_i2')) {
  values(rast_clim_mask_m_i2)[values(rast_clim_mask_m_i2) >= 0] = 0
  values(rast_clim_mask_m_i2)[values(rast_clim_mask_m_i2) < 0] = NA
}

if (exists('rast_clim_mask_d_i2')) {
  values(rast_clim_mask_d_i2)[values(rast_clim_mask_d_i2) >= 0] = 0
  values(rast_clim_mask_d_i2)[values(rast_clim_mask_d_i2) < 0] = NA
}

```
</div>


```{r i2_growth_stages_01, echo=FALSE, results='asis'}

cat("\n\n#### Growth Stages\n

Here we load the table of the growth stages.\n")

```


<div class="fold o"> 
```{r i2_growth_stages_02, results='asis'}

# get the growth stages filename using the innovation parameter
growth_stages_filename_i2 <-
  as.character(paste("tab_data/input/growth_stages_", params$INN2, ".csv", sep = ""))

df_growth_stages_i2 <-  read.csv(here(growth_stages_filename_i2))

df_growth_stages_i2 %>% dplyr::filter(name != "sow_date") %>% select(-day)  %>%
  kable(digits = 3, caption = "Growth Stage Lengths") %>% kable_styling("striped", full_width = T) #%>% print

# create a new table just for where growth stage has requirements
df_growth_stages_req_i2 <-
  dplyr::filter(df_growth_stages_i2, (prec_criteria == 1 |
                                  temp_criteria == 1))
df_growth_stages_req_prec_i2 <-
  dplyr::filter(df_growth_stages_i2, prec_criteria == 1)
df_growth_stages_req_temp_i2 <-
  dplyr::filter(df_growth_stages_i2, temp_criteria == 1)

```
</div>


<div class="fold o"> 
```{r i2_sowing_dates_static_01, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, results='asis', eval=nonsos_crit_i2}

# see if one of the criteria is for the total growing period, if so then generate distribution

# this uses two functions from the irm package called .growth_period_long (for monthly data) and .growth_period_long_dekad (for dekadal data)

# both functions take three arguments: day_begin, and day_end in day numbers (obtained from the growth_stages_req table) and num_years which is calculated based on whether the growing season is spread across more than one calendar year


# for each of the growth stages for which there are requirements create a new raster brick
if (nonsos_crit_i2) {

cat("\n\n\n")
cat("#### Spatially Static Growing Seasons\n") # add headings
cat("\n\n\n")

cat(paste("\n\nSowing Date:", df_growth_stages_i2$day[[1]],"\n\n"))

# get the number of variables in growth_stages (excluding sowing/planting date and total length)

# create a list of the growth stages and determine the start and end days of each growth period

phen_tmp_i2 <- list()
for (i in seq_len(nrow(df_growth_stages_i2) - 1)) {
  phen_tmp_i2[[as.character(df_growth_stages_i2[i + 1, 1])]] <-
    df_growth_stages_i2[i + 1, 3]
}

phen_stages_beg_i2 <-
  df_growth_stages_i2$day[1] + c(0, cumsum(phen_tmp_i2)[c(-length(phen_tmp_i2), -(length(phen_tmp_i2)-1))], 0)
phen_stages_length_i2 <- unlist(phen_tmp_i2)
phen_stages_end_i2 <- phen_stages_beg_i2 + phen_stages_length_i2
names(phen_stages_beg_i2) <- names(phen_tmp_i2)
names(phen_stages_end_i2) <- names(phen_tmp_i2)

rbind(start = phen_stages_beg_i2, end = phen_stages_end_i2) %>%
  as.data.frame %>%
  kable(caption = "Growth Stage Days") %>% kable_styling("striped", full_width = T)  %>% print

num_years_i2 <- ceiling(phen_stages_end_i2[["total"]] / 365)
cat(paste("Growth Stages span", num_years_i2, "calendar years"))
}

```
</div>

<div class="fold o"> 
```{r i2_sowing_dates_static_02, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=nonsos_crit_i2, results='asis'}

if (nonsos_crit_i2) {
  
# monthly distribution
if (exists('rast_clim_mask_m_i2')) {
  for (i in seq_len(nrow(df_growth_stages_req_i2))) {
    period_name_i2 <- as.character(df_growth_stages_req_i2[i, 1])
    cat(paste("\n", period_name_i2," - monthly\n"))
    v_m_i2 <-
      .growth_period_long(phen_stages_beg_i2[period_name_i2], phen_stages_end_i2[period_name_i2], num_years_i2)
    assign(paste0("rast_period_m_", df_growth_stages_req_i2[i, 1], "_i2"),
           rast_clim_mask_m_i2 %>%
             app(function(x) {
               ifelse(is.na(x), NA_real_, v_m_i2)
             }))
    
#    plot_raster <-
      plot(
        get(paste0("rast_period_m_", df_growth_stages_req_i2[i, 1], "_i2")),
        maxnl = 12,
        breaks = c(0, 0.25, 0.5, 0.75, 1),
        axes = F,
        plg = list(cex = 1, title = paste0(df_growth_stages_req_i2[i, 1], "_i2"))
      )
#    print(plot_raster)
  }
}
# dekadal distribution
if (exists('rast_clim_mask_d_i2')) {
  for (i in seq_len(nrow(df_growth_stages_req_i2))) {
    period_name_i2 <- as.character(df_growth_stages_req_i2[i, 1])
    cat(paste("\n", period_name_i2," - dekad\n"))
    v_d_i2 <-
      .growth_period_long_dekad(phen_stages_beg_i2[period_name_i2], phen_stages_end_i2[period_name_i2], num_years_i2)
    assign(paste0("rast_period_d_", df_growth_stages_req_i2[i, 1], "_i2"),
           rast_clim_mask_d_i2 %>%
             app(function(x) {
               ifelse(is.na(x), NA_real_, v_d_i2)
             }))
    
#    plot_raster <-
      plot(
        get(paste0("rast_period_d_", df_growth_stages_req_i2[i, 1], "_i2")),
        maxnl = 36,
        breaks = c(0, 0.25, 0.5, 0.75, 1),
        axes = F,
        plg = list(cex = 1, title = paste0(df_growth_stages_req_i2[i, 1], "_i2"))
      )

  }
}
}
``` 
</div>


```{r i2_sowing_dates_sos_title, echo=FALSE, results='asis', eval=sos_crit_i2}

cat("\n#### Spatially Dynamic Growing Seasons\n")

```

```{r i2_sowing_dates_sos_intro, echo=FALSE, results='asis',  eval=sos_crit_i2}

cat("For climatic criteria for specific growth stages which use monthly or dekadal data, and which have a spatially variable growth period the phenological stages need to be distributed over those periods and spatially.\n
\n
\n
The maps below give the distribution of each phenological stage over the months.\n
\n
I use the same function as Walvoort (here called growth_period_long_tbl and growth_period_long_dekad_tbl), and apply this on a cell-by-cell basis using the start and end days for each cell.\n
\n
When the function is applied to the tibble using 'apply' it produces a x *x* 12/36 matrix. I transpose this matrix, append it to the original tibble and create a temporary data frame. I save this as a csv, convert this to a spatvector object and create spatrasters for each month/dekad *x* growing period combination. I join the individual rasters in a SpatRaster brick for each growing period - to be used later.")

```


<div class="fold o">   
```{r i2_sowing_dates_sos_onsetdata_01, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=sos_crit_i2}

if (sos_crit_i2) {
# get onset for area of interest
rast_filename_onset_i2 <-
  as.character(paste("spatial_data/input/rast_onset_",
                     params$INN2,
                     ".tif",
                     sep = ""))
assign(paste0("rast_onset_i2"), rast(here(rast_filename_onset_i2)))
names(rast_onset_i2) <- c("onset")
# rast_onset
# 
# g <- base_raster_plot(rast_onset, "onset", 'red', 'blue', "Season onset day number (rast_onset)" )
# 
# gsubdivsimple <- add_subdiv_simple_plot(g)
# gsubdivsimple
}
```
</div>


<div class="fold o">   
```{r i2_sowing_dates_sos_onsetdata_02, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=sos_crit_i2}

if (sos_crit_i2) {
# project onset
rast_onset_proj_i2 <- project(rast_onset_i2, rast_mask_proj_i2, method = "near")
# rast_onset_proj
# 
# g <- base_raster_plot(rast_onset_proj, "onset", 'red', 'blue', "Season onset day number (rast_onset_proj)" )
# 
# gsubdivsimple <- add_subdiv_simple_plot(g)
# gsubdivsimple
}
```
</div>


<div class="fold o">   
```{r i2_sowing_dates_sos_onsetdata_03, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=sos_crit_i2}

if (sos_crit_i2) {
# do a rough crop to boundaries
rast_onset_crop_i2 <- crop(rast_onset_proj_i2, rast_mask_proj_i2, mask = T, touches = T, extend = T, snap = 'out')
# rast_onset_crop
# 
# g <- base_raster_plot(rast_onset_crop, "onset", 'red', 'blue', "Season onset day number (rast_onset_crop)" )
# 
# gsubdivsimple <- add_subdiv_simple_plot(g)
# gsubdivsimple
}

```
</div>


<div class="fold o">   
```{r i2_sowing_dates_sos_onsetdata_04, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=sos_crit_i2}
if (sos_crit_i2) {
rast_onset_crop_rsmp_i2 <- resample(rast_onset_crop_i2, rast_mask_proj_i2,  method="near")
rast_onset_crop_rsmp_i2


g_i2 <- base_raster_plot(rast_onset_crop_rsmp_i2, "onset", 'red', 'blue', "Season onset day number (rast_onset_crop_rsmp_i2)" )

gsubdivsimple_i2 <- add_subdiv_simple_plot(g_i2, vect_subdiv_i2)
gsubdivsimple_i2
}
```
</div>

<div class="fold o">   
```{r i2_sowing_dates_sos_onsetdata_05, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=sos_crit_i2}

if (sos_crit_i2) {
# convert to df
df_onset_i2 <- as.data.frame(rast_onset_crop_rsmp_i2, xy=TRUE, cells=TRUE, na.rm=NA)
df_onset_i2 <- mutate(df_onset_i2, onset = as.integer(onset))
}
```
</div>

<div class="fold o">   
```{r i2_sowing_dates_sos_transpose, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE,  eval=sos_crit_i2}

if (sos_crit_i2) {
df_growth_stages_lengths_i2 <- df_growth_stages_i2[-1, ]
#df_growth_stages_lengths

df_growth_stages_lengths1_i2 <- t(select(df_growth_stages_lengths_i2, name, length)) %>% data.frame()
#df_growth_stages_lengths1

df_growth_stages_lengths2_i2 <- setNames(df_growth_stages_lengths1_i2, df_growth_stages_lengths_i2[,1])
#df_growth_stages_lengths2

df_growth_stages_lengths3_i2 <- df_growth_stages_lengths2_i2[-1, ] 
#df_growth_stages_lengths3

df_growth_stages_lengths3_i2[] <- lapply(df_growth_stages_lengths3_i2, as.integer)
df_growth_stages_lengths3_i2 %>%
  kable(caption = "Growth Stage Days") %>% kable_styling("striped", full_width = T)  #%>% print
}
```
</div>

<div class="fold o">   
```{r i2_sowing_dates_sos_onsetdata_06, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE,  eval=sos_crit_i2}

if (sos_crit_i2) {
# add the growth stage lengths to the df
for (i in seq_len(nrow(df_growth_stages_lengths_i2))) {
  period_name_i2 <- as.character(df_growth_stages_lengths_i2[i, 1])
#  cat(paste(period_name))
#  cat(eval(parse(text = paste0("df_growth_stages_lengths3$", period_name))))
  df_onset_i2 <-  mutate(df_onset_i2, !!as.character(paste0(period_name_i2,"_l")) :=  eval(parse(text = paste0("df_growth_stages_lengths3_i2$", period_name_i2))), .keep = c("all"))
} 


# add the start day for the first growth stage (which is the onset)

first_period_name_i2 <- as.character(df_growth_stages_lengths_i2[1, 1])
#cat(paste(first_period_name))
df_onset_i2 <-
  mutate(df_onset_i2,!!as.character(paste0(first_period_name_i2, "_s")) :=  eval(parse(text = paste0(
    "df_onset_i2$onset"
  ))),
  .keep = c("all"))

# add the start days for each of the growth stages (excluding the first which is the onset)

for (i in seq_len(nrow(df_growth_stages_lengths_i2)- 2) ) {
  
#  cat(paste(i))
      
  previous_period_name_i2 <- as.character(df_growth_stages_lengths_i2[i, 1])
#  cat(paste("Prev = ", previous_period_name))
#  cat("\n")
  period_name_i2 <- as.character(df_growth_stages_lengths_i2[i + 1, 1])
#  cat(paste("Current = ", period_name))
#  cat("\n")
#  cat(paste0("df_growth_stages_lengths3$", period_name))
#  cat(paste(parse(text =paste0("df_onset$", previous_period_name,"_s"))))
#  cat("\n")
#  cat(paste(parse(text =paste0("df_onset$", previous_period_name,"_l"))))
#  cat("\n\n")
 
eval_expr_1 <- eval(parse(text =paste0("df_onset_i2$", previous_period_name_i2, "_s + df_onset_i2$", previous_period_name_i2,"_l")))

  df_onset_i2 <-
    mutate(df_onset_i2, !!as.character(paste0(period_name_i2, "_s")) :=  eval_expr_1,
           .keep = c("all"))

}

# add the end days for each of the growth stages

for (i in seq_len(nrow(df_growth_stages_lengths_i2) - 1) ) {
  
#  cat(paste(i))
      
#  previous_period_name <- as.character(df_growth_stages_lengths[i, 1])
#  cat(paste("Prev = ", previous_period_name))
#  cat("\n")
  period_name_i2 <- as.character(df_growth_stages_lengths_i2[i, 1])
#  cat(paste("Current = ", period_name))
#  cat("\n")
#  cat(paste0("df_growth_stages_lengths3$", period_name))
#  cat(paste(parse(text =paste0("df_onset$", period_name,"_s"))))
#  cat("\n")
#  cat(paste(parse(text =paste0("df_onset$", period_name,"_l"))))
#  cat("\n\n")
 
eval_expr_2 <- eval(parse(text =paste0("df_onset_i2$", period_name_i2, "_s + df_onset_i2$", period_name_i2,"_l - 1")))

  df_onset_i2 <-
    mutate(df_onset_i2, !!as.character(paste0(period_name_i2, "_e")) :=  eval_expr_2,
           .keep = c("all"))

}  
  
onset_max_i2 <- max(select(df_onset_i2, -cell, -x, -y)) # gets the maximum value of the julian day numbers
num_years_i2 <- max(ceiling(onset_max_i2 / 365))

cat(paste("Growth Stages span", num_years_i2, "calendar years"))
}
```
</div>

<div class="fold o">
```{r i2_sowing_dates_sos_maps_m, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=sos_crit_i2}

# to reduce unnecessary processing follow these steps
# for each growth stage:

# (1) does the monthly and/or dekad raster mask exist on file?
#   YES - (i) load raster file to env
#         (ii) plot raster file
#         (iii) move to next growth stage or next chunk
#   NO -  (i) go to (2)

# (2) does the monthly and/or dekad raster mask csv exist on file?
#   YES - (i) load csv file to env as vect
#         (ii) rasterize vect
#         (iii) write raster to file
#         (iv) go to (1)
#   NO -  (i) go to (3)

# (3) does the monthly and/or dekad raster mask df exist in the env?
#   YES - (i) write df to file as csv
#         (ii) go to (2)
#   NO -  (i) go to (4)

# (4) does the monthly and/or dekad raster mask matrix exist in the env?
#   YES - (i) join the matrix to the onset df
#         (ii) write df to file as csv
#         (iii) go to (3)
#   NO -  (i) create the matrix using the growth_period_long functions
#         (ii) join the matrix to the onset df
#         (iii) go to (4)

if (sos_crit_i2) {
if (exists('rast_clim_mask_m_i2')) {
  cat(paste("\n1 Monthly data exist"))
    
  # set static vectors of days and months
  days <- 1:365
  day_months <- days %>% as.character %>% as.Date("%j") %>% 
    format("%m") %>% as.integer
  months <- rep.int(day_months, num_years_i2)
  
  
  for (i in seq_len(nrow(df_growth_stages_lengths_i2))) {
    period_name_i2 <- as.character(df_growth_stages_lengths_i2[i, 1])
    cat(paste("\nCurrent growth stage = ", period_name_i2))
    
    rast_filename_m_i2 <-
      as.character(paste0(
        "spatial_data/output/rast_",
        period_name_i2,
        "_m_",
        params$INN2, "_", params$MASK,
        ".tif"
      ))
    
    if (!file.exists(here(rast_filename_m_i2))) {
      cat(paste("\n2 No spatraster"))
      
      if (!exists(paste0("vect_", period_name_i2, "_m_i2"))) {
        cat(paste("\n3 No spatvector"))
        
        csv_filename_m_i2 <-
          as.character(
            paste(
              "tab_data/output/df_onset_",
              period_name_i2,
              "_m_",
              params$INN2, "_", params$MASK,
              ".csv",
              sep = ""
            )
          )
        
        if (!file.exists(here(csv_filename_m_i2))) {
          cat(paste("\n4 No csv data"))
          
          if (!exists(paste0("df_onset_", period_name_i2, "_m_i2"))) {
            cat(paste("\n5 No df"))
            
            if (!exists(paste0(period_name_i2, "_matrix_days_m_i2"))) {
              cat(paste("\n6 No matrix"))
              
              if (period_name_i2 == "total") {
                expr_3_m <- parse(
                  text = paste0(
                    "t(apply(df_onset_i2, 1, .growth_period_long_tbl_short, day_begin = \"onset\", day_end = \"",
                    df_growth_stages_lengths_i2[nrow(df_growth_stages_lengths_i2) - 1, 1],
                    "_e\", num_years = num_years_i2))"
                  )
                )
              } else {
                expr_3_m <- parse(
                  text = paste0(
                    "t(apply(df_onset_i2, 1, .growth_period_long_tbl_short, day_begin = \"",
                    period_name_i2,
                    "_s\",
        day_end = \"",
        period_name_i2,
        "_e\", num_years = num_years_i2))"
                  )
                )
              }
              
              assign(paste0(period_name_i2, "_matrix_days_m_i2"),
                     eval(expr_3_m))
                            
                            expr_3_m2 <- parse(
                  text = paste0(period_name_i2, "_matrix_days_m_i2 * 1000"))
              
              assign(paste0(period_name_i2, "_matrix_days_m_i2"), eval(expr_3_m2))
              
              eval(parse(text = paste0(
                "mode(", period_name_i2, "_matrix_days_m_i2) <- \"integer\""
              )))
              
              cat(paste("\n-6"))
            }
            
            
            assign(paste0("df_onset_", period_name_i2, "_m_i2"),
                   data.frame(df_onset_i2, get(
                     paste0(period_name_i2, "_matrix_days_m_i2")
                   )))
            
            cat(paste("\n-5"))
          }
          
          rm(list = paste0(period_name_i2, "_matrix_days_m_i2")) # remove matrix when df created
          
          write.csv(get(paste0("df_onset_", period_name_i2, "_m_i2")),
                    here(csv_filename_m_i2))
          
          cat(paste("\n-4"))
        }
        rm(list = paste0("df_onset_", period_name_i2, "_m_i2")) # remove df when csv created
        # assign(paste0("vect_", period_name, "_m"),
        # vect(
        #   read_csv(here(csv_filename_m), show_col_types = FALSE, .name_repair = "unique_quiet"),
        #   geom = c("x", "y"),
        #   crs = wkt_lam
        # )) # gives an error due to unused argument (.name_repair = "unique_quiet")
        assign(paste0("vect_", period_name_i2, "_m_i2"),
               vect(
                 read_csv(here(csv_filename_m_i2), show_col_types = FALSE),
                 geom = c("x", "y"),
                 crs = wkt_lam
               )) 
        cat(paste("\n-3"))
      }
      
      
      assign(paste0("list_rast_", period_name_i2, "_m_i2"),
             list())
      
      #create an empty raster
      assign(paste0("rast_", period_name_i2, "_m_i2"), rast())
      
      for (j in 1:12) {
        assign(
          paste0("rast_", period_name_i2, "_m_i2_", j),
          rasterize(get(
            paste0("vect_", period_name_i2, "_m_i2")
          ), rast_clim_mask_m_i2, field = paste0("X", j))
        )
        
        assign(paste0("list_rast_", period_name_i2, "_m_i2"),
               append(get(
                 paste0("list_rast_", period_name_i2, "_m_i2")
               ), paste0("rast_", period_name_i2, "_m_i2_", j)))
        expr_5_m <-
          parse(text = paste0(
            "add(rast_",
            period_name_i2,
            "_m_i2) <- (rast_",
            period_name_i2,
            "_m_i2_",
            j,
            ")"
          ))
        
        eval(expr_5_m)
        rm(list = paste0("rast_", period_name_i2, "_m_i2_", j)) # remove month rast when added to brick
      }
      
      rm(list = paste0("vect_", period_name_i2, "_m_i2")) # remove vect when raster created
      writeRaster(get(paste0("rast_", period_name_i2, "_m_i2")), here(rast_filename_m_i2), overwrite = TRUE)
      cat(paste("\n-2"))
    }
    
    assign(paste0("rast_", period_name_i2, "_m_i2"), rast(here(rast_filename_m_i2)))
    cat(paste0("\n", rast_filename_m_i2))
    
    expr_6_m <-
      parse(
        text = paste0(
          "names(rast_",
          period_name_i2,
          "_m_i2) <- c(\"January\", \"February\", \"March\", \"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\")"
        )
      )
    
    eval(expr_6_m)
    
#    plot(
#      get(paste0("rast_", period_name, "_m")),
#      maxnl = 12,
#      breaks = c(0, 0.25, 0.5, 0.75, 1),
#      axes = F,
#      plg = list(cex = 1, title = paste0(period_name))
#    )
    
  }
  cat(paste("\n-1"))
}
}
```
</div>

<div class="fold o">
```{r i2_sowing_dates_sos_maps_d, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=sos_crit_i2}

# to reduce unnecessary processing follow these steps
# for each growth stage:

# (1) does the monthly and/or dekad raster mask exist on file?
#   YES - (i) load raster file to env
#         (ii) plot raster file
#         (iii) move to next growth stage or next chunk
#   NO -  (i) go to (2)

# (2) does the monthly and/or dekad raster mask csv exist on file?
#   YES - (i) load csv file to env as vect
#         (ii) rasterize vect
#         (iii) write raster to file
#         (iv) go to (1)
#   NO -  (i) go to (3)

# (3) does the monthly and/or dekad raster mask df exist in the env?
#   YES - (i) write df to file as csv
#         (ii) go to (2)
#   NO -  (i) go to (4)

# (4) does the monthly and/or dekad raster mask matrix exist in the env?
#   YES - (i) join the matrix to the onset df
#         (ii) write df to file as csv
#         (iii) go to (3)
#   NO -  (i) create the matrix using the growth_period_long functions
#         (ii) join the matrix to the onset df
#         (iii) go to (4)

if (sos_crit_i2) {
if (exists('rast_clim_mask_d_i2')) {
  cat(paste("\n1 Dekad data exist"))
  
  # set static vectors of days and dekads
  days <- 1:365
  day_dekads <- days %>% as.character %>% as.Date("%j") %>%
    dekad(type = "year") %>% as.integer
  dekads <- rep.int(day_dekads, num_years_i2)
  
  
  for (i in seq_len(nrow(df_growth_stages_lengths_i2))) {
    period_name_i2 <- as.character(df_growth_stages_lengths_i2[i, 1])
    cat(paste("\nCurrent growth stage = ", period_name_i2))
    
    
    rast_filename_d_i2 <-
      as.character(paste0(
        "spatial_data/output/rast_",
        period_name_i2,
        "_d_",
        params$INN2, "_", params$MASK, 
        ".tif"
      ))
    
    if (!file.exists(here(rast_filename_d_i2))) {
      cat(paste("\n2 No spatraster"))
      
      if (!exists(paste0("vect_", period_name_i2, "_d"))) {
        cat(paste("\n3 No spatvector"))
        
        csv_filename_d_i2 <-
          as.character(
            paste(
              "tab_data/output/df_onset_",
              period_name_i2,
              "_d_",
              params$INN2, "_", params$MASK,
              ".csv",
              sep = ""
            )
          )
        
        if (!file.exists(here(csv_filename_d_i2))) {
          cat(paste("\n4 No csv data"))
          
          if (!exists(paste0("df_onset_", period_name_i2, "_d"))) {
            cat(paste("\n5 No df"))
            
            if (!exists(paste0(period_name_i2, "_matrix_days_d"))) {
              cat(paste("\n6 No matrix"))
              
              if (period_name_i2 == "total") {
                expr_3_d <- parse(
                  text = paste0(
                    "t(apply(df_onset_i2, 1, .growth_period_long_dekad_tbl_short, day_begin = \"onset\", day_end = \"",
                    df_growth_stages_lengths_i2[nrow(df_growth_stages_lengths_i2) - 1, 1],
                    "_e\", num_years = num_years_i2))"
                  )
                )
              } else {
                expr_3_d <- parse(
                  text = paste0(
                    "t(apply(df_onset_i2, 1, .growth_period_long_dekad_tbl_short, day_begin = \"",
                    period_name_i2,
                    "_s\",
        day_end = \"",
        period_name_i2,
        "_e\", num_years = num_years_i2))"
                  )
                )
              }
              
              assign(paste0(period_name_i2, "_matrix_days_d_i2"),
                     eval(expr_3_d))
              expr_3_d2 <- parse(
                  text = paste0(period_name_i2, "_matrix_days_d_i2 * 1000"))
              
              assign(paste0(period_name_i2, "_matrix_days_d_i2"), eval(expr_3_d2))
              
              eval(parse(text = paste0(
                "mode(", period_name_i2, "_matrix_days_d_i2) <- \"integer\""
              )))
              
              cat(paste("\n-6"))
            }
            
            assign(paste0("df_onset_", period_name_i2, "_d_i2"),
                   data.frame(df_onset_i2, get(
                     paste0(period_name_i2, "_matrix_days_d_i2")
                   )))
            
            cat(paste("\n-5"))
          }
          rm(list = paste0(period_name_i2, "_matrix_days_d_i2")) # remove matrix when df created
          write.csv(get(paste0("df_onset_", period_name_i2, "_d_i2")),
                    here(csv_filename_d_i2))
          
          cat(paste("\n-4"))
        }
        rm(list = paste0("df_onset_", period_name_i2, "_d_i2")) # remove df when csv created
        # assign(paste0("vect_", period_name, "_d"),
        #        vect(
        #          read_csv(
        #            here(csv_filename_d),
        #            show_col_types = FALSE,
        #            .name_repair = "unique_quiet"
        #          ),
        #          geom = c("x", "y"),
        #          crs = wkt_lam
        #        ))# gives an error due to unused argument (.name_repair = "unique_quiet")
        assign(paste0("vect_", period_name_i2, "_d_i2"),
               vect(
                 read_csv(
                   here(csv_filename_d_i2),
                   show_col_types = FALSE
                 ),
                 geom = c("x", "y"),
                 crs = wkt_lam
               ))
        cat(paste("\n-3"))
      }
      assign(paste0("list_rast_", period_name_i2, "_d_i2"),
             list())
      
      #create an empty raster
      assign(paste0("rast_", period_name_i2, "_d_i2"), rast())
      
      for (j in 1:36) {
        assign(
          paste0("rast_", period_name_i2, "_d_i2_", j),
          rasterize(get(
            paste0("vect_", period_name_i2, "_d_i2")
          ), rast_clim_mask_d_i2, field = paste0("X", j))
        )
        
        assign(paste0("list_rast_", period_name_i2, "_d_i2"),
               append(get(
                 paste0("list_rast_", period_name_i2, "_d_i2")
               ), paste0("rast_", period_name_i2, "_d_i2_", j)))
        expr_5_d <-
          parse(text = paste0(
            "add(rast_",
            period_name_i2,
            "_d_i2) <- (rast_",
            period_name_i2,
            "_d_i2_",
            j,
            ")"
          ))
        
        eval(expr_5_d)
        rm(list = paste0("rast_", period_name_i2, "_d_i2_", j)) # remove dekad rast when added to brick
        
      }
      
      rm(list = paste0("vect_", period_name_i2, "_d_i2")) # remove vect when raster created
      writeRaster(get(paste0("rast_", period_name_i2, "_d_i2")), here(rast_filename_d_i2), overwrite = TRUE)
      cat(paste("\n-2"))
    }
    
    assign(paste0("rast_", period_name_i2, "_d_i2"), rast(here(rast_filename_d_i2)))
    cat(paste0("\n", rast_filename_d_i2))
    
    expr_6_d <-
      parse(
        text = paste0(
          "names(rast_",
          period_name_i2,
          "_d_i2) <- c(\"Ja1\", \"Ja2\", \"Ja3\", \"Fe1\", \"Fe2\", \"Fe3\",\"Mr1\", \"Mr2\", \"Mr3\",\"Ap1\", \"Ap2\", \"Ap3\",\"My1\", \"My2\", \"My3\",\"Jn1\", \"Jn2\", \"Jn3\",\"Jl1\",\"Jl2\", \"Jl3\",\"Ag1\",\"Ag2\", \"Ag3\",\"Sp1\",\"Sp2\", \"Sp3\",\"Oc1\",\"Oc2\", \"Oc3\",\"No1\",\"No2\", \"No3\",\"De1\",\"De2\", \"De3\")"
        )
      )
    
    eval(expr_6_d)
    
#    plot(
#      get(paste0("rast_", period_name, "_d")),
#      maxnl = 36,
#      breaks = c(0, 0.25, 0.5, 0.75, 1),
#      axes = F,
#      plg = list(cex = 1, title = paste0(period_name))
#    )
    
  }
  cat(paste("\n-1"))
}
}
```
</div>

<div class="fold o">   
```{r i2_sowing_dates_sos_distribute_m, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=sos_crit_i2}

##-- monthly distribution --
if (sos_crit_i2) {
if (exists('rast_clim_mask_m_i2')) {
  for (i in seq_len(nrow(df_growth_stages_req_i2))) {
    period_name_i2 <- as.character(df_growth_stages_req_i2[i, 1])
    cat("period_name = ", period_name_i2, "\n")
    
    
    # load growth period rasters
    rast_filename_m_i2 <-
      as.character(paste0(
        "spatial_data/output/rast_",
        period_name_i2,
        "_m_",
        params$INN2, "_", params$MASK,
        ".tif"
      ))
    
    assign(paste0("rast_period_m_", period_name_i2, "_original_i2"),
           rast(here(rast_filename_m_i2))/1000) # divide by 1000 because the values were multiplied by 1000 when creating the matrix
    
    # reproject growth period rasters
    
    assign(
      paste0("rast_period_m_", period_name_i2, "_prj_i2"),
      terra::project(get(
        paste0("rast_period_m_", period_name_i2, "_original_i2")
      ),   rast_mask_proj_i2, "near")
    )
    
    # aggregate if necessary
    
    #calc_agg_factor_m <-
    #    (res(rast_mask_proj) / res(rast_period_m_total_prj))
    #  cat(paste("calculated aggregate factor m = ", calc_agg_factor_m))
    
    calc_agg_factor_m_i2 <-
      (res(rast_mask_proj_i2) / res(get(
        paste0("rast_period_m_", period_name_i2, "_prj_i2")
      )))
    
    cat(paste("calculated aggregate factor m = ", calc_agg_factor_m_i2))
    
    
    if (calc_agg_factor_m_i2[1] < 1) {
      calc_agg_factor_m_i2[1] <- 1
      
      # this means that the mask has a higher resolution than the precipitation raster so aggregation is not necessary and the precipitation raster will stay the same resolution
      
      cat(paste(
        "revised calculated aggregate factor m1 = ",
        calc_agg_factor_m_i2[1]
      ))
    }
    cat("\n")
    
    if (calc_agg_factor_m_i2[2] < 1) {
      calc_agg_factor_m_i2[2] <- 1
      cat(paste(
        "revised calculated aggregate factor m2 = ",
        calc_agg_factor_m_i2[2]
      ))
    }
    
    # resample
    
    cat(paste("aggregate and resample"))
    
    #    rast_period_m_total <-
    #    agg_resample(
    #      rast_period_m_total_prj,
    #      calc_agg_factor_m, "modal", "near")
    
    assign(
      paste0("rast_period_m_", period_name_i2, "_i2"),
      agg_resample(get(
        paste0("rast_period_m_", period_name_i2, "_prj_i2")
      ),
      calc_agg_factor_m_i2, "modal", "near", rast_mask_proj_i2)
    )
    
    # plot
    
    expr_7_m <-
      parse(
        text = paste0(
          "names(rast_period_m_",
          period_name_i2,
          "_i2) <- c(\"January\", \"February\", \"March\", \"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\")"
        )
      )
    
    eval(expr_7_m)
    plot(
      get(paste0("rast_period_m_", period_name_i2, "_i2")),
      maxnl = 12,
      breaks = c(0, 0.25, 0.5, 0.75, 1),
      axes = F,
      plg = list(cex = 1, title = paste0(period_name_i2))
    )
    
  }
}
}
```  
</div>    
 
<div class="fold o">   
```{r i2_sowing_dates_sos_distribute_d, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=sos_crit_i2}

# dekadal growth stages have been pre-modelled for the spatial onset of season

# for each of the growth stages for which there are requirements create a new raster brick

##-- dekadal distribution --

if (sos_crit_i2) {
if (exists('rast_clim_mask_d_i2')) {
  for (i in seq_len(nrow(df_growth_stages_req_i2))) {
    period_name_i2 <- as.character(df_growth_stages_req_i2[i, 1])
    cat("period_name = ", period_name_i2, "\n")
    
    
    # load growth period rasters
    rast_filename_d_i2 <-
      as.character(paste0(
        "spatial_data/output/rast_",
        period_name_i2,
        "_d_",
        params$INN2, "_", params$MASK,
        ".tif"
      ))
    
    assign(paste0("rast_period_d_", period_name_i2, "_original_i2"),
           rast(here(rast_filename_d_i2))/1000) # divide by 1000 because the values were multiplied by 1000 when creating the matrix
    
    # reproject growth period rasters
    
    assign(
      paste0("rast_period_d_", period_name_i2, "_prj_i2"),
      terra::project(get(
        paste0("rast_period_d_", period_name_i2, "_original_i2")
      ),   rast_mask_proj_i2, "near")
    )
    
    # aggregate if necessary
    
    #calc_agg_factor_d <-
    #    (res(rast_mask_proj) / res(rast_period_d_total_prj))
    #  cat(paste("calculated aggregate factor m = ", calc_agg_factor_d))
    
    calc_agg_factor_d_i2 <-
      (res(rast_mask_proj_i2) / res(get(
        paste0("rast_period_d_", period_name_i2, "_prj_i2")
      )))
    
    cat(paste("calculated aggregate factor d = ", calc_agg_factor_d_i2))
    
    
    if (calc_agg_factor_d_i2[1] < 1) {
      calc_agg_factor_d_i2[1] <- 1
      
      # this means that the mask has a higher resolution than the precipitation raster so aggregation is not necessary and the precipitation raster will stay the same resolution
      
      cat(paste(
        "revised calculated aggregate factor d1 = ",
        calc_agg_factor_d_i2[1]
      ))
    }
    cat("\n")
    
    if (calc_agg_factor_d_i2[2] < 1) {
      calc_agg_factor_d_i2[2] <- 1
      cat(paste(
        "revised calculated aggregate factor d2 = ",
        calc_agg_factor_d_i2[2]
      ))
    }
    
    # resample
    
    cat(paste("aggregate and resample"))
    
    #    rast_period_d_total <-
    #    agg_resample(
    #      rast_period_d_total_prj,
    #      calc_agg_factor_d, "modal", "near")
    
    assign(
      paste0("rast_period_d_", period_name_i2, "_i2"),
      agg_resample(get(
        paste0("rast_period_d_", period_name_i2, "_prj_i2")
      ),
      calc_agg_factor_d_i2, "modal", "near", rast_mask_proj_i2)
    )
    
    # plot
    
    expr_7_d <-
      parse(
        text = paste0(
          "names(rast_period_d_",
          period_name_i2,
          "_i2) <- c(\"Ja1\", \"Ja2\", \"Ja3\", \"Fe1\", \"Fe2\", \"Fe3\",\"Mr1\", \"Mr2\", \"Mr3\",\"Ap1\", \"Ap2\", \"Ap3\",\"My1\", \"My2\", \"My3\",\"Jn1\", \"Jn2\", \"Jn3\",\"Jl1\",\"Jl2\", \"Jl3\",\"Ag1\",\"Ag2\", \"Ag3\",\"Sp1\",\"Sp2\", \"Sp3\",\"Oc1\",\"Oc2\", \"Oc3\",\"No1\",\"No2\", \"No3\",\"De1\",\"De2\", \"De3\")"
        )
      )
    
    eval(expr_7_d)
    plot(
      get(paste0("rast_period_d_", period_name_i2, "_i2")),
      maxnl = 36,
      breaks = c(0, 0.25, 0.5, 0.75, 1),
      axes = F,
      plg = list(cex = 1, title = paste0(period_name_i2))
    )
    
  }
}
}
```     
</div> 

### Processing precipitation data

<div class="fold o">   
```{r i2_requirements_prec02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE}

df_priorities_clim_prec_m_i2 <-
  dplyr::filter(df_priorities_clim_i2, prec_temp == "p" &
                  temp_resolution == "m") # filter precipitation criteria

for (i in seq_len(nrow(df_growth_stages_req_prec_i2))) {
  period_name_i2 <- as.character(df_growth_stages_req_prec_i2[i, 1])
  print(paste("Criterion = ", df_priorities_clim_prec_m_i2[i, 4]))
  #      print(period_name)
  
  for (j in seq_len(nrow(df_priorities_clim_prec_m_i2))) {
    if (sum(df_priorities_clim_prec_m_i2[j, 'phen_stage'] == period_name_i2, na.rm = TRUE) == 1) {
      print(paste0("period_name = ", as.character(period_name_i2)))
      # crit_rownum <-
      #   which(df_priorities_clim_prec_m$phen_stage == period_name)
      assign(
        paste0(
          "rast_",
          df_priorities_clim_prec_m_i2[j, 12],
          "_rsmp_",
          df_growth_stages_req_prec_i2[i, 1], "_i2"
        ),
        sum(get(
          paste0("rast_", df_priorities_clim_prec_m_i2[j, 12], "_rsmp_i2")
        ) * get(
          paste0("rast_period_m_", df_growth_stages_req_prec_i2[i, 1], "_i2") #changed 14/05/2024
        ))
      )
      print(
        paste0(
          "rast_",
          df_priorities_clim_prec_m_i2[j, 12],
          "_rsmp_",
          df_growth_stages_req_prec_i2[i, 1], "_i2"
        )
      )
      #        plot_raster <-
      plot(get(
        paste0(
          "rast_",
          df_priorities_clim_prec_m_i2[j, 12],
          "_rsmp_",
          df_growth_stages_req_prec_i2[i, 1], "_i2"
        )
      ),
      main = paste0(
        "rast_period_m_",
        as.character(df_growth_stages_req_prec_i2[i, 1]), "_i2"
      ))
      #        print(plot_raster)
      
      
      new_col_i2 <-
        get(
          paste0(
            "rast_",
            df_priorities_clim_prec_m_i2[j, 12],
            "_rsmp_",
            df_growth_stages_req_prec_i2[i , 1], "_i2"
          )
        ) %>% terra::extract(xy_i2) # extract the raster values using xy points
      
      new_col_i2 <- new_col_i2[[1]]
      
      df_irm_i2 <-
        dplyr::select(df_irm_i2,-any_of(c(as.character(
          paste0(df_priorities_clim_prec_m_i2[j, 3])
        )))) # remove column if name already exists
      
      df_irm_i2 <-
        mutate(df_irm_i2,!!as.character(paste0(df_priorities_clim_prec_m_i2[j, 3])) := new_col_i2,
               .keep = c("all"))   # add the raster values to the df_irm_i2 tibble, this needs to be dynamic so uses the !! and := operators
      
      
    } else {
      #    print(sum(df_priorities_clim_prec_m[, 'phen_stage'] == period_name, na.rm = TRUE))
    }
  }
}

df_priorities_clim_prec_d_i2 <-
  dplyr::filter(df_priorities_clim_i2, prec_temp == "p" &
                  temp_resolution == "d") # filter precipitation criteria

for (i in seq_len(nrow(df_growth_stages_req_prec_i2))) {
  period_name_i2 <- as.character(df_growth_stages_req_prec_i2[i, 1])
  print(paste("Criterion = ", df_priorities_clim_prec_d_i2[i, 4]))
  # print(paste("i =", i))
  # print(period_name)
  for (j in seq_len(nrow(df_priorities_clim_prec_d_i2))) {
      # print(paste("j =", j))
        if (sum(df_priorities_clim_prec_d_i2[j, 'phen_stage'] == period_name_i2, na.rm = TRUE) == 1) {
      print(paste0("period_name = ", as.character(period_name_i2)))
      
      # crit_rownum <-
      #   which(df_priorities_clim_prec_d$phen_stage == period_name)
      assign(
        paste0(
          "rast_",
          df_priorities_clim_prec_d_i2[j, 12],
          "_rsmp_",
          df_growth_stages_req_prec_i2[i, 1], "_i2"
        ),
        sum(get(
          paste0("rast_", df_priorities_clim_prec_d_i2[j, 12], "_rsmp_i2")
        ) * get(
          paste0("rast_period_d_", df_growth_stages_req_prec_i2[i, 1], "_i2")
        ))
      )
      print(
        paste0(
          "rast_",
          df_priorities_clim_prec_d_i2[j, 12],
          "_rsmp_",
          df_growth_stages_req_prec_i2[i, 1], "_i2"
        )
      )
      #        plot_raster <-
      plot(get(
        paste0(
          "rast_",
          df_priorities_clim_prec_d_i2[j, 12],
          "_rsmp_",
          df_growth_stages_req_prec_i2[i, 1], "_i2"
        )
      ),
      main = paste0(
        "rast_period_d_",
        as.character(df_growth_stages_req_prec_i2[i, 1]), "_i2" #changed 14/05/2024
      ))
      #        print(plot_raster)
      
      
      new_col_i2 <-
        get(
          paste0(
            "rast_",
            df_priorities_clim_prec_d_i2[j, 12],
            "_rsmp_",
            df_growth_stages_req_prec_i2[i , 1], "_i2"
          )
        ) %>% terra::extract(xy_i2) # extract the raster values using xy points
      
      new_col_i2 <- new_col_i2[[1]]
      
      df_irm_i2 <-
        dplyr::select(df_irm_i2, -any_of(c(as.character(
          paste0(df_priorities_clim_prec_d_i2[j, 3])
        )))) # remove column if name already exists
      
      df_irm_i2 <-
        mutate(df_irm_i2,
               !!as.character(paste0(df_priorities_clim_prec_d_i2[j, 3])) := new_col_i2,
               .keep = c("all"))   # add the raster values to the df_irm_i2 tibble, this needs to be dynamic so uses the !! and := operators
      
      
    } else {
      #   print(sum(df_priorities_clim_prec_d[, 'phen_stage'] == period_name, na.rm = TRUE))
    }
  }
}

df_priorities_clim_prec_i2 <-
  rbind(df_priorities_clim_prec_m_i2, df_priorities_clim_prec_d_i2)

```  
</div>

### Processing temperature data

<div class="fold o">   
```{r i2_requirements_temp02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE}

# A Farrow 01/06/2023 the following assumes that there is only one temperature criterion per growth stage
# In fact there may be multiple so a different way of looping through the criteria is needed


# for monthly temperature data

# logic
# for each temperature criterion i
# for each phen stage for which there is a criterion j
# do the appropriate calculation


df_priorities_clim_temp_m_i2 <-
  dplyr::filter(df_priorities_clim_i2, prec_temp == "t" &
                  temp_resolution == "m") # filter temperature criteria

if (nrow(df_priorities_clim_temp_m_i2) > 0) {
  #1
  for (i in seq_len(nrow(df_priorities_clim_temp_m_i2))) {
    #2
    #print(paste("i = ", i))
    print(paste("Criterion = ", df_priorities_clim_temp_m_i2[i, 4]))
    for (j in seq_len(nrow(df_growth_stages_req_temp_i2))) {
      #3
      #print(paste("j = ", j))
      period_name_i2 <- as.character(df_growth_stages_req_temp_i2[j, 1])
      print(paste0("m period_name = ", as.character(period_name_i2)))
      if (sum(df_priorities_clim_temp_m_i2[i, 'phen_stage'] == period_name_i2, na.rm = TRUE) == 1) {
        #4
        if (df_priorities_clim_temp_m_i2[i, 14] == "mean") {
          #5
          print("mean")
          assign(
            paste0(
              "rast_",
              df_priorities_clim_temp_m_i2[i, 12],
              "_rsmp_",
              df_growth_stages_req_temp_i2[j, 1], "_i2"
            ),
            (sum(get(
              paste0("rast_", df_priorities_clim_temp_m_i2[i, 12], "_rsmp_i2")
            ) * get(
              paste0("rast_period_m_", df_growth_stages_req_temp_i2[j, 1], "_i2")
            )) / sum(get(
              paste0("rast_period_m_", df_growth_stages_req_temp_i2[j, 1], "_i2")
            )))
          )
        } else {
          #-5 5a
          if (df_priorities_clim_temp_m_i2[i, 14] == "min") {
            #6
            print("min")
            assign(
              paste0(
                "rast_",
                df_priorities_clim_temp_m_i2[i, 12],
                "_rsmp_",
                df_growth_stages_req_temp_i2[j, 1], "_i2"
              ),
              (min(get(
                paste0("rast_", df_priorities_clim_temp_m_i2[i, 12], "_rsmp_i2")
              ) / round(
                get(
                  paste0("rast_period_m_", df_growth_stages_req_temp_i2[j, 1], "_i2")
                )
              )))
            )
            
          } else {
            #-6 6a
            if (df_priorities_clim_temp_m_i2[i, 14] == "max") {
              #7
              print("max")
              assign(
                paste0(
                  "rast_",
                  df_priorities_clim_temp_m_i2[i, 12],
                  "_rsmp_",
                  df_growth_stages_req_temp_i2[j, 1], "_i2"
                ),
                (max(
                  get(
                    paste0("rast_", df_priorities_clim_temp_m_i2[i, 12], "_rsmp_i2")
                  ) * get(
                    paste0("rast_period_m_", df_growth_stages_req_temp_i2[j, 1], "_i2")
                  )
                ))
              )
              
            } else {
              #-7 7a
            } #-7a
          } #-6a
        } #-5a
        plot(get(
          paste0(
            "rast_",
            df_priorities_clim_temp_m_i2[i, 12],
            "_rsmp_",
            df_growth_stages_req_temp_i2[j, 1], "_i2"
          )
        ),
        main = paste0(
          "rast_period_m_",
          as.character(df_growth_stages_req_temp_i2[j, 1], "_i2")
        ))
        
        new_col_i2 <-
          get(
            paste0(
              "rast_",
              df_priorities_clim_temp_m_i2[i, 12],
              "_rsmp_",
              df_growth_stages_req_temp_i2[j , 1], "_i2"
            )
          ) %>% terra::extract(xy_i2) # extract the raster values using xy points
        
        new_col_i2 <- new_col_i2[[1]]
        
        df_irm_i2 <-
          dplyr::select(df_irm_i2,-any_of(c(as.character(
            paste0(df_priorities_clim_temp_m_i2[i, 3])
          )))) # remove column if name already exists
        
        df_irm_i2 <-
          mutate(df_irm_i2,
                 !!as.character(paste0(df_priorities_clim_temp_m_i2[i, 3])) := new_col_i2,
                 .keep = c("all"))   # add the raster values to the df_irm_i2 tibble, this needs to be dynamic so uses the !! and := operators
      } #-4
    }
  }
}




# for dekadal temperature data

df_priorities_clim_temp_d_i2 <-
  dplyr::filter(df_priorities_clim_i2, prec_temp == "t" &
                  temp_resolution == "d") # filter temperature criteria

if (nrow(df_priorities_clim_temp_d_i2) > 0) {
  #1
  for (i in seq_len(nrow(df_priorities_clim_temp_d_i2))) {
    #2
    #print(paste("i = ", i))
    print(paste("Criterion = ", df_priorities_clim_temp_d_i2[i, 4]))
    for (j in seq_len(nrow(df_growth_stages_req_temp_i2))) {
      #3
      print(paste("j = ", j))
      period_name_i2 <- as.character(df_growth_stages_req_temp_i2[j, 1])
      print(paste0("d period_name = ", as.character(period_name_i2)))
      if (sum(df_priorities_clim_temp_d_i2[i, 'phen_stage'] == period_name_i2, na.rm = TRUE) == 1) {
        #4
        if (df_priorities_clim_temp_d_i2[i, 14] == "mean") {
          #5
          print("mean")
          assign(
            paste0(
              "rast_",
              df_priorities_clim_temp_d_i2[i, 12],
              "_rsmp_",
              df_growth_stages_req_temp_i2[j, 1], "_i2"
            ),
            (sum(get(
              paste0("rast_", df_priorities_clim_temp_d_i2[i, 12], "_rsmp")
            ) * get(
              paste0("rast_period_d_", df_growth_stages_req_temp_i2[j, 1], "_i2")
            )) / sum(get(
              paste0("rast_period_d_", df_growth_stages_req_temp_i2[j, 1], "_i2")
            )))
          )
        } else {
          #-5 5a
          if (df_priorities_clim_temp_d_i2[i, 14] == "min") {
            #6
            print("min")
            assign(
              paste0(
                "rast_",
                df_priorities_clim_temp_d_i2[i, 12],
                "_rsmp_",
                df_growth_stages_req_temp_i2[j, 1], "_i2"
              ),
              (min(get(
                paste0("rast_", df_priorities_clim_temp_d_i2[i, 12], "_rsmp")
              ) / round(
                get(
                  paste0("rast_period_d_", df_growth_stages_req_temp_i2[j, 1], "_i2")
                )
              )))
            )
            
          } else {
            #-6 6a
            if (df_priorities_clim_temp_d_i2[i, 14] == "max") {
              #7
              print("max")
              assign(
                paste0(
                  "rast_",
                  df_priorities_clim_temp_d_i2[i, 12],
                  "_rsmp_",
                  df_growth_stages_req_temp_i2[j, 1], "_i2"
                ),
                (max(
                  get(
                    paste0("rast_", df_priorities_clim_temp_d_i2[i, 12], "_rsmp")
                  ) * get(
                    paste0("rast_period_d_", df_growth_stages_req_temp_i2[j, 1], "_i2")
                  )
                ))
              )
              
            } else {
              #-7 7a
            } #-7a
          } #-6a
        } #-5a
        plot(get(
          paste0(
            "rast_",
            df_priorities_clim_temp_d_i2[i, 12],
            "_rsmp_",
            df_growth_stages_req_temp_i2[j, 1], "_i2"
          )
        ),
        main = paste0(
          "rast_period_d_",
          as.character(df_growth_stages_req_temp_i2[j, 1], "_i2")
        ))
        
        new_col_i2 <-
          get(
            paste0(
              "rast_",
              df_priorities_clim_temp_d_i2[i, 12],
              "_rsmp_",
              df_growth_stages_req_temp_i2[j , 1], "_i2"
            )
          ) %>% terra::extract(xy_i2) # extract the raster values using xy points
        
        new_col_i2 <- new_col_i2[[1]]
        
        df_irm_i2 <-
          dplyr::select(df_irm_i2,-any_of(c(as.character(
            paste0(df_priorities_clim_temp_d_i2[i, 3])
          )))) # remove column if name already exists
        
        df_irm_i2 <-
          mutate(df_irm_i2,
                 !!as.character(paste0(df_priorities_clim_temp_d_i2[i, 3])) := new_col_i2,
                 .keep = c("all"))   # add the raster values to the df_irm_i2 tibble, this needs to be dynamic so uses the !! and := operators
      } #-4
    }
  }
}

df_priorities_clim_temp_i2 <-
  rbind(df_priorities_clim_temp_m_i2, df_priorities_clim_temp_d_i2)

```
</div> 


## Processing soil data

### Soil texture

If soil texture is a criterion then the USDA codes are reclassified quantitatively so that the fuzzy partitions can be applied.

Soil texture classes are reclassified in with 1, corresponding to S1 in Sys _et al._ (1993, p.159), 0.5 corresponding to S2, and 0 corresponding to S3, N1, N2 in Sys _et al._. 


```{r i2_reclass_soil_texture, results='asis'}

soil_texture_filename_i2 <-
  as.character(paste("tab_data/input/usda_texture_", params$INN2, ".csv", sep = ""))

if (file.exists(here(soil_texture_filename_i2))) {
  df_soil_texture_i2 <- read.csv(here(soil_texture_filename_i2))
  df_soil_texture_i2 %>%
    kable(digits = 3, caption = "Soil Texture ") %>% kable_styling("striped", full_width = T) %>% print
  
  df_priorities_texture_i2 <-
    dplyr::filter(df_raster_data_soil_i2, texture == 1) # filter temperature criteria
  # reclass using df_soil_texture table
  
  if (nrow(df_priorities_texture_i2) > 0) {
    
    #reclassify the texture raster (ensure that it is integer)
    rast_txt_clas_rsmp_i2 <- get(paste0("rast_", df_priorities_texture_i2[1, 12], "_rsmp_i2")) %>% as.int() %>% classify(as.matrix(
      dplyr::select(df_soil_texture_i2, USDA_Texture_Class, IRM_Value)
    ))
    
    #replace the texture raster in df_raster_data_soil
    text_rownum_i2 <- which(df_raster_data_soil_i2$texture == 1)
    
    df_raster_data_soil_i2[1, 12] <- "txt_clas"
    
    }
}

```



### Processing soil data horizons

If the criterion does not have a growth stage it is a soil property, and the values will need to be averaged, and weighted by the depth of each horizon, and possibly any other weights (e.g. Maghami Moghim, 2024). The simplest is to assume that each horizon has decreasing importance with depth, instead of applying a weight we assume that the depth of each horizon is the same - so we just calculate a simple average. Typical horizons in ISRIC data are:  

Depth             | Interval I | Interval II | Interval III | Interval IV | Interval V | Interval VI
------------------|------------|-------------|--------------|-------------|------------|-----------
Top depth (cm)    |	0          |	5          |	15          |	30          |	60         |	100
Bottom depth (cm  |	5          |	15         |	30          |	60          | 100        |	200


```{r i2_soil_horizon_weights_01, results='asis', warning=FALSE}

# averaging the values in the sifferent horizons
# there are two methods 1) use the thickness of each layer 2) assume that each layer contributes equally

for (i in seq_len(nrow(df_raster_data_soil_i2))) {
  cat(paste(df_raster_data_soil_i2[i, 3], "\n", df_raster_data_soil_i2[i, 4], "\n"))
  
  # method 1
  
  # # standard depths for interpolation
  # standard_depths <- c(0.025, 0.10, 0.225, 0.45, 0.80, 1.50)
  # 
  # # thicknesses of individual layers
  # bottom_layer <- c(0.05, 0.15, 0.30, 0.60, 1.0)
  # thickness <- diff(c(0, bottom_layer))
  # stopifnot(max(abs(
  #   bottom_layer - 0.5 *  thickness - standard_depths[1:5]
  # )) < 1.0e-6)
  # 
  # # horizon depth weighted
  # assign(
  #   paste0("rast_", df_raster_data_soil[i, 12], "_rsmp_1"),
  #   get(paste0("rast_", df_raster_data_soil[i, 12], "_rsmp")) %>% app(function(x) {
  #     sum((x * thickness) / sum(thickness))
  #   })
  # )
  # 
  # plot(get(paste0(
  #   "rast_", df_raster_data_soil[i, 12], "_rsmp_1"
  # )),
  # main = paste0("rast_", df_raster_data_soil[i, 12], "_rsmp_1"))
  # 
  # print("method 1")
  
  # method 2
  
  n_band_i2 <- dim(get(paste0("rast_", df_raster_data_soil_i2[i, 12], "_rsmp_i2")))[[3]]
  print(n_band_i2)
  
  # averaged equally across horizons
  assign(
    paste0("rast_", df_raster_data_soil_i2[i, 12], "_rsmp_i2"),
    get(paste0("rast_", df_raster_data_soil_i2[i, 12], "_rsmp_i2")) %>% app(function(x) {
      sum((x) / n_band_i2)
    })
  )
  
  plot(get(paste0(
    "rast_", df_raster_data_soil_i2[i, 12], "_rsmp_i2"
  )),
  main = paste0("rast_", df_raster_data_soil_i2[i, 12], "_rsmp_i2"))
  
  print("uses simple method")
}


```

<div class="fold o">   
```{r i2_soil_horizon_weights_02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE}

for (i in seq_len(nrow(df_raster_data_soil_i2))) {
  new_col_i2 <-
    get(paste0("rast_", df_raster_data_soil_i2[i, 12], "_rsmp_i2")) %>% terra::extract(xy_i2) # extract the raster values using xy points
  
  new_col_i2 <- new_col_i2[[1]]
  
  df_irm_i2 <-
    mutate(df_irm_i2,!!as.character(paste0(df_raster_data_soil_i2[i, 3])) := new_col_i2, .keep = c("all"))   # add the raster values to the df_irm_i2 tibble, this needs to be dynamic so uses the !! and := operators
  
}

```
</div>


```{r i2_extract_other_data}
## Add all other criteria data to the IRM spatial database
# some criteria use the same raster data so need to get those rows from df_priorities

df_priorities_single_i2 <- inner_join(df_priorities_i2, select(df_raster_data_single_i2, data_file_prefix), by = "data_file_prefix")

for (i in seq_len(nrow(df_priorities_single_i2))) {
  new_col_i2 <-
    get(paste0("rast_", df_priorities_single_i2[i, 12], "_rsmp_i2")) %>% terra::extract(xy_i2) # extract the raster values using xy points
  
  new_col_i2 <- new_col_i2[[1]]
  
  df_irm_i2 <-
    mutate(df_irm_i2,!!as.character(paste0(df_priorities_single_i2[i, 3])) := new_col_i2, .keep = c("all"))   # add the raster values to the df_irm_i2 tibble, this needs to be dynamic so uses the !! and := operators
  
}

```

# Evaluate lower level rule bases

```{r i2_get_lower_level_data, results = "asis"}

# join to original table using the criterion name

df_leaves_data_i2 <-
  left_join(df_leaves_criterion_i2,
            df_priorities_i2,
            by = c("rulebase_number"))

```



```{r i2_evaluate_lower_level_rules, time_it = TRUE, out.width="100%", results = "asis"}

# Function to populate a list of proposition and conclusion levels

prop_conc_i2 <- function(df_leaves_row_i2) {
  if (!is.na(df_leaves_row_i2["prop_level_3"])) {
    # for those criteria with three proposition values
    prop_levels_i2 <-
      as.character(df_leaves_row_i2[c("prop_level_1", "prop_level_2", "prop_level_3")])
    conc_levels_i2 <-
      df_leaves_row_i2[c("conclusion_1", "conclusion_2", "conclusion_3")]
  } else {
    # for those criteria with two proposition values
    prop_levels_i2 <-
      as.character(df_leaves_row_i2[c("prop_level_1", "prop_level_2")])
    conc_levels_i2 <- df_leaves_row_i2[c("conclusion_1", "conclusion_2")]
  }
  
  return(list(prop_levels_i2 = prop_levels_i2, conc_levels_i2 = conc_levels_i2))
}

result_list_i2 <- list()

cat("\n\n\n")
cat("## Fuzzy Partitions\n") # add headings
cat("\n\n\n")
  
  
# Main function
apply(df_leaves_data_i2, 1, function(df_leaves_row_i2) {

  # Calculate the value list within the main function
  prop_conc_list_i2 <- prop_conc_i2(df_leaves_row_i2)
  prop_levels_i2 <- prop_conc_list_i2$prop_levels_i2
  conc_levels_i2 <- prop_conc_list_i2$conc_levels_i2
  conc_suffixes_i2 <- lapply(conc_levels_i2, function(x)
    substr(x, 1, 1))
  
  cross_points_i2 <-
    as.numeric(c(df_leaves_row_i2["threshold"], ifelse(!is.na(df_leaves_row_i2["threshold2"]), df_leaves_row_i2["threshold2"], NA)))
  
  cross_points_i2 <- cross_points_i2[!is.na(cross_points_i2)]
  
  trans_width_i2 <-
    as.numeric(c(as.numeric(df_leaves_row_i2["width"]), ifelse(
      !is.na(as.numeric(df_leaves_row_i2["width2"])), as.numeric(df_leaves_row_i2["width2"]), NA
    )))
  
  trans_width_i2 <- trans_width_i2[!is.na(trans_width_i2)]
  
  cat("\n\n\n")
  cat("###", df_leaves_row_i2[["criterion"]], "\n") # add headings
  cat("\n\n\n")
      
  plot_xlim_i2 <-
    as.numeric(c((as.numeric(df_leaves_row_i2["threshold"]) - as.numeric(df_leaves_row_i2["width"])), (as.numeric(df_leaves_row_i2["threshold"]) + as.numeric(df_leaves_row_i2["width"]))))
  
  # construct the fuzzy partition
  assign(
    paste0("fp_", as.character(df_leaves_row_i2["rulebase_number"])),
    LinearFuzzyPartition(
      level = prop_levels_i2,
      crossoverPoint = cross_points_i2,
      transitionWidth = trans_width_i2
    ),
    .GlobalEnv
  )
  
  # construct the fuzzy partition plot
  plot_fp_i2 <- plot(
    get(paste0("fp_", as.character(df_leaves_row_i2["rulebase_number"]))),
    xlim = plot_xlim_i2,
    xlab = as.character(df_leaves_row_i2["criterion"]),
    title = "fuzzy partition"
  )
  
  # print the fuzzy partition plot
  print(plot_fp_i2)
  
  # construct the rule bases
  # set the proposition name
  
  Prop_name_i2 <-
    paste0(as.character(df_leaves_row_i2["rulebase_number"]))
  
  # set the conclusion name
  Conc_name_i2 <-
    paste0(as.character(df_leaves_row_i2["rulebase_number"]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop_i2 <- tibble(!!Prop_name_i2 := c(prop_levels_i2))
  # set the conclusion values
  df_conc_i2 <- tibble(!!Conc_name_i2 := c(conc_levels_i2))
  
  # new proposition and conclusion class objects are made here
  new_prop_i2 <- new("Proposition", table = df_prop_i2)
  new_conc_i2 <- new("Conclusion", table = df_conc_i2)
  
  assign(paste0("rb_",
                as.character(df_leaves_row_i2["rulebase_number"])),
         RuleBase(new_prop_i2, new_conc_i2),
         .GlobalEnv)
  
  cat("\n\nRule Base = \n")
  knitr::normal_print(
  print(get(paste0("rb_",
                   as.character(df_leaves_row_i2["rulebase_number"])))))
  
  # apply the fuzzy partitions to the data
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    as.character(df_leaves_row_i2["rulebase_number"]),
    ", newdata = df_irm_i2,",
    as.character(df_leaves_row_i2["rulebase_number"]),
    "=",
    "fp_",
    as.character(df_leaves_row_i2["rulebase_number"]),
    ")"
  )
  
  assign(paste0("fpm_",
                as.character(df_leaves_row_i2["rulebase_number"])), eval(parse(text = x)), .GlobalEnv)
  #print(conc_levels[1])
  
  # Define a function to print each element
  #print_element <- function(x) {
  #  print(x)
  #}
  
  
  # Function to get the membership values of the fuzzy partition matrix for each conclusion value
  # this only works when nested in main function
  
  fpm_values_i2 <- function(conc_value_i2) {
    
  fpm_name_i2 <-
     paste0("fpm_", df_leaves_row_i2["rulebase_number"], "$", conc_value_i2)
    #print(fpm_name)
    conc_col_name_i2 <-
      paste0(df_leaves_row_i2["rulebase_number"], "_", substr(conc_value_i2, 1, 1))
    #print(paste0("suffix = _", substr(conc_value, 1, 1)))
    x <- paste0("getMembership(", fpm_name_i2, ")")
    #print(x)
    #print(eval(parse(text = x)))
    
    # this works
     #result_list <<-
    #   c(result_list, setNames(list(eval(parse(
    #     text = x
    #   ))), conc_col_name))
     
     # construct the fuzzy partition
  assign(paste("result_list_i2"),
     c(result_list_i2, setNames(list(eval(parse(
         text = x
       ))), conc_col_name_i2)),
    .GlobalEnv
  )
    cat(conc_col_name_i2)
    #return(result_list)
  }
  
  # apply the fpm_values to the list of conclusion levels and generate a list of values (result_list)
  lapply(unique(conc_levels_i2), fpm_values_i2)
  #print("done 2")
  #return(result_list)
  
})


# Convert the result list to a data frame
result_df_i2 <- data.frame(matrix(unlist(result_list_i2), ncol = length(result_list_i2), byrow = FALSE))
colnames(result_df_i2) <- names(result_list_i2)

# Bind the result data frame to the original data frame
df_irm_i2 <- cbind(df_irm_i2, result_df_i2)

# Print the updated data frame
#print(df_irm_i2)
cat("\n\n\n")
cat("## Evaluate Rules\n") # add headings
cat("\n\n\n")


# Plot function for evaluated fuzzy partition using main data frame - rowwise across criteria
apply(df_leaves_data_i2, 1, function(df_leaves_row_i2) {
  
  cat("\n\n\n")
  cat("###", df_leaves_row_i2[["criterion"]], "\n") # add headings
  cat("\n\n\n")
  
  prop_conc_list_i2 <- prop_conc_i2(df_leaves_row_i2)
  conc_levels_i2 <- prop_conc_list_i2$conc_levels_i2
  conc_suffixes_i2 <- lapply(conc_levels_i2, function(x)
    substr(x, 1, 1))
  
  # Function to print each conclusion value - per unique object in list of conclusion values
  # this only works when nested in print function
  
  plot_fpm_i2 <- function(conc_value_i2) {
    conc_col_name_i2 <-
      paste0(df_leaves_row_i2["rulebase_number"], "_", substr(conc_value_i2, 1, 1))
    fpm_conc_var_i2 <- c(conc_col_name_i2, "x" , "y")
    fpm_conc_name_i2 <- conc_value_i2

    # spatialise the results
    sf_fpm_i2 <- df_irm_i2 %>%
      dplyr::select(unlist(as.character(noquote(fpm_conc_var_i2)))) %>%
      na.omit() %>%
      st_as_sf(coords = c("x", "y")) %>% na.omit()
    
    # rasterize
    rast_fpm_i2 <-  rasterize(sf_fpm_i2, rast_mask_proj_i2, fpm_conc_var_i2[[1]]) 
    
    # give the rast sensible names
    names(rast_fpm_i2) <- fpm_conc_name_i2
    
    # plot rast using title
    #plot_conc <-
    cat(paste(conc_col_name_i2, "\n\n")) 
    rast_fpm_i2 %>% plot(
      breaks = c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1),
      axes = F,
      main = paste(df_leaves_row_i2[["criterion"]], "-", conc_value_i2)
    )
    cat("\n\n") 
  }
  
  # apply the plot_fpm to the list of conclusion levels and generate plots
  lapply(unique(conc_levels_i2), plot_fpm_i2)
  
  #print("done 4")
  #return(plot_fpm)

})

```

# Higher-level rule base evaluation


``` {r i2_evaluate_higher_level_rules, out.width="100%", results = 'asis' }

# inverse join df_leaves_data to df_priorities

df_rulebases_i2 <-
  anti_join(df_priorities_i2,
            df_leaves_data_i2,
            by = 'rulebase_number',
            copy = FALSE)

#  join df_rulebases to hierarchies_new

# first split hierarchies_new based on hierarchy level

# get highest level

hierarchy_level_max_i2 <- max(unique(hierarchies_new_i2$level_number))
cat(paste("Highest hierarchy level = ", hierarchy_level_max_i2, "\n"))

# initialise FAO limits raster list
list_rast_clas_FAO_cat <- list()

# initialise FAO limits raster list
list_rast_limits_max_FAO <- list()


# for loop to run through all hierarchy levels from biggest to smallest
for (i in hierarchy_level_max_i2:1) {
  cat(paste0('\nLevel', i, "\n"))
  
  # join to the rulebases
  assign(paste0("df_hierarchy_i2_", i),
         inner_join(
           select(df_rulebases_i2, rulebase_number, conclusion_1, conclusion_2, conclusion_3),
           dplyr::filter(select(
             hierarchies_new_i2, level_number, paste0('level', i)
           ), level_number == i),
           by = c('rulebase_number' = paste0('level', i))
         ))
  
  # if no data move to next
  if (nrow(get(paste0("df_hierarchy_i2_", i)) != 0)) {
    cat(paste0("\nLevel", i, " has higher rule bases"))
    
    #Custom function to perform one-to-many join for each row and evaluate rule base
    eval_rule_base_i2 <- function(row) {
      
      # conc_options <-
      #   c(row[["conclusion_1"]], row[["conclusion_2"]], row[["conclusion_3"]])
      # print(conc_options)
      # print(paste("conc_options = ", conc_options))
      
      df_row_i2 <- data.frame(rulebase_number = row[["rulebase_number"]])
      df_one_many_i2 <-
        left_join(
          df_row_i2,
          df_priorities_i2,
          by = c('rulebase_number' = 'rulebase_stack'),
          keep = TRUE
        )
      
      cat("\n\n\n")
      cat("##", unique(df_one_many_i2[["stack"]]), "\n")
      cat("\n\n\n")
      conc_name_i2 <- unique(df_one_many_i2[["rulebase_stack"]])
      
      # cat("\n\nStack = ", df_one_many[["rulebase_stack"]], df_one_many[["stack"]])
      cat("\n\nCriterion = ", df_one_many_i2[["criterion"]])
      # cat("\n\nconc_name = ", conc_name)
      
      
      ### GET OR ADD TO THE FUZZY PARTITION LIST ###
      
      fp_list_i2 <- fn_fill_fp_list(df_one_many_i2) # function gets the fp list
      
      assign(paste0("fp_", conc_name_i2, "_list"),
             fp_list_i2,
             .GlobalEnv) # make a globally available named list
      
      ### GET WEIGHTS ###
      
      weights_i2 <- df_one_many_i2$weight
      weights_glob_i2 <<- weights_i2
      cat(paste0("\n\nWeights = ", weights_i2))
      
      ### CONSTRUCT THE NEW RULE BASE ###    
      
      rb_prefix <- "rb_"
      df_one_many_i2$rb <-
        paste(rb_prefix, df_one_many_i2$rulebase_number.y, sep = "")

      lower_rb_i2 <- df_one_many_i2$rb      # get the rule bases
      # get and print the lower rule bases to ensure that these are available
      #cat(paste("lower_rb = ", lower_rb))
      #str(lower_rb)
      lower_rb_glob_i2 <<-
        lower_rb_i2      # save to global env for debugging
      
      lower_rb_concs_i2 <- lapply(lower_rb_i2, fn_get_rb_conc)
      lower_rb_concs_glob_i2 <<- (lower_rb_concs_i2)      
      lower_rb_props_i2 <- lapply(lower_rb_i2, fn_get_rb_prop)
      lower_rb_props_glob_i2 <<- (lower_rb_props_i2) 
       
      # print(paste("str(lower_rb_concs) =", str(lower_rb_concs)))
      # print(paste("lower_rb_concs =", lower_rb_concs))

      results_rb_i2  <- fn_create_rb(lower_rb_concs_i2, weights_i2, conc_name_i2)
      #str(results_rb)
      result_rb_i2 <- unlist(results_rb_i2[[1]])
      cat("\n\nRule Base = \n")
      #cat(paste(result_rb, "\n"))
      print(result_rb_i2)
      result_rb_conc_i2 <- unlist(results_rb_i2[[2]])
      #cat("\nresult_rb_conc = \n")
      #print(result_rb_conc)

                  
      assign(paste0("rb_", conc_name_i2), result_rb_i2, .GlobalEnv)
      
      
      ### GET OR ADD TO THE RULE BASE STACK ###
      
      rb_list <- fn_fill_rb_list(df_one_many_i2)
      rb_list <-  append(rb_list, paste0("rb_", conc_name_i2))
      rb_list_glob_i2 <<- rb_list
      #cat("\nrb_list = \n")
      #print(rb_list)   
      
      assign(paste0("rb_list_", conc_name_i2), rb_list,
             .GlobalEnv) # convert to rule base list

      newList_i2 <- list("df" = df_one_many_i2, "fp" = fp_list_i2 , "rb" = result_rb_i2, rbs = rb_list)

      
 
      
      # print(get(paste0("rb_list_", conc_name)))
      # str(get(paste0("rb_list_", conc_name)))
      
      # # create the rule base stack from the list
      x <-
        paste("stack(", gsub(",$", "", paste0(
          get(paste0("rb_list_", conc_name_i2)), sep = ",", collapse = ""
        )), ")")
      
      #cat("\nx = \n")
      #print(x)
      
      assign(paste0("rbs_", conc_name_i2, "_i2"), eval(parse(text = x)),
             .GlobalEnv)
      #print(get(paste0("rbs_", conc_name)))
      
      # # evaluate the rule base stack
      
      w <-
        paste0("predict(",
              "rbs_",
              conc_name_i2,
              "_i2, newdata = df_irm_i2,",
              gsub(",$", "", paste0(
                fp_list_i2, sep = ",", collapse = ""
              )),
              ")")
      
      #cat("\nw = \n")
      #print(w)
      assign(paste0("fpm_", conc_name_i2, "_i2"), eval(parse(text = w)),
             .GlobalEnv)

      
      # columns defined by conclusions to rule base
      
      fpm_colnames_i2 <<- pull(distinct(result_rb_conc_i2@table))
      
      #cat("\nfpm_colnames = \n")
      #print(fpm_colnames)
      
      for (j in 1:length(fpm_colnames_i2)) {
        
      col_suffix_i2 <-   substr( fpm_colnames_i2[[j]] , start = 1 , stop = 1 )
      #cat("\ncol_suffix = \n")
      #print(col_suffix)
      
      mem_text_i2 <- paste0("getMembership(","fpm_", conc_name_i2, "_i2$", fpm_colnames_i2[[j]],")")
      #print(mem_text)
      membership_i2 <- eval(parse(text = mem_text_i2))
      
      df_irm_i2 <<-
        mutate(df_irm_i2,!!as.character(paste0(conc_name_i2, "_", col_suffix_i2)) := membership_i2, .keep = c("all"))
        
      }
   
      n_i2 = length(fpm_colnames_i2)
      fpm_conc_var_i2 <- c()
      for (j in 1:length(fpm_colnames_i2)) {
        col_suffix_i2 <-   substr(fpm_colnames_i2[[j]] , start = 1 , stop = 1)
        fpm_conc_var_i2 <-
          c(fpm_conc_var_i2, paste0(conc_name_i2, "_", col_suffix_i2))
      }
      
      fpm_conc_var_i2 <-    c(fpm_conc_var_i2, "x" , "y")
      fpm_conc_name_i2 <- fpm_colnames_i2
      fpm_plot_title_i2 <-    paste(unique(df_one_many_i2[["stack"]]))
      
      plot_fpm_i2 <-
        rasterize_plot_fpm(
          n_i2,
          fpm_conc_var_i2,
          fpm_conc_name_i2,
          df_irm_i2,
          fpm_plot_title_i2,
          rast_mask_proj_i2
        )
      
      print(plot_fpm_i2)
 
      if (i <= params$FAOCLASS2) {
        FAO_leaflet_widget_i2 <<-
          classify_maps_FAO(
            n_i2,
            fpm_conc_var_i2,
            fpm_conc_name_i2,
            df_irm_i2,
            fpm_plot_title_i2,
            df_one_many_i2,
            rast_mask_proj_i2,
            list_rast_clas_FAO_cat,
            vect_subdiv_i2,
            params$INN2
          )
        
      }
      
      if (i <= params$LIMITS2) {
        FAO_limits_leaflet_widget_i2 <<-
          classify_maps_limits(
            n_i2,
            fpm_conc_var_i2,
            fpm_conc_name_i2,
            df_irm_i2,
            fpm_plot_title_i2,
            df_one_many_i2,
            weights_i2,
            rast_mask_proj_i2,
            vect_subdiv_i2,
            list_rast_limits_max_FAO,
            params$INN2
          )
        
      }
      
      return(newList_i2)
      
     }
    
    # Apply the rule base evaluation function to each row of df1
    assign(paste0("df_one_many_i2_", i),
           apply(get(paste0("df_hierarchy_i2_", i)), 1, eval_rule_base_i2))
    
  }
}


```

```{r i2_leaflet_FAO, results = 'asis', out.width="100%"}
if ( params$FAOCLASS2 > 0){
  cat(paste("\n\n## Interactive Classified Map - FAO Suitability Classes \n\n"))
  frameWidget(FAO_leaflet_widget_i2, height = '500')}

```

```{r i2_leaflet_FAOlimits, results = 'asis', out.width="100%"}
if ( params$LIMITS2 > 0){
  cat(paste("\n\n## Interactive Classified Map - FAO Limitations Classes \n\n"))
  frameWidget(FAO_limits_leaflet_widget_i2, height = '500')}

```

# Sub-division statistics

This section gets the statistics for each sub-division, taking into account the dynamically created limitations for adoption, suitability and feasibility.


The existing function expects arguments showing:

1) the number of maps to produce - one per class (of whatever output)
2) a vector of the variables (classes) that need to be mapped (1 and 2 are linked and 1 is not really necessary)
3) a palette of colours with the same number of colours as classes - these are 

The palettes in the current IRM do not match with the any of the colours used in the classified maps.
Instead they are just a distinct colour.

The variables and colour palette names are currently hard coded. The names of the palettes are from the ggplot2 package but derive from colorbrewer, all palettes are sequential. There are 18 named sequential palettes, they can be referenced by name or as an index from the list.

The index works as long as the values do not exceed 18, so need to wrap.

## Area

### FAO Classes

```{r i2_subdiv_area_FAO, results = 'asis', out.width="100%"}

# create a list of valid names of colorbrewer palettes for sequential data
palettes_i2 <-
  c("Blues",
    "YlGn",
    "Greys",
    "Oranges",
    "YlOrRd"
  )


# loop through the FAO class rasters created above

for (i in 1:length(list_rast_clas_FAO_cat))   {
  # get the name of the criteria from the raster name - this is used in the plotting
  subdiv_criteria_name_i2 <- list_rast_clas_FAO_cat[i]
  subdiv_criteria_name_i2 <-
    sub(paste0(".*", "fao_cat"), "", subdiv_criteria_name_i2)
  
  cat("\n\n\n")
  cat("###", subdiv_criteria_name_i2, "\n") # add headings
  cat("\n\n\n")
  
  # get the raster for which statistics are derived for each limitation
  rast_to_plot_i2 <- get(paste0(list_rast_clas_FAO_cat[i]))
  
  # get the cellsize for each raster
  rast_to_plot_cellsize_i2 <- cellSize(rast_to_plot_i2, unit = "ha")
  
  
  # extract the raster class to a data frame using the subdivisions
  df_extr_i2 <-
    terra::extract(rast_to_plot_i2, vect_subdiv_i2, na.rm = TRUE, ID = T, weights = T)
  
    # extract the raster cellsize to a data frame using the subdivisions
  df_extr_cellsize_i2 <-
    terra::extract(rast_to_plot_cellsize_i2, vect_subdiv_i2, na.rm = TRUE, ID = T, weights = T)
  
  df_extr_i2 <- mutate(df_extr_i2, df_extr_cellsize_i2)
  
   # summarise the class for each subdivision raster ID
  df_extr_summary_i2 <- df_extr_i2 %>%
    group_by(ID) %>%
    count(FAO, wt = (area * weight), .drop = FALSE)
  
  # join the summary data frame to the original subdivision data spatvector
  vect_subdiv_extr_i2 <<-
    left_join(vect_subdiv_i2, df_extr_summary_i2, by = 'ID')
  
  # loop through each existing class type 
  for (class_type in unique(vect_subdiv_extr_i2$FAO)) {
    
    # Get the current iteration number
    j_i2 <- match(class_type, unique(vect_subdiv_extr_i2$FAO))

    # get the palette using the iteration number
    colour_index_i2 <- j_i2
    colour_index_mod_i2 <- (colour_index_i2 %% 18)
    colour_index_mod_i2 <-
      ifelse(colour_index_mod_i2 == 0, 18, colour_index_mod_i2)
    result_i2 <- palettes_i2[colour_index_mod_i2]
    
    # Filter the joined data for the current limitation
    filtered_data_i2 <-
      vect_subdiv_extr_i2[vect_subdiv_extr_i2$FAO == class_type,]
    #print(filtered_data)
    
    if (nrow(filtered_data_i2) == 0) {next} 

  
    # Create a ggplot for count value per subdivision for the current class type using the palette from above
    subdiv_plot_i2 <- ggplot() +
      geom_spatvector(data = filtered_data_i2, aes(group = params$SUBDIV2, fill = n)) +
      labs(
        title = paste(subdiv_criteria_name_i2, "\nClass = ", class_type),
        fill = "Area (ha)"
      ) +
      scale_fill_distiller(
        type = "seq",
        palette = result_i2,
        direction = 1,
        limits = c(0, max_area_i2),
        guide = "legend", labels = comma
      ) 
    
    print(subdiv_plot_i2)
  }
}  


```

### FAO Limitations

```{r i2_subdiv_area_FAOlimits, results = 'asis', out.width="100%"}

# create a list of valid names of colorbrewer palettes for sequential data
palettes_i2 <-
  c(
    "Blues",
    "BuGn",
    "BuPu",
    "GnBu",
    "Greens",
    "Greys",
    "Oranges",
    "OrRd",
    "PuBu",
    "PuBuGn",
    "PuRd",
    "Purples",
    "RdPu",
    "Reds",
    "YlGn",
    "YlGnBu",
    "YlOrBr",
    "YlOrRd"
  )


# loop through the limitation rasters created above

for (i in 1:length(list_rast_limits_max_FAO))   {
  # get the name of the criteria from the raster name - this is used in the plotting
  subdiv_criteria_name_i2 <- list_rast_limits_max_FAO[i]
  subdiv_criteria_name_i2 <-
    sub(paste0(".*", "FAO_"), "", subdiv_criteria_name_i2)
  
  cat("\n\n\n")
  cat("###", subdiv_criteria_name_i2, "\n") # add headings
  cat("\n\n\n")
  
  # get the raster for which statistics are derived for each limitation
  rast_to_plot_i2 <- get(paste0(list_rast_limits_max_FAO[i]))
  
  # get the cellsize for each raster
  rast_to_plot_cellsize_i2 <- cellSize(rast_to_plot_i2, unit = "ha")
  
  
  # extract the raster limitations to a data frame using the subdivisions
  df_extr_i2 <-
    terra::extract(rast_to_plot_i2, vect_subdiv_i2, na.rm = TRUE, ID = T, weights = T)
  
    # extract the raster cellsize to a data frame using the subdivisions
  df_extr_cellsize_i2 <-
    terra::extract(rast_to_plot_cellsize_i2, vect_subdiv_i2, na.rm = TRUE, ID = T, weights = T)
  
  df_extr_i2 <- mutate(df_extr_i2, df_extr_cellsize_i2)
  
   # summarise the limitations for each subdivision raster ID
  df_extr_summary_i2 <- df_extr_i2 %>%
    group_by(ID) %>%
    count(FAO_limit, wt = (area * weight), .drop = FALSE)
  
  # join the summary data frame to the original subdivision data spatvector
  vect_subdiv_extr_i2 <<-
    left_join(vect_subdiv_i2, df_extr_summary_i2, by = 'ID')
  
  # loop through each existing limitation type 
  for (limitation_type_i2 in unique(vect_subdiv_extr_i2$FAO_limit)) {
    
    # Get the current iteration number
    j <- match(limitation_type_i2, unique(vect_subdiv_extr_i2$FAO_limit))

    # get the palette using the iteration number
    colour_index_i2 <- j_i2
    colour_index_mod_i2 <- (colour_index_i2 %% 18)
    colour_index_mod_i2 <-
      ifelse(colour_index_mod_i2 == 0, 18, colour_index_mod_i2)
    result_i2 <- palettes_i2[colour_index_mod_i2]
    
    # Filter the joined data for the current limitation
    filtered_data_i2 <-
      vect_subdiv_extr_i2[vect_subdiv_extr_i2$FAO_limit == limitation_type_i2,]
    #print(filtered_data)
    if (nrow(filtered_data_i2) == 0) {next} 
    

    
    # Create a ggplot for count value per subdivision for the current limitation type using the palette from above
    subdiv_plot_i2 <- ggplot() +
      geom_spatvector(data = filtered_data_i2, aes(group = params$SUBDIV2, fill = n)) +
      labs(
        title = paste(subdiv_criteria_name_i2, "\nLimit = ", limitation_type_i2),
        fill = "Area (ha)"
      ) +
      scale_fill_distiller(
        type = "seq",
        palette = result_i2,
        direction = 1,
        limits = c(0, max_area_i2),
        guide = "legend", labels = comma
      ) 
    
    print(subdiv_plot_i2)
  }
}  


```

## Percentage

### FAO Classes

```{r i2_subdiv_pc_FAO, results = 'asis', out.width="100%"}

# create a list of valid names of colorbrewer palettes for sequential data
palettes_i2 <-
  c("Blues",
    "YlGn",
    "Greys",
    "Oranges",
    "YlOrRd"
  )


# loop through the FAO class rasters created above

for (i in 1:length(list_rast_clas_FAO_cat))   {
  # get the name of the criteria from the raster name - this is used in the plotting
  subdiv_criteria_name_i2 <- list_rast_clas_FAO_cat[i]
  subdiv_criteria_name_i2 <-
    sub(paste0(".*", "fao_cat"), "", subdiv_criteria_name_i2)
  
  cat("\n\n\n")
  cat("###", subdiv_criteria_name_i2, "\n") # add headings
  cat("\n\n\n")
  
  # get the raster for which statistics are derived for each limitation
  rast_to_plot_i2 <- get(paste0(list_rast_clas_FAO_cat[i]))
  
  # get the cellsize for each raster
  rast_to_plot_cellsize_i2 <- cellSize(rast_to_plot_i2, unit = "ha")
  
  
  # extract the raster class to a data frame using the subdivisions
  df_extr_i2 <-
    terra::extract(rast_to_plot_i2, vect_subdiv_i2, na.rm = TRUE, ID = T, weights = T)
  
    # extract the raster cellsize to a data frame using the subdivisions
  df_extr_cellsize_i2 <-
    terra::extract(rast_to_plot_cellsize_i2, vect_subdiv_i2, na.rm = TRUE, ID = T, weights = T)
  
  df_extr_i2 <- mutate(df_extr_i2, df_extr_cellsize_i2)
  
   # summarise the class for each subdivision raster ID
  df_extr_summary_i2 <- df_extr_i2 %>%
    group_by(ID) %>%
    count(FAO, wt = (area * weight), .drop = FALSE)
  
  # join the summary data frame to the original subdivision data spatvector
  vect_subdiv_extr_i2 <<-
    left_join(vect_subdiv_i2, df_extr_summary_i2, by = 'ID')
  
   # join the summary data frame to the subdivision area data frame
  vect_subdiv_extr_i2 <<-
    left_join(vect_subdiv_extr_i2, df_subdiv_area_i2, by = 'ID') 
  
  vect_subdiv_extr_i2 <<-
    mutate(vect_subdiv_extr_i2, area_pc = (n/ha)*100) 
  
  # loop through each existing class type 
  for (class_type in unique(vect_subdiv_extr_i2$FAO)) {
    
    # Get the current iteration number
    j_i2 <- match(class_type, unique(vect_subdiv_extr_i2$FAO))

    # get the palette using the iteration number
    colour_index_i2 <- j_i2
    colour_index_mod_i2 <- (colour_index_i2 %% 18)
    colour_index_mod_i2 <-
      ifelse(colour_index_mod_i2 == 0, 18, colour_index_mod_i2)
    result_i2 <- palettes_i2[colour_index_mod_i2]
    
    # Filter the joined data for the current limitation
    filtered_data_i2 <-
      vect_subdiv_extr_i2[vect_subdiv_extr_i2$FAO == class_type,]
    #print(filtered_data)
    if (nrow(filtered_data_i2) == 0) {next} 

    # Create a ggplot for count value per subdivision for the current class type using the palette from above
    
    filtered_data_global_i2 <<- filtered_data_i2
      
    subdiv_plot_i2 <- ggplot() +
      geom_spatvector(data = filtered_data_i2, aes(group = params$SUBDIV2, fill = area_pc)) +
      labs(
        title = paste(subdiv_criteria_name_i2, "\nClass = ", class_type),
        fill = "Area (%)"
      ) +
      scale_fill_distiller(
        type = "seq",
        palette = result_i2,
        direction = 1,
        limits = c(0, 101),
        guide = "legend", labels = comma
      ) 
    
    print(subdiv_plot_i2)
  }
}  


```

### FAO Limitations

```{r i2_subdiv_pc_FAOlimits, results = 'asis', out.width="100%"}

# create a list of valid names of colorbrewer palettes for sequential data
palettes_i2 <-
  c(
    "Blues",
    "BuGn",
    "BuPu",
    "GnBu",
    "Greens",
    "Greys",
    "Oranges",
    "OrRd",
    "PuBu",
    "PuBuGn",
    "PuRd",
    "Purples",
    "RdPu",
    "Reds",
    "YlGn",
    "YlGnBu",
    "YlOrBr",
    "YlOrRd"
  )


# loop through the limitation rasters created above

for (i in 1:length(list_rast_limits_max_FAO))   {
  # get the name of the criteria from the raster name - this is used in the plotting
  subdiv_criteria_name_i2 <- list_rast_limits_max_FAO[i]
  subdiv_criteria_name_i2 <-
    sub(paste0(".*", "FAO_"), "", subdiv_criteria_name_i2)
  
  cat("\n\n\n")
  cat("###", subdiv_criteria_name_i2, "\n") # add headings
  cat("\n\n\n")
  
  # get the raster for which statistics are derived for each limitation
  rast_to_plot_i2 <- get(paste0(list_rast_limits_max_FAO[i]))
  
  # get the cellsize for each raster
  rast_to_plot_cellsize_i2 <- cellSize(rast_to_plot_i2, unit = "ha")
  
  
  # extract the raster limitations to a data frame using the subdivisions
  df_extr_i2 <-
    terra::extract(rast_to_plot_i2, vect_subdiv_i2, na.rm = TRUE, ID = T, weights = T)
  
    # extract the raster cellsize to a data frame using the subdivisions
  df_extr_cellsize_i2 <-
    terra::extract(rast_to_plot_cellsize_i2, vect_subdiv_i2, na.rm = TRUE, ID = T, weights =T)
  
  df_extr_i2 <- mutate(df_extr_i2, df_extr_cellsize_i2)
  
   # summarise the limitations for each subdivision raster ID
  df_extr_summary_i2 <- df_extr_i2 %>%
    group_by(ID) %>%
    count(FAO_limit, wt = (area * weight), .drop = FALSE)
  
  # join the summary data frame to the original subdivision data spatvector
  vect_subdiv_extr_i2 <<-
    left_join(vect_subdiv_i2, df_extr_summary_i2, by = 'ID')
  
  # join the summary data frame to the subdivision area data frame
  vect_subdiv_extr_i2 <<-
    left_join(vect_subdiv_extr_i2, df_subdiv_area_i2, by = 'ID')
  
  vect_subdiv_extr_i2 <<-
    mutate(vect_subdiv_extr_i2, area_pc = (n / ha) * 100)  
  
  # loop through each existing limitation type 
  for (limitation_type_i2 in unique(vect_subdiv_extr_i2$FAO_limit)) {
    
    # Get the current iteration number
    j_i2 <- match(limitation_type_i2, unique(vect_subdiv_extr_i2$FAO_limit))

    # get the palette using the iteration number
    colour_index_i2 <- j_i2
    colour_index_mod_i2 <- (colour_index_i2 %% 18)
    colour_index_mod_i2 <-
      ifelse(colour_index_mod_i2 == 0, 18, colour_index_mod_i2)
    result_i2 <- palettes_i2[colour_index_mod_i2]
    
    # Filter the joined data for the current limitation
    filtered_data_i2 <-
      vect_subdiv_extr_i2[vect_subdiv_extr_i2$FAO_limit == limitation_type_i2,]
    #print(filtered_data)
    if (nrow(filtered_data_i2) == 0) {next} 
    
    # Create a ggplot for count value per subdivision for the current limitation type using the palette from above
    subdiv_plot_i2 <- ggplot() +
      geom_spatvector(data = filtered_data_i2, aes(group = params$SUBDIV2, fill = area_pc)) +
      labs(
        title = paste(subdiv_criteria_name_i2, "\nLimit = ", limitation_type_i2),
        fill = "Area (%)"
      ) +
      scale_fill_distiller(
        type = "seq",
        palette = result_i2,
        direction = 1,
        limits = c(0, 101),
        guide = "legend", labels = comma
      ) 
    
    print(subdiv_plot_i2)
  }
}  


```

# Calculate yields and production

## Yield proportion

The IRM script already calculates the optimality of the individual criteria as well as the climatic, landscape, soil fertility and soil physical properties groups of criteria.

The first method of calculating yield will calculate the product of the optimality of selected criteria.

<div class="fold o"> 
```{r i2_calc_yield_pc, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", include = TRUE, echo=FALSE, message=FALSE, warning=FALSE}

# get the criteria that contribute to yield

df_yield_rb_1_i2 <- dplyr::select(df_priorities_i2, "rulebase_number","criterion","yield") %>% dplyr::filter(!is.na(yield))

df_yield_rb_1_i2 %>% kable(digits = 3) %>% kable_styling("striped", full_width = T)  %>%  scroll_box(height = "500px")
# make an expression using the rule base numbers

yield_expr_i2 <- paste("df_irm_i2$yieldpc <- (")

for (i in seq(from = 1,
              to = nrow(df_yield_rb_1_i2),
              by = 1)) {
  yield_expr_i2 <- paste0(yield_expr_i2, "df_irm_i2$" , as.character(df_yield_rb_1_i2[i, 1]), "_o * ")
  
}
yield_expr_i2 <- paste(yield_expr_i2, " 100)")
yield_expr_i2

# evaluate the expression
eval(str2expression(yield_expr_i2))
# str(df_irm_i2$yieldpc)
if (summarise(df_irm_i2, Average = mean(yieldpc, na.rm = T)) > 0) {

# df_irm_i2 <- dplyr::select(df_irm_i2,-yield)

vect_yieldpc_i2 <- select(df_irm_i2, x, y, yieldpc) %>% na.omit %>% vect(geom = c("x", "y"))

rast_yieldpc_i2 <- rasterize(vect_yieldpc_i2, rast_mask_proj_i2, field="yieldpc")
names(rast_yieldpc_i2) <- c('yieldpc')

# export
output_geotiff(rast_yieldpc_i2, paste0("yieldpc_", params$INN2))

#  dy <- rast_yield %>%
#    as.data.frame(xy = TRUE) %>%
#    na.omit

  
  gy_i2 <- ggplot() +
    geom_spatraster(data = rast_yieldpc_i2, aes(fill = yieldpc)) +
    scale_fill_stepsn(
      paste0("Yield % \n", params$INN2),
      n.breaks = 10,
      limits = c(0, 100),
      colours = hcl.colors(palette = "Greens", 10, rev = TRUE),
      guide = "legend",  na.value = "transparent"
    ) +
#    scale_x_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
#    scale_y_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
    coord_sf()
  
  gy2_i2 <- add_subdiv_proj_simple_plot(gy_i2, vect_subdiv_i2)
gy2_i2
}
```
</div>

## Calculate yield

The IRM script converts yield proportion to yield using the yield values for sole crop or intercrop.

<div class="fold o"> 
```{r i2_calc_yield, cache = TRUE, cache.whatever=params$Agg, out.width="100%", include = TRUE, echo=FALSE, message=FALSE, warning=FALSE}

# get the criteria that contribute to yield

filename_yield_i2 <-
  as.character(paste("tab_data/input/yield_", params$INN2, ".csv", sep = ""))
df_yield_values_i2 <- read.csv(here(filename_yield_i2), na.strings = c("NA"))

df_yield_values_i2 %>% kable(digits = 3) %>% kable_styling("striped", full_width = T)  %>%  scroll_box(height = "100px")


if (params$INN2 == "NA") {
  df_irm_i2$yield <- df_irm_i2$yieldpc / 100 * df_yield_values_i2$YW
  cat("Sole crop yield")
} else {
  if (params$SYS == "comparison") {
    df_irm_i2$yield <- df_irm_i2$yieldpc / 100 * df_yield_values_i2$YW
    cat("Sole crop 1 yield (comparison)")
  } else {
    if (params$SYS == "intercrop") {
      df_irm_i2$yield <- df_irm_i2$yieldpc / 100 * df_yield_values_i2$YI
      cat("Intercrop 1 yield")
    } else {
      if (params$SYS == "rotation") {
        df_irm_i2$yield <- df_irm_i2$yieldpc / 100 * df_yield_values_i2$YW
        cat("Rotation crop 1 yield")
      }
    }
  }
}

if (summarise(df_irm_i2, Average = mean(yield, na.rm = T)) > 0) {
  
  vect_yield_i2 <-
    select(df_irm_i2, x, y, yield) %>% na.omit %>% vect(geom = c("x", "y"))
  
  rast_yield_i2 <- rasterize(vect_yield_i2, rast_mask_proj_i2, field = "yield")
  names(rast_yield_i2) <-  c('yield')

# export
output_geotiff(rast_yield_i2, paste0("yield_", params$INN2))

#dyd <- dByd %>%
#  as.data.frame(xy = TRUE) %>%
#  na.omit


gyd_i2 <- ggplot() +
  geom_spatraster(data = rast_yield_i2, aes(fill = yield)) +
  scale_fill_stepsn(
    paste0("Yield (kg/ha) \n", params$INN2),
    n.breaks = 10,
    colours = hcl.colors(palette = "OrRd", 10, rev = TRUE),
    guide = "legend",
    labels = comma,  na.value = "transparent"
  ) +
#  scale_x_continuous(
#    name = "",
#    labels = function(x) {
#      1.0e-3 * x
#    }
#  ) +
#  scale_y_continuous(
#    name = "",
#    labels = function(x) {
#      1.0e-3 * x
#    }
#  ) +
  coord_sf()

  gyd2_i2 <- add_subdiv_proj_simple_plot(gyd_i2, vect_subdiv_i2)
gyd2_i2
}
```
</div>

## Calculate production

The IRM script converts yield proportion to production using the yield values for sole crop or intercrop.

<div class="fold o">
```{r i2_calc_production, cache = TRUE, cache.whatever=params$Agg, out.width="100%", include = TRUE, echo=FALSE, message=FALSE, warning=FALSE}

# get the criteria that contribute to yield

#yield_filename <-
#  as.character(paste("tab_data/input/yield_", params$INN2, ".csv", sep = ""))
#yield_tab <- read.csv(here(yield_filename), na.strings = c("NA"))

#yield_tab %>% kable(digits = 3) %>% kable_styling("striped", full_width = T)  %>%  scroll_box(height = "150px")

df_irm_i2$production <- df_irm_i2$yieldpc *  Stat_factor_ha_i2

if (summarise(df_irm_i2, Average = mean(production, na.rm = T)) > 0) {
  vect_production_i2 <-
    select(df_irm_i2, x, y, production) %>% na.omit %>% vect(geom = c("x", "y"))
  
  rast_production_i2 <-
    rasterize(vect_production_i2, rast_mask_proj_i2, field = "production")
  names(rast_production_i2) <- c('production')
  
  # export
  output_geotiff(rast_production_i2, paste0("production_", params$INN2))
  
  #  dp <- dBp %>%
  #    as.data.frame(xy = TRUE) %>%
  #    na.omit
  
  gp_i2 <- ggplot() +
    geom_spatraster(data = rast_production_i2, aes(fill = production)) +
    scale_fill_stepsn(
      paste0("Production (kg) \n", params$INN2),
      n.breaks = 10,
      colours = hcl.colors(palette = "BuPu", 10, rev = TRUE),
      guide = "legend",
      labels = comma,
      na.value = "transparent"
    ) +
#    scale_x_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
#    scale_y_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
    coord_sf()
  
  gp2_i2 <- add_subdiv_proj_simple_plot(gp_i2, vect_subdiv_i2)
  gp2_i2
}
```
</div>


# Compare the innovations

## Suitability comparison

In this case we compare the likelihood for adoption, biophysical suitability or socio-economic feasibility of two innovations.

This comparison depends on the two innovations sharing the same higher-level rule bases. This will be applied only to the hierarchical levels that have classified maps.

```{r compare_rule_bases, results='asis', out.width="100%", message=FALSE, warning=FALSE}

# which levels have higher-level rule bases?
# level 1 is root so is not counted
num_higher_levels <- (min(c(hierarchy_level_max_i1, hierarchy_level_max_i2)) -1)

# which levels have potentially classified maps?
num_levels_FAO <- min(c(params$FAOCLASS1, params$FAOCLASS2, num_higher_levels))

# initialise vector of rule bases for each innovation
rb_i1 <- c()
rb_i2 <- c()  
  
# for each higher level with classified maps add the rule base number to a list...
for (i in num_levels_FAO:1) {
  
# get the higher-level rule base number
 print(i) 
 
 rb_i1 <- c(rb_i1, get(paste0("df_hierarchy_i1_", i))$rulebase_number)
 #print(rb_i1)
 str(rb_i1)
 #print(length(rb_i1))
 
 
 rb_i2 <- c(rb_i2, get(paste0("df_hierarchy_i2_", i))$rulebase_number)
 #print(rb_i2)
 str(rb_i2)
 #print(length(rb_i2))
  
}

#get the rule bases that appear in both innovations

rb_i12 <- unique(rb_i1[rb_i1 %in% rb_i2])
str(rb_i12)

for (j in 1:length(rb_i12)) {
  print(rb_i12[j])
  
  # get the output rasters for innovation 1
  
  geotiff_filename_i1 <-
    as.character(paste(
      "spatial_data/output/FAO_",
      rb_i12[j],
      "_",
      params$INN1,
      ".tif",
      sep = ""
    ))
  print(geotiff_filename_i1)
    
  # get the optimality layers for each innovation for innovation 1
  
  assign(paste0("rast_FAO_", rb_i12[j], "_", params$INN1),
         rast(here(geotiff_filename_i1), lyrs = 1))
  
  print(paste0("rast_FAO_", rb_i12[j], "_", params$INN1))
  plot(get(paste0("rast_FAO_", rb_i12[j], "_", params$INN1)), main = paste0(rb_i12[j], "_", params$INN1))
  
  # get the output rasters for innovation 2
  
  geotiff_filename_i2 <-
    as.character(paste(
      "spatial_data/output/FAO_",
      rb_i12[j],
      "_",
      params$INN2,
      ".tif",
      sep = ""
    ))
  print(geotiff_filename_i2)
  
  # get the optimality layers for each innovation for innovation 2
  assign(paste0("rast_FAO_", rb_i12[j], "_", params$INN2),
         rast(here(geotiff_filename_i2), lyrs = 1))
  
  print(paste0("rast_FAO_", rb_i12[j], "_", params$INN2))
  plot(get(paste0("rast_FAO_", rb_i12[j], "_", params$INN2)), main = paste0(rb_i12[j], "_", params$INN2))
  
  # compare the scores - choose the maximum for each pixel 
  
  assign(paste0("rast_FAO_", rb_i12[j], "_max"), max(get(
    paste0("rast_FAO_", rb_i12[j], "_", params$INN1)
  ), get(
    paste0("rast_FAO_", rb_i12[j], "_", params$INN2)
  )))
  
  # plot and save the raster
  
  print(paste0("rast_FAO_", rb_i12[j], "_max"))
  plot(get(paste0("rast_FAO_", rb_i12[j], "_max")), main = paste0("max ", rb_i12[j]))
  
  
  rast_filename_rb_i12_max <- 
    as.character(paste(
      "spatial_data/output/FAO_",
      rb_i12[j], "_", params$INN1, "_", params$INN2,
      "_max_optimal.tif",
      sep = ""
    ))
  print(rast_filename_rb_i12_max)
  
  writeRaster(get(paste0("rast_FAO_", rb_i12[j], "_max")), here(rast_filename_rb_i12_max), overwrite = TRUE)
  
  # compare the scores - get which is bigger
  
  
  assign(paste0("rast_FAO_", rb_i12[j], "_whichmax"), which.max(c(get(
    paste0("rast_FAO_", rb_i12[j], "_", params$INN1)
  ), get(
    paste0("rast_FAO_", rb_i12[j], "_", params$INN2)
  ))))
  
    # plot and save the raster
  
  print(paste0("rast_FAO_", rb_i12[j], "_whichmax"))
  plot(get(paste0("rast_FAO_", rb_i12[j], "_whichmax")), main = paste0("_whichmax ", rb_i12[j]))
  
  
  rast_filename_rb_i12_whichmax <- 
    as.character(paste(
      "spatial_data/output/FAO_",
      rb_i12[j], params$INN1, "_", params$INN2,
      "_whichmax_optimal.tif",
      sep = ""
    ))
  print(rast_filename_rb_i12_whichmax)
  
  writeRaster(get(paste0("rast_FAO_", rb_i12[j], "_whichmax")), here(rast_filename_rb_i12_whichmax), overwrite = TRUE)
  
  
  # get the limitations rasters
  # get the output rasters for innovation 1
  
  geotiff_filename_i1 <-
    as.character(paste(
      "spatial_data/output/FAO_limits_",
      rb_i12[j],
      "_",
      params$INN1,
      ".tif",
      sep = ""
    ))
  print(geotiff_filename_i1)
  
  # get the limitations layers for innovation 1
  
  assign(paste0("rast_FAO_limits_", rb_i12[j], "_", params$INN1),
         rast(here(geotiff_filename_i1), lyrs = 1))
  
  print(paste0("rast_FAO_limits_", rb_i12[j], "_", params$INN1))
  plot(get(paste0("rast_FAO_limits_", rb_i12[j], "_", params$INN1)), main = paste0(rb_i12[j], "_limits_", params$INN1))
  
  # get the output rasters for innovation 2
  
  geotiff_filename_i2 <-
    as.character(paste(
      "spatial_data/output/FAO_limits_",
      rb_i12[j],
      "_",
      params$INN2,
      ".tif",
      sep = ""
    ))
  print(geotiff_filename_i2)
  
  # get the limitations layers for innovation 2
  assign(paste0("rast_FAO_limits_", rb_i12[j], "_", params$INN2),
         rast(here(geotiff_filename_i2), lyrs = 1))
  
  print(paste0("rast_FAO_limits_", rb_i12[j], "_", params$INN2))
  plot(get(paste0("rast_FAO_limits_", rb_i12[j], "_", params$INN2)), main = paste0(rb_i12[j], "_limits_", params$INN2))
  
  # use the whichmax optimal raster as an index to choose the raster of limitations
  
  # assign(
  #   paste0("rast_FAO_limits_", rb_i12[j], "_max"),
  #   selectRange(c(get(
  #     paste0("rast_FAO_limits_", rb_i12[j], "_", params$INN1)
  #   ), get(
  #     paste0("rast_FAO_limits_", rb_i12[j], "_", params$INN2)
  #   )),
  #   get(
  #     paste0("rast_FAO_", rb_i12[j], "_whichmax")
  #   ),
  #   z = 1))
  #   
  #   print(paste0("rast_FAO_limits_", rb_i12[j], "_max"))
  #   plot(get(
  #     paste0("rast_FAO_limits_", rb_i12[j], "_max")
  #   ), main = paste0("rast_FAO_limits_", rb_i12[j], "_max")
  #   )
  
    # this is not optimal because it does not give the categorical values of the limitations - just a number
  
  
    # alternative - convert the index raster to points
    # for each index number extract from the relevant categorical raster and create a df
    
    #convert which.max raster to vector to use for extraction

    assign(paste0("vect_FAO_", rb_i12[j], "_whichmax"), as.points(get(
      paste0("rast_FAO_", rb_i12[j], "_whichmax")
    )))
    
    #filter the which.max vector and extract from the limits raster for each innovation
    
    assign(paste0("df_FAO_limits_", rb_i12[j], "_whichmax_1"),
           terra::extract(get(paste0("rast_FAO_limits_", rb_i12[j], "_", params$INN1)
           ) , tidyterra::filter(get(
             paste0("vect_FAO_", rb_i12[j], "_whichmax")
           ), which.max == 1), ID=FALSE, cells = TRUE))
    
    assign(paste0("df_FAO_limits_", rb_i12[j], "_whichmax_2"),
           terra::extract(get(
             paste0("rast_FAO_limits_", rb_i12[j], "_", params$INN2)
           ), tidyterra::filter(get(
             paste0("vect_FAO_", rb_i12[j], "_whichmax")
           ), which.max== 2), ID=FALSE, cells = TRUE))
    
    # combine the df, join to vector and convert back to raster
          
    assign(paste0("df_FAO_limits_", rb_i12[j], "_whichmax"), arrange(rbind(get(
      paste0("df_FAO_limits_", rb_i12[j], "_whichmax_1")
    ), get(
      paste0("df_FAO_limits_", rb_i12[j], "_whichmax_2")
    )), cell))
    
    assign(paste0("vect_FAO_limits_", rb_i12[j], "_whichmax"),
           cbind(get(
             paste0("vect_FAO_", rb_i12[j], "_whichmax")
           ), get(
             paste0("df_FAO_limits_", rb_i12[j], "_whichmax")
           )))
    
    #vect_limits_whichmax$limit_code <- as.numeric(factor(lyr.1))
    
    #assign(paste0("vect_FAO_limits_", rb_i12[j], "_whichmax$limit_code"),
    #       as.numeric(factor("FAO_limit")))
    
    expr_recode <-
      parse(
        text = paste0(
          "vect_FAO_limits_",  rb_i12[j],
          "_whichmax$limit_code <- as.numeric(factor(vect_FAO_limits_",  rb_i12[j],
          "_whichmax$FAO_limit))"
        )
      )
      
    eval(expr_recode)      
    
    #df_limits_code <- na.omit(distinct(as.data.frame(select(vect_limits_whichmax,limit_code,lyr.1))))     
    
    assign(paste0("df_limits_code_", rb_i12[j]), na.omit(distinct(
      select(as.data.frame(get(
        paste0("vect_FAO_limits_", rb_i12[j], "_whichmax")
      )), limit_code, FAO_limit)
    )))
    
    assign(
      paste0("rast_FAO_limits_", rb_i12[j], "_whichmax"),
      rasterize(get(
        paste0("vect_FAO_limits_", rb_i12[j], "_whichmax")
      ), rast_mask_proj_i1 , field = "limit_code")
    )
    
    # need to create a df of ID and FAO_limit to create categories
    
    # assign(paste0("df_FAO_limits_", rb_i12[j], "_ID"), as.data.frame(tidyterra::select(get(
    #     paste0("vect_FAO_limits_", rb_i12[j], "_whichmax")), cell, FAO_limit)))
    
    
    # print(get(paste0("df_FAO_limits_", rb_i12[j], "_ID")))
    # assign(levels(get(paste0("rast_FAO_limits_", rb_i12[j], "_whichmax"))$FAO_limit),
    #   get(paste0("df_FAO_limits_", rb_i12[j], "_ID")))

    expr_levels <-
      parse(
        text = paste0(
          "levels(rast_FAO_limits_",
          rb_i12[j],
          "_whichmax) <- df_limits_code_",
          rb_i12[j])
      )
    
    #print(expr_levels)
    eval(expr_levels)        
            
    plot(get(paste0("rast_FAO_limits_", rb_i12[j], "_whichmax")),
         main = paste0("rast_FAO_limits_", rb_i12[j], "_whichmax"))
    
    rast_filename_rb_i12_FAO_limits_whichmax <-
      as.character(paste(
        "spatial_data/output/FAO_limits_",
        rb_i12[j], params$INN1, "_", params$INN2,
        "_whichmax.tif",
        sep = ""
      ))
    
    writeRaster(get(paste0("rast_FAO_limits_", rb_i12[j], "_whichmax")),
                here(rast_filename_rb_i12_FAO_limits_whichmax),
                overwrite = TRUE)
    
}


```


## Yield comparison

<div class="fold o"> 
```{r classified compare_score_maps1, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", message=FALSE, warning=FALSE, timeit = TRUE}

yield_pc_i1_df <-
  df_irm_i1 %>% dplyr::select(yieldpc, x , y) %>% na.omit #%>% vect(geom = c("x", "y"))

yield_pc_i2_df <-
  df_irm_i2 %>% dplyr::select(yieldpc) %>% na.omit %>%
  dplyr::rename(yieldpc_i2 = yieldpc)

yield_pc_diff_df <- cbind(yield_pc_i1_df, yield_pc_i2_df)

# complementary score
#yield_pc_diff_df$compl <-
#  (yield_pc_diff_df$yieldpc + yield_pc_diff_df$yieldpc_i2)

# relative difference score
yield_pc_diff_df$diff <-
  yield_pc_diff_df$yieldpc - yield_pc_diff_df$yieldpc_i2

# absolute difference score
#yield_pc_diff_df$absdiff <-
#  abs(yield_pc_diff_df$yieldpc - yield_pc_diff_df$yieldpc_i2)

# decimal difference score for plotting
yield_pc_diff_df$diff_dec <- yield_pc_diff_df$diff / 100

# max innovation name
yield_pc_diff_df$max_inn_name <-
  ifelse(
    yield_pc_diff_df$yieldpc > yield_pc_diff_df$yieldpc_i2,
    paste(params$INN1),
    ifelse(
      yield_pc_diff_df$yieldpc < yield_pc_diff_df$yieldpc_i2,
      paste(params$INN2) ,
      "equal"
    )
  )

# max innovation id for plotting
yield_pc_diff_df$max_inn_id <- as.integer(ifelse(
  yield_pc_diff_df$yieldpc > yield_pc_diff_df$yieldpc_i2,
  1,
  ifelse(yield_pc_diff_df$yieldpc < yield_pc_diff_df$yieldpc_i2, 2 , 0)
))

vect_yield_pc_diff <-
  yield_pc_diff_df %>% na.omit %>% vect(geom = c("x", "y"))

rast_yield_pc_diff <-
  rasterize(vect_yield_pc_diff,
            rast_mask_proj_i1,
            field = c("diff", "diff_dec", "max_inn_id"))

rast_yield_pc_diff_cat <- rast_yield_pc_diff
df_int <-
  data.frame(id = 0:2,
             max_inn_id = c("equal", "potato", "superpotato"))
levels(rast_yield_pc_diff_cat$max_inn_id) <- df_int

names(rast_yield_pc_diff_cat) <- c('difference', 'decimal difference', 'innovation')

# export
output_geotiff(rast_yield_pc_diff_cat, paste0("difference_", params$INN1,"_", params$INN2))


colour_breaks <- c(-1, 0, 1)
colours <- c("#004D40", "#FFC107", "#D81B60")

gc <- ggplot() +
  geom_spatraster(data = rast_yield_pc_diff,
                  na.rm = TRUE,
                  aes(fill = diff_dec, alpha = after_stat(abs(value)))) +
  scale_fill_gradientn(
    name = "most suitable\ninnovation",
    na.value = "transparent",
    limits  = c(-1, 1),
    colours = colours[c(1, seq_along(colours), length(colours))],
    breaks = c(-1, 0, 1),
    labels = c(paste(params$INN2), "equal", paste(params$INN1))
  ) +
  scale_alpha(guide = 'none')


gc2 <- add_subdiv_proj_simple_plot(gc, vect_subdiv_i1)

gc2


```
</div>

<div class="fold o">
```{r classified combine_score_maps1, cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, timeit = TRUE}

if (params$SYS != "comparison") {
      
#complementary score
yield_pc_diff_df$compl <-
  (yield_pc_diff_df$yieldpc + yield_pc_diff_df$yieldpc_i2)

vect_yield_pc_diff <-
  yield_pc_diff_df %>% na.omit %>% vect(geom = c("x", "y"))

rast_yield_pc_compl <-
  rasterize(vect_yield_pc_diff,
            rast_mask_proj_i1,
            field = c("compl"))

names(rast_yield_pc_compl) <- c('complementary')

# export
output_geotiff(rast_yield_pc_compl, paste0("complementary_", params$INN1,"_", params$INN2))
        

gcsum <- ggplot() +
  geom_spatraster(data = rast_yield_pc_compl,
                  na.rm = TRUE,
                  aes(fill = complementary)) +
  scale_fill_stepsn(
    na.value = "transparent",
    n.breaks = 10,
    colours = hcl.colors(palette = "PiYG", 10, rev = FALSE),
    guide = "legend") +
  labs(fill = "Combined yield %")



  gcsum2 <- add_subdiv_proj_simple_plot(gcsum, vect_subdiv_i1)
  
gcsum2

}
```
</div>


  
```{r}

if (params$INT == 1)
  shiny::setProgress(0.99, message = "Finished - just writing html file")  # set progress to 99%
```
  
# Session Information
  
<div class="fold o"> 
```{r}

sessionInfo()

``` 
</div>

# Acknowledgements

Javascript code and css style used in this script by Martin Schmelzer

https://stackoverflow.com/questions/37755037/how-to-add-code-folding-to-output-chunks-in-rmarkdown-html-documents


Timing for chunks by Yihui Xie
https://stackoverflow.com/questions/24595280/timing-for-chunks