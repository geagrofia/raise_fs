---
title: Hierarchies of criteria in IRM
author: ""
date: "`r Sys.Date()`"
output:
  html_document:  
    code_folding: "hide"
    theme: united
    number_sections: no
    toc: yes
    toc_float: true
    toc_depth: 6
    css: js/style.css
params:
  INT: NA
  SYS: comparison
  Agg: 1
  MASK: 5000
  INN1: tester
  RES1: 3
  SOS1: 1
  SUBDIV1: Kebelle
  TRIAD1: Adoption
  TRIBA1: Aptitude
  TRISE1: Feasibility
  INN2: lg_superpotato
  RES2: 3
  SOS2: 1
  SUBDIV2: Kebelle
  TRIAD2: Adoption
  TRIBA2: Aptitude
  TRISE2: Feasibility

---

<style>
pre {
  overflow-x: auto;
}
pre code {
  word-wrap: normal;
  white-space: pre;
}

div.INN { background-color:#e6f0ff; border-radius: 5px; padding: 10px; font-size: 200%;  color: orange;}
div.Agg { background-color:#e6f0ff; border-radius: 5px; padding: 10px; font-size: 150%;  color: orange;}

</style>

<script src="js/hideOutput.js"></script>



```{r setup, include=FALSE}


library(dplyr)
library(tidyr)
library(data.tree)
library(knitr)
library(kableExtra)
library(here)
library(irm)
library(fuZR)
library(sf)
library(terra)
library(stringr)
library(purrr)

r_filename <- function(filename) {
  here::here("code/r/", filename)
}

source(r_filename("irm_functions.R"))


#set (chunk) options - figure path is necessary to avoid an error message
opts_chunk$set(
  comment = NA,
  dpi = 96,
  echo = FALSE,
  fig.path = paste0("figures/", params$INN1,"/"),
  warning = FALSE,
  cache = FALSE,
  time_it = TRUE,
  include = TRUE
)

options(width = 250, dplyr.width = 120)

knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      # record the current time before each chunk
      now <<- Sys.time()
    } else {
      # calculate the time difference after a chunk
      res <- difftime(Sys.time(), now, units = "secs")
      # return a character string to show the time
      paste("Time for the chunk", options$label, "to run:", round(res,
        2), "seconds")
    }
  }
}))


```

```{r }

adop_crit_i1 <- F
ba_crit_i2 <- T

# order of parameters to evaluate is important
```

```{r eval=adop_crit_i1,  eval=ba_crit_i2}

print("hello")
```

# Hierarchies tester

```{r }


# Assuming df is your data frame
df <- data.frame(
  child = c("Parent1", "Child1", "Child2", "Child3", "Child4", "Child5"),
  parent = c("root2", "Parent1", "Parent1", "Child1", "Child1", "Child1"),
  child_age = c(50, 30, 28, 12, 9, 5)
)

# Convert to tree
tree <- FromDataFrameNetwork(df)

# Display the tree
print(tree)

hierarchies <- ToDataFrameTree(tree, 
                level1 = function(x) x$path[2],
                level2 = function(x) x$path[3],
                level3 = function(x) x$path[4],
                level4 = function(x) x$path[5],
                level_number = function(x) x$level - 1)[-1,-1]

# Display the df
print(hierarchies)

```

# Tester with irm data

```{r }

# get the priorities filename using the innovation parameter
priorities_filename <-
  as.character(paste("tab_data/input/priorities_", params$INN1, ".csv", sep = ""))

df_priorities <- read.csv(here(priorities_filename), na.strings = c("NA"))

df_priorities %>% kable(digits = 3) %>% kable_styling("striped", full_width = T) %>%
  row_spec(0, angle = -45) %>%  scroll_box(height = "500px")

df_priorities_short <- df_priorities %>% select(rulebase_stack, rulebase_number)

df_priorities_short[is.na(df_priorities_short)] <- "root2"

# Convert to tree
tree <- FromDataFrameNetwork(df_priorities_short)

# Display the tree
print(tree)

hierarchies <- ToDataFrameTree(tree, 
                level1 = function(x) x$path[2],
                level2 = function(x) x$path[3],
                level3 = function(x) x$path[4],
                level4 = function(x) x$path[5],
                level5 = function(x) x$path[6],
                level6 = function(x) x$path[7],
                level_number = function(x) x$level - 1)[-1,-1]

# Display the df
hierarchies %>% kable(digits = 3) %>% kable_styling("striped", full_width = T) %>%
  row_spec(0, angle = -45) %>%  scroll_box(height = "500px")

# set the plot settings

SetGraphStyle(
  tree,
  rankdir = "RL",
  overlap = "true",
  fontsize = 200,
  fontname = "Calibri",
  label = "Rule bases for",
  labelloc = "t"
)

SetNodeStyle(
  tree,
  shape = "box", 
  fontsize = 100, 
  fontname = "Helvetica", 
  fontcolor = "black",
  fixedsize = "false",
  color = "DarkOliveGreen4", 
  fillcolor = "OliveDrab2", 
  style = "filled,rounded",
  tooltip = GetDefaultTooltip
)

SetEdgeStyle(tree,
             arrowhead = "vee",
             color = "blue",
             penwidth = 2, dir= "back")

plot(tree)

Do(tree$leaves, function(node)
  SetNodeStyle(
    node,
    shape = "oval",
    fixedsize = "false",
    width = 0.9,
    color = "red",
    fillcolor = "IndianRed3",
    fontsize = 75,
    fontname = "Helvetica",
    fontcolor = "white",
    style = "filled"
  ))
plot(tree)

```

## Use the criterion names

```{r }

priorities_new_columns_filename <-
  as.character(paste(
    "tab_data/input/priorities_new_columns_",
    params$INN1,
    ".csv",
    sep = ""
  ))

df_priorities_new_columns <-
  read.csv(here(priorities_new_columns_filename), na.strings = c("NA"))

df_priorities_new_columns_short <-
  df_priorities_new_columns %>% select(stack, criterion, new_weight, weight, threshold, threshold2,	width,	width2)


df_priorities_new_columns_short$stack[is.na(df_priorities_new_columns_short$stack)] <-
  "root2"

# Convert to tree
tree_new <- FromDataFrameNetwork(df_priorities_new_columns_short, c("new_weight", "weight", "threshold",	"threshold2",	"width",	"width2"
))

# Display the tree
print(tree_new, "new_weight", "weight", "threshold",	"threshold2",	"width",	"width2")
```

## Get the tree hierarchy

```{r }

hierarchies_new <- ToDataFrameTree(
  tree_new,
  level1 = function(x)
    x$path[2],
  level2 = function(x)
    x$path[3],
  level3 = function(x)
    x$path[4],
  level4 = function(x)
    x$path[5],
  level5 = function(x)
    x$path[6],
  level6 = function(x)
    x$path[7],
  level_number = function(x)
    x$level - 1
)[-1, -1]

# Display the df
hierarchies_new %>% kable(digits = 3, caption = "Hierarchies") %>% kable_styling("striped", full_width = T) %>%  row_spec(0, angle = -45) %>%  scroll_box(height = "500px")

```

## Get the tree leaves

```{r }
n_leaves <- tree_new$leafCount
df_leaves <- ToDataFrameTypeCol(tree_new)

df_leaves_criterion <- as.data.frame( df_leaves[cbind(seq(nrow(df_leaves)), max.col(!is.na(df_leaves), ties.method = 'last'))])
names(df_leaves_criterion) <- c("criterion")
  
df_leaves %>% kable(digits = 3, caption = "Leaves") %>% kable_styling("striped", full_width = T) %>%  scroll_box(height = "500px")

```

## Plot the tree graph

```{r }

SetGraphStyle(
  tree_new,
  rankdir = "RL",
  overlap = "true",
  fontsize = 400,
  fontname = "Calibri",
  label = paste("Rule bases for",params$INN1),
  labelloc = "t"
)

SetNodeStyle(
  tree_new,
  shape = "box",
  fontsize = 200,
  fontname = "Helvetica",
  fontcolor = "black",
  fixedsize = "false",
  color = "DarkOliveGreen4",
  fillcolor = "OliveDrab2",
  style = "filled,rounded",
  penwidth = 10,
  tooltip = GetDefaultTooltip
)

SetEdgeStyle(
  tree_new,
  arrowhead = "none",
  color = "blue",
  penwidth = function(node) (node$weight * 50),
  dir = "back",
  label = function(node) paste("weight = :",node$weight),
  fontsize = 150,
  fontcolor = "blue"
)

plot(tree_new)

SetNodeStyle(
  tree_new$`Likelihood for Adoption`$`Biophysical Aptitude`,
  fillcolor = "LightBlue",
  color = "black",
  penwidth = 10
)

Do(tree_new$leaves, function(node)
  SetNodeStyle(
    node,
    shape = "oval",
    fixedsize = "false",
    width = 0.9,
    color = "red",
    fillcolor = "IndianRed3",
    fontsize = 200,
    fontname = "Helvetica",
    fontcolor = "white",
    style = "filled"
  ))

plot(tree_new)

```

# Populate the IRM database

```{r }

df_irm <-
  data.frame(
    "x" = c(1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5),
    "y" = c(1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5),
    "ba_2a" = sample(0:1, 25, replace = TRUE),
    "ba_4a" = sample(1:200, 25, replace = TRUE),
    "ba_4b" = sample(1:100, 25, replace = TRUE),
    "ba_4c" = sample(1:100, 25, replace = TRUE),
    "ba_4d" = sample(1:100, 25, replace = TRUE),
    "ba_4e" = sample(-1:30, 25, replace = TRUE),
    "ba_4f" = sample(-1:30, 25, replace = TRUE),
    "ba_4g" = sample(-1:30, 25, replace = TRUE),
    "ba_4h" = sample(1:200, 25, replace = TRUE),
    "ba_3c" = sample(0:1, 25, replace = TRUE),
    "ba_3d" = sample(1:100, 25, replace = TRUE),
    "ba_3e" = sample(1:100, 25, replace = TRUE),
    "ba_3f" = sample(1:100, 25, replace = TRUE),
    "ba_3g" = sample(1:10, 25, replace = TRUE),
    "ba_3h" = sample(1:100, 25, replace = TRUE),
    "ba_3i" = sample(1:8, 25, replace = TRUE),
    "ba_3j" = sample(0:1, 25, replace = TRUE),
    "ba_3k" = sample(1:10, 25, replace = TRUE),
    "ba_3l" = sample(1:5000, 25, replace = TRUE),
    "ba_3m" = sample(1:100, 25, replace = TRUE),
    "ba_3n" = sample(1:10, 25, replace = TRUE),
    "se_5a" = sample(1:10, 25, replace = TRUE),
    "se_5b" = sample(1:10, 25, replace = TRUE),
    "se_5c" = sample(1:10, 25, replace = TRUE),
    "se_5d" = sample(1:10, 25, replace = TRUE),
    "se_5e" = sample(1:10, 25, replace = TRUE),
    "se_5f" = sample(1:10, 25, replace = TRUE),
    "se_4d" = sample(1:10, 25, replace = TRUE),
    "se_4e" = sample(1:10, 25, replace = TRUE),
    "se_3c" = sample(1:10, 25, replace = TRUE),
    "se_3d" = sample(1:10, 25, replace = TRUE),
    "se_3e" = sample(1:10, 25, replace = TRUE)
  )

vect <- vect(df_irm, geom=c("x", "y"), crs="+proj=longlat +datum=WGS84")
rast_mask_proj <- rast(vect, nrow=5, ncol=5)
values(rast_mask_proj) <- 1
plot(rast_mask_proj)

```


# Evaluate base data level rules

## Create the base data level data frame

```{r }

# join to original table using the criterion name

df_leaves_data <-
  left_join(df_leaves_criterion,
            df_priorities_new_columns,
            by = c("criterion"))
```

## For loop to create fuzzy partitions and evaluate

```{r for_loop, eval = F, time_it = TRUE}

# create fuzzy partitions

for (i in 1:nrow(df_leaves_data)) {
  if (!is.na(df_leaves_data$prop_level_3[i])) {
    # for those criteria with three proposition values
    
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_leaves_data$prop_level_1[i]),
        as.character(df_leaves_data$prop_level_2[i]),
        as.character(df_leaves_data$prop_level_3[i])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        df_leaves_data$conclusion_1[i],
        df_leaves_data$conclusion_2[i],
        df_leaves_data$conclusion_3[i]
      )
    
    # get the first letters of the 3 conclusion levels
    conc_suffixes <-
      lapply(conc_levels, function(x)
        substr(x, 1, 1))
    
    # get  the 2 crossover points
    cross_points <-
      c(df_leaves_data$threshold[i],
        df_leaves_data$threshold2[i])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_leaves_data$width[i],
        df_leaves_data$width2[i])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_leaves_data$threshold[i] - df_leaves_data$width[i]),
        (df_leaves_data$threshold2[i] + df_leaves_data$width2[i])
      )
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    
    prop_levels <-
      c(
        df_leaves_data$prop_level_1[i],
        df_leaves_data$prop_level_2[i]
      )
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(
        df_leaves_data$conclusion_1[i],
        df_leaves_data$conclusion_2[i]
      )
    
   # get the first letters of the 2 conclusion levels    
    conc_suffixes <-
      lapply(conc_levels, function(x)
        substr(x, 1, 1))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_leaves_data$threshold[i])
    
    # get  the 1 transition width
    trans_width <-
      c(df_leaves_data$width[i])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_leaves_data$threshold[i] - df_leaves_data$width[i]),
        (df_leaves_data$threshold[i] + df_leaves_data$width[i])
      )
  }
  
  # construct the fuzzy partition
  
  assign(
    paste0("fp_", as.character(df_leaves_data$rulebase_number[i])),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  # construct the fuzzy partition plot
  
  plot_fp <-
    plot(
      get(paste0(
        "fp_", as.character(df_leaves_data$rulebase_number[i])
      )),
      xlim = plot_xlim,
      xlab = as.character(df_leaves_data$criterion[i]),
      title = "fuzzy partition"
    )
  
  # print the fuzzy partition plot
  
  print(plot_fp)
  
  # construct the rule bases
  # set the proposition name
  
  Prop_name <-
    paste0(as.character(df_leaves_data$rulebase_number[i]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_leaves_data$rulebase_number[i]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                as.character(df_leaves_data$rulebase_number[i])),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0(
    "rb_",
    as.character(df_leaves_data$rulebase_number[i])
  )))
  
  # apply the fuzzy partitions to the data
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    as.character(df_leaves_data$rulebase_number[i]),
    ", newdata = df_irm,",
    as.character(df_leaves_data$rulebase_number[i]),
    "=",
    "fp_",
    as.character(df_leaves_data$rulebase_number[i]),
    ")"
  )
  
  
  assign(paste0("fpm_",
                as.character(df_leaves_data$rulebase_number[i])), eval(parse(text = x)))
  
  
  # need to use the conclusion values
  
  if ("optimal" %in% conc_levels) { # the conclusions are optimal and suboptimal
  
  
  # get the membership values from the fpm
    
    o_col <- getMembership(get(paste0("fpm_",
                                      df_leaves_data$rulebase_number[i]))$optimal)
    s_col <- getMembership(get(paste0("fpm_",
                                      df_leaves_data$rulebase_number[i]))$suboptimal)
    df_irm <-
      mutate(df_irm,!!as.character(paste0(df_leaves_data$rulebase_number[i], "_o")) := o_col, .keep = c("all"))
    
    df_irm <-
      mutate(df_irm,!!as.character(paste0(df_leaves_data$rulebase_number[i], "_s")) := s_col, .keep = c("all"))
    
    n = 2
    fpm_conc_var <-
      c(as.character(paste0(df_leaves_data$rulebase_number[i], "_o")), as.character(paste0(df_leaves_data$rulebase_number[i], "_s")), "x" , "y")
    fpm_conc_name <-
      c(as.character(paste0(
        df_leaves_data$rulebase_number[i], " optimal"
      )), as.character(paste0(
        df_leaves_data$rulebase_number[i], " suboptimal"
      )))
    fpm_plot_title <-
      paste0(df_leaves_data$criterion[i], "optimality membership")
    
  } else { # the conclusions are good and poor
    
    # get the membership values from the fpm
    
    g_col <- getMembership(get(paste0("fpm_",
                                      df_leaves_data$rulebase_number[i]))$good)
    p_col <- getMembership(get(paste0("fpm_",
                                      df_leaves_data$rulebase_number[i]))$poor)
    df_irm <-
      mutate(df_irm,!!as.character(paste0(df_leaves_data$rulebase_number[i], "_g")) := g_col, .keep = c("all"))
    
    df_irm <-
      mutate(df_irm,!!as.character(paste0(df_leaves_data$rulebase_number[i], "_p")) := p_col, .keep = c("all"))
    
    n = 2
    fpm_conc_var <-
      c(as.character(paste0(df_leaves_data$rulebase_number[i], "_g")), as.character(paste0(df_leaves_data$rulebase_number[i], "_p")), "x" , "y")
    fpm_conc_name <-
      c(as.character(paste0(
        df_leaves_data$rulebase_number[i], " good"
      )), as.character(paste0(
        df_leaves_data$rulebase_number[i], " poor"
      )))
    fpm_plot_title <-
      paste0(df_leaves_data$criterion[i], "good/poor membership")
  }
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
  print(plot_fpm)
  
}

```

## Vectors and apply functions to create fuzzy partitions and evaluate
### Method 1

```{r eval = F}

apply(df_leaves_data, 1, function(row) {
  if (!is.na(row["prop_level_3"])) {
    # for those criteria with three proposition values
    prop_levels <-
      as.character(row[c("prop_level_1", "prop_level_2", "prop_level_3")])
    print(prop_levels)
    conc_levels <-
      row[c("conclusion_1", "conclusion_2", "conclusion_3")]
        print(conc_levels)
    conc_suffixes <-
      lapply(conc_levels, function(x)
        substr(x, 1, 1))
            print(conc_suffixes)
    cross_points <-
      as.numeric(c(row["threshold"], row["threshold2"]))
                print(cross_points)
    trans_width <- as.numeric(c(row["width"], row["width2"]))
                    print(trans_width)
    plot_xlim <-
      as.numeric(c((as.numeric(row["threshold"]) - as.numeric(row["width"])), (as.numeric(row["threshold2"]) + as.numeric(row["width2"]))))
  } else {
    # for those criteria with two proposition values
    prop_levels <-
      as.character(row[c("prop_level_1", "prop_level_2")])
        print(prop_levels)
    conc_levels <- row[c("conclusion_1", "conclusion_2")]
            print(conc_levels)
    conc_suffixes <-
      lapply(conc_levels, function(x)
        substr(x, 1, 1))
                print(conc_suffixes)
    cross_points <- as.numeric(row["threshold"])
                    print(cross_points)
    trans_width <- as.numeric(row["width"])
                        print(trans_width)
    plot_xlim <-
      as.numeric(c((as.numeric(row["threshold"]) - as.numeric(row["width"])), (as.numeric(row["threshold"]) + as.numeric(row["width"]))))
  }
  
  # construct the fuzzy partition
  assign(
    paste0("fp_", as.character(row["rulebase_number"])),
    LinearFuzzyPartition(
      level = prop_levels,
      crossoverPoint = cross_points,
      transitionWidth = trans_width
    )
  )
  
  # construct the fuzzy partition plot
  plot_fp <- plot(
    get(paste0("fp_", as.character(row["rulebase_number"]))),
    xlim = plot_xlim,
    xlab = as.character(row["criterion"]),
    title = "fuzzy partition"
  )
  
  # print the fuzzy partition plot
  print(plot_fp)
})


```

### Method 2


``` {r eval = F}
# # the logic for determining prop_levels and conc_levels has been moved into the process_row function. The function returns a list containing these two vectors, and then you can use them as needed in the main loop
# 
# process_row <- function(row) {
#   if (!is.na(row["prop_level_3"])) {
#     # for those criteria with three proposition values
#     prop_levels <-
#       as.character(row[c("prop_level_1", "prop_level_2", "prop_level_3")])
#     conc_levels <-
#       row[c("conclusion_1", "conclusion_2", "conclusion_3")]
#   } else {
#     # for those criteria with two proposition values
#     prop_levels <-
#       as.character(row[c("prop_level_1", "prop_level_2")])
#     conc_levels <- row[c("conclusion_1", "conclusion_2")]
#   }
#   
#   return(list(prop_levels = prop_levels, conc_levels = conc_levels))
# }
# 
# # main loop
# 
# apply(df_leaves_data, 1, function(row) {
#   processed_data <- process_row(row)
#   
#   prop_levels <- processed_data$prop_levels
#   conc_levels <- processed_data$conc_levels
#   conc_suffixes <- lapply(conc_levels, function(x)
#     substr(x, 1, 1))
#   
#   cross_points <-
#     as.numeric(c(row["threshold"], ifelse(!is.na(row["threshold2"]), row["threshold2"], NA)))
#   
#   cross_points <- cross_points[!is.na(cross_points)]
#   
#   trans_width <-
#     as.numeric(c(as.numeric(row["width"]), ifelse(
#       !is.na(as.numeric(row["width2"])), as.numeric(row["width2"]), NA
#     )))
#   
#   trans_width <- trans_width[!is.na(trans_width)]
#   
#   
#   plot_xlim <-
#     as.numeric(c((as.numeric(row["threshold"]) - as.numeric(row["width"])), (as.numeric(row["threshold"]) + as.numeric(row["width"]))))
#   
#   # construct the fuzzy partition
#   assign(
#     paste0("fp_", as.character(row["rulebase_number"])),
#     LinearFuzzyPartition(
#       level = prop_levels,
#       crossoverPoint = cross_points,
#       transitionWidth = trans_width
#     ),
#     .GlobalEnv
#   )
#   
#   # construct the fuzzy partition plot
#   plot_fp <- plot(
#     get(paste0("fp_", as.character(row["rulebase_number"]))),
#     xlim = plot_xlim,
#     xlab = as.character(row["criterion"]),
#     title = "fuzzy partition"
#   )
#   
#   # print the fuzzy partition plot
#   print(plot_fp)
#   
#   # construct the rule bases
#   # set the proposition name
#   
#   Prop_name <-
#     paste0(as.character(row["rulebase_number"]))
#   
#   # set the conclusion name
#   Conc_name <-
#     paste0(as.character(row["rulebase_number"]),
#            "_o")
#   
#   # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
#   
#   # set the proposition values
#   df_prop <- tibble(!!Prop_name := c(prop_levels))
#   # set the conclusion values
#   df_conc <- tibble(!!Conc_name := c(conc_levels))
#   
#   # new proposition and conclusion class objects are made here
#   new_prop <- new("Proposition", table = df_prop)
#   new_conc <- new("Conclusion", table = df_conc)
#   
#   assign(paste0("rb_",
#                 as.character(row["rulebase_number"])),
#          RuleBase(new_prop, new_conc),
#          .GlobalEnv)
#   
#   print(get(paste0("rb_",
#                    as.character(row["rulebase_number"]))))
#   
#   # apply the fuzzy partitions to the data
#   
#   # first construct the predict function with all arguments as text
#   
#   x <- paste0(
#     "predict(rb_",
#     as.character(row["rulebase_number"]),
#     ", newdata = df_irm,",
#     as.character(row["rulebase_number"]),
#     "=",
#     "fp_",
#     as.character(row["rulebase_number"]),
#     ")"
#   )
#   
#   assign(paste0("fpm_",
#                 as.character(row["rulebase_number"])), eval(parse(text = x)), .GlobalEnv)
# })
# 
# # second function to produce a list of values which is added to df_irm
# 
#   result_vectorized <- sapply(conc_levels, function(value, row) {
#     fpm_name <- paste0("fpm_", row["rulebase_number"], "$", value)
#     
#     print(fpm_name)
#     
#     print(paste0("suffix = _", substr(value, 1, 1)))
#     
#     # df_irm <<- 
#     #   mutate(df_irm, hello = 1, .keep = c("all"))
#     
#     # df_irm <<-
#     #   mutate(df_irm, hello = "hello", .keep = c("all"))
#     
#      # df_irm <<-
#      #   mutate(df_irm,
#      #          !!as.character(paste0(row["rulebase_number"], "_", substr(value, 1, 1))) := 1,
#      #          .keep = c("all"))
#       
#      # df_irm <<-
#      #   mutate(df_irm,!!as.character(paste0(row["rulebase_number"], "_", substr(value, 1, 1))) := (paste0(fpm_name)), .keep = c("all"))
#     
#      # df_irm <<-
#      #   mutate(df_irm,!!as.character(paste0(row["rulebase_number"], "_", substr(value, 1, 1))) := getMembership(get(paste0("fpm_", row["rulebase_number"],"$", value))), .keep = c("all"))
#     
#     })
#   
#   # 
#   # # need to use the conclusion values
#   # 
#   # if ("optimal" %in% conc_levels) { # the conclusions are optimal and suboptimal
#   # 
#   # 
#   # # get the membership values from the fpm
#   #   
#   #   o_col <- getMembership(get(paste0("fpm_",
#   #                                     row["rulebase_number"]))$optimal)
#   #   s_col <- getMembership(get(paste0("fpm_",
#   #                                     row["rulebase_number"]))$suboptimal)
#   #   df_irm <-
#   #     mutate(df_irm,!!as.character(paste0(row["rulebase_number"], "_o")) := o_col, .keep = c("all"))
#   #   
#   #   df_irm <-
#   #     mutate(df_irm,!!as.character(paste0(row["rulebase_number"], "_s")) := s_col, .keep = c("all"))
#   #   
#   #   n = 2
#   #   fpm_conc_var <-
#   #     c(as.character(paste0(row["rulebase_number"], "_o")), as.character(paste0(row["rulebase_number"], "_s")), "x" , "y")
#   #   fpm_conc_name <-
#   #     c(as.character(paste0(
#   #       row["rulebase_number"], " optimal"
#   #     )), as.character(paste0(
#   #       row["rulebase_number"], " suboptimal"
#   #     )))
#   #   fpm_plot_title <-
#   #     paste0(row["rulebase_number"], "optimality membership")
#   #   
#   # } else { # the conclusions are good and poor
#   #   
#   #   # get the membership values from the fpm
#   #   
#   #   g_col <- getMembership(get(paste0("fpm_",
#   #                                     row["rulebase_number"]))$good)
#   #   p_col <- getMembership(get(paste0("fpm_",
#   #                                     row["rulebase_number"]))$poor)
#   #   df_irm <-
#   #     mutate(df_irm,!!as.character(paste0(row["rulebase_number"], "_g")) := g_col, .keep = c("all"))
#   #   
#   #   df_irm <-
#   #     mutate(df_irm,!!as.character(paste0(row["rulebase_number"], "_p")) := p_col, .keep = c("all"))
#   #   
#   #   n = 2
#   #   fpm_conc_var <-
#   #     c(as.character(paste0(row["rulebase_number"], "_g")), as.character(paste0(row["rulebase_number"], "_p")), "x" , "y")
#   #   fpm_conc_name <-
#   #     c(as.character(paste0(
#   #       row["rulebase_number"], " good"
#   #     )), as.character(paste0(
#   #       row["rulebase_number"], " poor"
#   #     )))
#   #   fpm_plot_title <-
#   #     paste0(row["rulebase_number"], "good/poor membership")
#   # }
#   # 
#   # plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
#   # print(plot_fpm)
  


```

### Method 2a
#### Original from ChatGPT v3

```{r  eval = F }


# # Main function
# mainFunction <- function(data) {
#   result_list <- list()
# 
#   # Calculate the value list within the main function
#   valueList <- calculateValueList(data)
# 
#   # Your main function logic using apply
#   result <- apply(data, 1, function(row) {
#     # Process each row using second function with sapply
#     secondResult <- sapply(valueList, secondFunction, mainData = row)
#     
#     # Your main processing logic for each row
#     mainProcessingResult <- sum(row)  # Replace this with your actual logic
#     
#     # Store results in the list
#     result_list[[length(result_list) + 1]] <- list(
#       MainResult = mainProcessingResult,
#       SecondResult = secondResult
#     )
#   })
# 
#   # Return the list of results
#   return(result_list)
# }
# 
# # Second function
# secondFunction <- function(value, mainData) {
#   # Your processing logic here using value and mainData
#   
#   # Return the value to be stored
#   return(value)
# }
# 
# # Function to calculate the value list based on data
# calculateValueList <- function(data) {
#   # Your logic to calculate the value list based on data
#   # For example, you can extract unique values from a specific column
#   uniqueValues <- unique(data$SomeColumn)
#   return(uniqueValues)
# }
# 
# # Example usage
# data <- data.frame(
#   Col1 = c(1, 2, 3),
#   Col2 = c(4, 5, 6),
#   SomeColumn = c("A", "B", "A")
# )
# 
# # Call the main function
# resultList <- mainFunction(data)
# 
# # Access results from the list
# for (i in seq_along(resultList)) {
#   cat("Main Result for Row", i, ":", resultList[[i]]$MainResult, "\n")
#   cat("Second Result for Row", i, ":", resultList[[i]]$SecondResult, "\n")
# }

```

#### Combined Chat GPTv3 and my code

```{r vectorised, time_it = TRUE, results = "asis", eval = F}

# Function to populate a list of proposition and conclusion levels
prop_conc <- function(df_leaves_row) {
  if (!is.na(df_leaves_row["prop_level_3"])) {
    # for those criteria with three proposition values
    prop_levels <-
      as.character(df_leaves_row[c("prop_level_1", "prop_level_2", "prop_level_3")])
    conc_levels <-
      df_leaves_row[c("conclusion_1", "conclusion_2", "conclusion_3")]
  } else {
    # for those criteria with two proposition values
    prop_levels <-
      as.character(df_leaves_row[c("prop_level_1", "prop_level_2")])
    conc_levels <- df_leaves_row[c("conclusion_1", "conclusion_2")]
  }
  
  return(list(prop_levels = prop_levels, conc_levels = conc_levels))
}

result_list <- list()

# Main function
apply(df_leaves_data, 1, function(df_leaves_row) {

  # Calculate the value list within the main function
  prop_conc_list <- prop_conc(df_leaves_row)
  prop_levels <- prop_conc_list$prop_levels
  conc_levels <- prop_conc_list$conc_levels
  conc_suffixes <- lapply(conc_levels, function(x)
    substr(x, 1, 1))
  
  cross_points <-
    as.numeric(c(df_leaves_row["threshold"], ifelse(!is.na(df_leaves_row["threshold2"]), df_leaves_row["threshold2"], NA)))
  
  cross_points <- cross_points[!is.na(cross_points)]
  
  trans_width <-
    as.numeric(c(as.numeric(df_leaves_row["width"]), ifelse(
      !is.na(as.numeric(df_leaves_row["width2"])), as.numeric(df_leaves_row["width2"]), NA
    )))
  
  trans_width <- trans_width[!is.na(trans_width)]
  
  
  plot_xlim <-
    as.numeric(c((as.numeric(df_leaves_row["threshold"]) - as.numeric(df_leaves_row["width"])), (as.numeric(df_leaves_row["threshold"]) + as.numeric(df_leaves_row["width"]))))
  
  # construct the fuzzy partition
  assign(
    paste0("fp_", as.character(df_leaves_row["rulebase_number"])),
    LinearFuzzyPartition(
      level = prop_levels,
      crossoverPoint = cross_points,
      transitionWidth = trans_width
    ),
    .GlobalEnv
  )
  
  # construct the fuzzy partition plot
  plot_fp <- plot(
    get(paste0("fp_", as.character(df_leaves_row["rulebase_number"]))),
    xlim = plot_xlim,
    xlab = as.character(df_leaves_row["criterion"]),
    title = "fuzzy partition"
  )
  
  # print the fuzzy partition plot
  print(plot_fp)
  
  # construct the rule bases
  # set the proposition name
  
  Prop_name <-
    paste0(as.character(df_leaves_row["rulebase_number"]))
  
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_leaves_row["rulebase_number"]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                as.character(df_leaves_row["rulebase_number"])),
         RuleBase(new_prop, new_conc),
         .GlobalEnv)
  
  print(get(paste0("rb_",
                   as.character(df_leaves_row["rulebase_number"]))))
  
  # apply the fuzzy partitions to the data
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    as.character(df_leaves_row["rulebase_number"]),
    ", newdata = df_irm,",
    as.character(df_leaves_row["rulebase_number"]),
    "=",
    "fp_",
    as.character(df_leaves_row["rulebase_number"]),
    ")"
  )
  
  assign(paste0("fpm_",
                as.character(df_leaves_row["rulebase_number"])), eval(parse(text = x)), .GlobalEnv)
  #print(conc_levels[1])
  
  # Define a function to print each element
  #print_element <- function(x) {
  #  print(x)
  #}
  
  
  # Function to get the membership values of the fuzzy partition matrix for each conclusion value
  # this only works when nested in main function
  
  fpm_values <- function(conc_value) {
    fpm_name <-
      paste0("fpm_", df_leaves_row["rulebase_number"], "$", conc_value)
    #print(fpm_name)
    conc_col_name <-
      paste0(df_leaves_row["rulebase_number"], "_", substr(conc_value, 1, 1))
    #print(paste0("suffix = _", substr(conc_value, 1, 1)))
    x <- paste0("getMembership(", fpm_name, ")")
    #print(x)
    #print(eval(parse(text = x)))
    
    # this works
     result_list <<-
       c(result_list, setNames(list(eval(parse(
         text = x
       ))), conc_col_name))
    
    return(result_list)
  }
  
  # apply the fpm_values to the list of conclusion levels and generate a list of values (result_list)
  lapply(unique(conc_levels), invisible(fpm_values))
  
  #return(result_list)
  
})

# Convert the result list to a data frame
result_df <- data.frame(matrix(unlist(result_list), ncol = length(result_list), byrow = FALSE))
colnames(result_df) <- names(result_list)

# Bind the result data frame to the original data frame
df_irm <- cbind(df_irm, result_df)

# Print the updated data frame
#print(df_irm)



# Plot function for evaluated fuzzy partition using main data frame - rowwise across criteria
apply(df_leaves_data, 1, function(df_leaves_row) {
  
  prop_conc_list <- prop_conc(df_leaves_row)
  conc_levels <- prop_conc_list$conc_levels
  conc_suffixes <- lapply(conc_levels, function(x)
    substr(x, 1, 1))
  
  # Function to print each conclusion value - per unique object in list of conclusion values
  # this only works when nested in print function
  
  plot_fpm <- function(conc_value) {
    conc_col_name <-
      paste0(df_leaves_row["rulebase_number"], "_", substr(conc_value, 1, 1))
    fpm_conc_var <- c(conc_col_name, "x" , "y")
    fpm_conc_name <- conc_value

    # spatialise the results
    sf_fpm <- df_irm %>%
      dplyr::select(unlist(as.character(noquote(fpm_conc_var)))) %>%
      na.omit %>%
      st_as_sf(coords = c("x", "y"))
    
    # rasterize
    rast_fpm <-  rasterize(sf_fpm, rast_mask_proj, fpm_conc_var[[1]]) 
    
    # give the rast sensible names
    names(rast_fpm) <- fpm_conc_name
    
    # plot rast using title
    #plot_conc <- 
    rast_fpm %>% plot(breaks = c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1),
                axes = F, main = paste0(conc_col_name, "  membership"))
    #print(plot_conc)
    
    }
  
  # apply the plot_fpm to the list of conclusion levels and generate plots
  lapply(unique(conc_levels), plot_fpm)

  #return(plot_fpm)

})

```

#### Final code

```{r more tests, time_it = TRUE, results = "asis"}


# Function to populate a list of proposition and conclusion levels
prop_conc <- function(df_leaves_row) {
  if (!is.na(df_leaves_row["prop_level_3"])) {
    # for those criteria with three proposition values
    prop_levels <-
      as.character(df_leaves_row[c("prop_level_1", "prop_level_2", "prop_level_3")])
    conc_levels <-
      df_leaves_row[c("conclusion_1", "conclusion_2", "conclusion_3")]
  } else {
    # for those criteria with two proposition values
    prop_levels <-
      as.character(df_leaves_row[c("prop_level_1", "prop_level_2")])
    conc_levels <- df_leaves_row[c("conclusion_1", "conclusion_2")]
  }
  
  return(list(prop_levels = prop_levels, conc_levels = conc_levels))
}

result_list <- list()

# Main function
apply(df_leaves_data, 1, function(df_leaves_row) {

  # Calculate the value list within the main function
  prop_conc_list <- prop_conc(df_leaves_row)
  prop_levels <- prop_conc_list$prop_levels
  conc_levels <- prop_conc_list$conc_levels
  conc_suffixes <- lapply(conc_levels, function(x)
    substr(x, 1, 1))
  
  cross_points <-
    as.numeric(c(df_leaves_row["threshold"], ifelse(!is.na(df_leaves_row["threshold2"]), df_leaves_row["threshold2"], NA)))
  
  cross_points <- cross_points[!is.na(cross_points)]
  
  trans_width <-
    as.numeric(c(as.numeric(df_leaves_row["width"]), ifelse(
      !is.na(as.numeric(df_leaves_row["width2"])), as.numeric(df_leaves_row["width2"]), NA
    )))
  
  trans_width <- trans_width[!is.na(trans_width)]
  
  
  plot_xlim <-
    as.numeric(c((as.numeric(df_leaves_row["threshold"]) - as.numeric(df_leaves_row["width"])), (as.numeric(df_leaves_row["threshold"]) + as.numeric(df_leaves_row["width"]))))
  
  # construct the fuzzy partition
  assign(
    paste0("fp_", as.character(df_leaves_row["rulebase_number"])),
    LinearFuzzyPartition(
      level = prop_levels,
      crossoverPoint = cross_points,
      transitionWidth = trans_width
    ),
    .GlobalEnv
  )
  
  # construct the fuzzy partition plot
  plot_fp <- plot(
    get(paste0("fp_", as.character(df_leaves_row["rulebase_number"]))),
    xlim = plot_xlim,
    xlab = as.character(df_leaves_row["criterion"]),
    title = "fuzzy partition"
  )
  
  # print the fuzzy partition plot
  print(plot_fp)
  
  # construct the rule bases
  # set the proposition name
  
  Prop_name <-
    paste0(as.character(df_leaves_row["rulebase_number"]))
  
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_leaves_row["rulebase_number"]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                as.character(df_leaves_row["rulebase_number"])),
         RuleBase(new_prop, new_conc),
         .GlobalEnv)
  
  print(get(paste0("rb_",
                   as.character(df_leaves_row["rulebase_number"]))))
  
  # apply the fuzzy partitions to the data
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    as.character(df_leaves_row["rulebase_number"]),
    ", newdata = df_irm,",
    as.character(df_leaves_row["rulebase_number"]),
    "=",
    "fp_",
    as.character(df_leaves_row["rulebase_number"]),
    ")"
  )
  
  assign(paste0("fpm_",
                as.character(df_leaves_row["rulebase_number"])), eval(parse(text = x)), .GlobalEnv)
  #print(conc_levels[1])
  
  # Define a function to print each element
  #print_element <- function(x) {
  #  print(x)
  #}
  
  
  # Function to get the membership values of the fuzzy partition matrix for each conclusion value
  # this only works when nested in main function
  
  fpm_values <- function(conc_value) {
    
  fpm_name <-
     paste0("fpm_", df_leaves_row["rulebase_number"], "$", conc_value)
    #print(fpm_name)
    conc_col_name <-
      paste0(df_leaves_row["rulebase_number"], "_", substr(conc_value, 1, 1))
    #print(paste0("suffix = _", substr(conc_value, 1, 1)))
    x <- paste0("getMembership(", fpm_name, ")")
    #print(x)
    #print(eval(parse(text = x)))
    
    # this works
     #result_list <<-
    #   c(result_list, setNames(list(eval(parse(
    #     text = x
    #   ))), conc_col_name))
     
     # construct the fuzzy partition
  assign(paste("result_list"),
     c(result_list, setNames(list(eval(parse(
         text = x
       ))), conc_col_name)),
    .GlobalEnv
  )
    cat(conc_col_name)
    #return(result_list)
  }
  
  # apply the fpm_values to the list of conclusion levels and generate a list of values (result_list)
  lapply(unique(conc_levels), fpm_values)
  #print("done 2")
  #return(result_list)
  
})


# Convert the result list to a data frame
result_df <- data.frame(matrix(unlist(result_list), ncol = length(result_list), byrow = FALSE))
colnames(result_df) <- names(result_list)

# Bind the result data frame to the original data frame
df_irm <- cbind(df_irm, result_df)

# Print the updated data frame
#print(df_irm)



# Plot function for evaluated fuzzy partition using main data frame - rowwise across criteria
apply(df_leaves_data, 1, function(df_leaves_row) {
  
  prop_conc_list <- prop_conc(df_leaves_row)
  conc_levels <- prop_conc_list$conc_levels
  conc_suffixes <- lapply(conc_levels, function(x)
    substr(x, 1, 1))
  
  # Function to print each conclusion value - per unique object in list of conclusion values
  # this only works when nested in print function
  
  plot_fpm <- function(conc_value) {
    conc_col_name <-
      paste0(df_leaves_row["rulebase_number"], "_", substr(conc_value, 1, 1))
    fpm_conc_var <- c(conc_col_name, "x" , "y")
    fpm_conc_name <- conc_value

    # spatialise the results
    sf_fpm <- df_irm %>%
      dplyr::select(unlist(as.character(noquote(fpm_conc_var)))) %>%
      na.omit %>%
      st_as_sf(coords = c("x", "y"))
    
    # rasterize
    rast_fpm <-  rasterize(sf_fpm, rast_mask_proj, fpm_conc_var[[1]]) 
    
    # give the rast sensible names
    names(rast_fpm) <- fpm_conc_name
    
    # plot rast using title
    #plot_conc <- 
    rast_fpm %>% plot(breaks = c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1),
                axes = F, main = paste0(conc_col_name, "  membership"))
    cat(conc_col_name)
    
    }
  
  # apply the plot_fpm to the list of conclusion levels and generate plots
  lapply(unique(conc_levels), plot_fpm)
  
  #print("done 4")
  #return(plot_fpm)

})
```

# Higher-level rule base evaluation

Each row in each higher-level df is a rule base stack

For each row in each higher-level df starting with lowest level (e.g. 6)

Join to lower-level criteria to give joined df

1) Get the lower-level rule bases (1 entry per row in joined df)
2) Construct the list of lower-level rule bases (1 entry per row in joined df)
3) Construct the list of lower-level fuzzy partitions
4) Get the conclusion values of the lower-level rule bases (multiple per row in joined df)
5) Use the weights, number of lower-level rule bases and conclusion values of the lower-level rule bases to determine the number of rules (1 per joined df)
6) Use the weights (if any) to define the higher-level rule base conclusions (multiple per joined df)
7) Make a new proposition object (1 per joined df)
8) Make a new conclusion object 1 per joined df)
9) Create a new rule base (1 per joined df)
10) Add to the list of previous rule bases (1 list per joined df)
11) Evaluate the new rule base (and stack) (per joined df)
12) Add results to df_irm (per joined df)
13) Plot results (per joined df)


## Compute the number of rules and conclusions

### Basic script to get the conclusion values from two weights

```{r eval = F}

weights <- c(0.6, 0.4)

# Generate all combinations of addition and subtraction
combinations <- expand.grid(rep(list(c(1, -1)), length(weights)))

# Initialize vector to store results
results <- numeric()

# Loop through each combination and calculate the result
for (i in 1:nrow(combinations)) {
  result <- sum(combinations[i, ] * weights)
  results <- c(results, result)
}

# Display the results
print(results)

# bin the results
results_classes <- cut(results, breaks = c(-Inf, (-1/3), (1/3), Inf), labels = c("poor","moderate","good"))

# get the number of unique classes
results_classes_unique <- unique(results_classes)

# get length
num_conclusions <- length(results_classes_unique)

# Display the results
#print(paste("Number of unique conclusions = ", num_conclusions))
cat("Number of unique conclusions = ", paste(num_conclusions, collapse = ", "), "\n")
#print(paste("Conclusions = ", results_classes_unique))
cat("Conclusions = ", paste(results_classes_unique, collapse = ", "), "\n")

```

### Basic script to get the conclusion values from any number of weights - lapply

```{r eval = F}

weights <- list(c(0.6, 0.4), c(0.7, 0.3), c(0.3, 0.4, 0.3), c(0.8, 0.1, 0.1))


conc_values <- function(weights){
# Generate all combinations of addition and subtraction
combinations <- expand.grid(rep(list(c(1, -1)), length(weights)))

# Initialize vector to store results
results <- numeric()

# Loop through each combination and calculate the result
for (i in 1:nrow(combinations)) {
  result <- sum(combinations[i, ] * weights)
  results <- c(results, result)
}

# Display the results
print(results)

# bin the results
# results_classes <- cut(results, breaks = c(-Inf, (-1/3), (1/3), Inf), labels = c("poor","moderate","good"))
results_classes <- cut(results, breaks = c(-Inf, (-1/3), (1/3), Inf), labels = c("poor","moderate","good"))
                       
# get the number of unique classes
results_classes_unique <- unique(results_classes)

# get length
num_conclusions <- length(results_classes_unique)

# Display the results
#print(paste("Number of unique conclusions = ", num_conclusions))
cat("Number of unique conclusions = ", paste(num_conclusions, collapse = ", "), "\n")
#print(paste("Conclusions = ", results_classes_unique))
cat("Conclusions = ", paste(results_classes_unique, collapse = ", "), "\n")

return(results_classes_unique)

}

lapply(weights, conc_values)

```


### Basic script to get the conclusion values from any number of weights and using conclusion values from a list - lapply


```{r eval = F}

weights <- list(c(0.6, 0.4), c(0.7, 0.3), c(0.3, 0.4, 0.3), c(0.8, 0.1, 0.1))
conc_options <- list(c("poor","moderate","good"), c("poor","moderate","good"), c("poor","moderate","good"), c("low","moderate","high"))


conc_values_m <- function(weights, conc_options) {
  # Generate all combinations of addition and subtraction
  print(weights)
  print(conc_options)
  
  combinations <- expand.grid(rep(list(c(1,-1)), length(weights)))
  
  # Initialize vector to store results
  results <- numeric()
  
  # Loop through each combination and calculate the result
  for (i in 1:nrow(combinations)) {
    result <- sum(combinations[i,] * weights)
    results <- c(results, result)
  }
  
  # Display the results
  print(results)
  
  # bin the results
  # results_classes <- cut(results, breaks = c(-Inf, (-1/3), (1/3), Inf), labels = c("poor","moderate","good"))
  results_classes <-
    cut(results,
        breaks = c(-Inf, (-1 / 3), (1 / 3), Inf),
        labels = conc_options)
  
  cat("Raw conclusions = ",
      paste(results_classes, collapse = ", "),
      "\n")
  
  # get the number of unique classes
  results_classes_unique <- unique(results_classes)
  
  # get length
  num_conclusions <- length(results_classes_unique)
  
  # Display the results
  #print(paste("Number of unique conclusions = ", num_conclusions))
  cat("Number of unique conclusions = ",
      paste(num_conclusions, collapse = ", "),
      "\n")
  #print(paste("Conclusions = ", results_classes_unique))
  cat("Conclusions = ",
      paste(results_classes_unique, collapse = ", "),
      "\n")
  
  return(results_classes_unique)
  
}

mapply(conc_values_m, weights, conc_options)

```

### Basic script to get the number of conclusions and their values from any number of weights and using conclusion values from a list - lapply


```{r eval = F }

weights <- list(c(0.6, 0.4), c(0.7, 0.3), c(0.3, 0.4, 0.3), c(0.8, 0.1, 0.1))
conc_options <- list(c("poor","moderate","good"), c("poor","moderate","good"), c("poor","moderate","good"), c("low","moderate","high"))


conc_values_n <- function(weights, conc_options) {
  # Generate all combinations of addition and subtraction
  print(weights)
  print(conc_options)
  
  combinations <- expand.grid(rep(list(c(1,-1)), length(weights)))
  
  # Initialize vector to store results
  results <- numeric()
  
  # Loop through each combination and calculate the result
  for (i in 1:nrow(combinations)) {
    result <- sum(combinations[i,] * weights)
    results <- c(results, result)
  }
  
  # Display the results
  print(results)
  
  # bin the results
  # results_classes <- cut(results, breaks = c(-Inf, (-1/3), (1/3), Inf), labels = c("poor","moderate","good"))
  results_classes <-
    cut(results,
        breaks = c(-Inf, (-1 / 3), (1 / 3), Inf),
        labels = conc_options)
  
  cat("Raw conclusions = ",
      paste(results_classes, collapse = ", "),
      "\n")
  
  return(results_classes)
  
}

mapply(conc_values_n, weights, conc_options)

```

### Basic script to get the new rule base - SEF

Logic:

1) How many lower rule bases
2) Get conclusions from lower rule bases
3) multiply conclusions by weights 


``` {r eval = F }

weights <-
  list(c(0.6, 0.4), c(0.7, 0.3), c(0.3, 0.4, 0.3), c(0.8, 0.1, 0.1))
conc_options <-
  list(
    c("poor", "moderate", "good"),
    c("poor", "moderate", "good"),
    c("poor", "moderate", "good"),
    c("low", "moderate", "high")
  )
lower_conc_values <-
  list(list(se_4a_o = c("poor", "moderate", "good"), se_4b_o = c("poor", "good")), 
       list(se_3a_o = c("poor", "good"), se_3b_o = c("poor", "moderate", "good")),
       list(se_2a_o = c("poor", "good"), se_2b_o = c("poor", "good"), se_2c_o = c("poor", "good", "moderate")),
       list(se_2d_o = c("poor", "moderate", "good"), se_2e_o = c("poor", "good"), se_2f_o = c("poor", "good")))

conc_values_1 <- function(weights, conc_options, lower_conc_values) {
  # Generate all combinations of addition and subtraction

  str(lower_conc_values)
  rb <- expand.grid(lower_conc_values)
  n_rb <- nrow(rb)
  cat(paste("Number of rules =", n_rb, "\n"))
  
  rb[,] <- lapply(rb, function(x) type.convert(as.character(x), as.is = TRUE))
  
  rb_integer <- rb %>%
    mutate(across(
      where(is.character),
      ~ case_when(. == "poor" ~ -1,
                  . == "moderate" ~ 0,
                  . == "good" ~ 1,
                  TRUE ~ NA_integer_),
      .names = "{col}_integer"
    ))  %>% select(-where(is.character)) %>% drop()
  
  # Display the modified data frame
 
  #str(rb_integer)
  #str(weights)
  cat(paste("Weights =", weights, "\n"))
  cat(paste("Possible Conclusions =", conc_options, "\n"))
  
  rb_integer_weighted <- sweep(rb_integer, 2, weights, `*`)
  rb_integer_weighted$conc <- rowSums(rb_integer_weighted, na.rm = TRUE)
  rb_integer_weighted <- cbind(rb, rb_integer_weighted)
  
  rb_integer_weighted$conclusion <-
    ifelse(
      rb_integer_weighted$conc <= (-1 / 3),
      conc_options[1],
      ifelse(rb_integer_weighted$conc < (1 / 3),
             conc_options[2],
             conc_options[3])
    )
  
  #str(rb_integer_weighted) 
  
  # new proposition object is made here
  prop <- new("Proposition", table = rb %>% select(where(is.character)))
  # new conclusion object is made here
  conc <- new("Conclusion", table = select(rb_integer_weighted, conclusion) )
  
  # create a rule base
  rulebase <- RuleBase(prop, conc) %>% print()

  return(rulebase)
}

mapply(conc_values_1, weights, conc_options, lower_conc_values)

``` 

### Basic script to get the new rule base - BA

Logic:

1) How many lower rule bases
2) Get conclusions from lower rule bases



``` {r eval = F }

conc_options_ba <-
  list(c("suboptimal", "optimal"))

lower_conc_values_ba <- list(
  list(ba_2a_o = c("suboptimal", "optimal"), ba_2b_o = c("suboptimal", "optimal"), ba_2c_o = c("suboptimal", "optimal")))

conc_values_2 <- function(conc_options_ba, lower_conc_values_ba) {
  # Generate all combinations of addition and subtraction

  str(lower_conc_values_ba)
  n_ba <- length(lower_conc_values_ba)
  rb_ba <- expand.grid(lower_conc_values_ba)
  n_rb_ba <- nrow(rb_ba)
  cat(paste("Number of rules =", n_rb_ba, "\n"))
  
  rb_ba[,] <- lapply(rb_ba, function(x) type.convert(as.character(x), as.is = TRUE))
  
  rb_ba_integer <- rb_ba %>%
    mutate(across(
      where(is.character),
      ~ case_when(. == "suboptimal" ~ -1,
                  . == "optimal" ~ 1,
                  TRUE ~ NA_integer_),
      .names = "{col}_integer"
    ))  %>% select(-where(is.character)) %>% drop()
  
  # Display the modified data frame
 
  #str(rb_integer)
  cat(paste("Possible Conclusions =", conc_options_ba, "\n"))
  
  rb_ba_integer$conc <- rowSums(rb_ba_integer, na.rm = TRUE)
  rb_ba_integer <- cbind(rb_ba, rb_ba_integer)
  
  rb_ba_integer$conclusion <-
    ifelse(rb_ba_integer$conc < n,
           conc_options_ba[1], conc_options_ba[2])
    
  
  #str(rb_integer_weighted) 
  
  # new proposition object is made here
  prop_ba <- new("Proposition", table = rb_ba %>% select(where(is.character)))
  # new conclusion object is made here
  conc_ba <- new("Conclusion", table = select(rb_ba_integer, conclusion) )
  
  # create a rule base
  rulebase_ba <- RuleBase(prop_ba, conc_ba) %>% print()

  return(rulebase_ba)
}

mapply(conc_values_2, conc_options_ba, lower_conc_values_ba)

``` 

### Function to construct the new rule base - ALL

Logic:

1) How many lower rule bases
2) Get conclusions from lower rule bases
3) multiply conclusions by weights (if required)


``` {r  }

weights <-
  list(c(0.6, 0.4), c(0.7, 0.3), c(0.3, 0.4, 0.3), c(NA, NA, NA), c(0.8, 0.1, 0.1), c(0.6, 0.4))

# to reduce confusion it is preferable to remove conclusions from the higher level rule bases
# we assume that the conclusions are socio-economic (e.g. poor/moderate/good) except where the lower-level conclusions are biophysical (i.e. suboptimal/optimal)

lower_conc_values <-
  list(
    list(
      se_4a_o = c("poor", "moderate", "good"),
      se_4b_o = c("poor", "good")
    ),
    list(
      se_3a_o = c("poor", "good"),
      se_3b_o = c("poor", "moderate", "good")
    ),
    list(
      se_2a_o = c("poor", "good"),
      se_2b_o = c("poor", "good"),
      se_2c_o = c("poor", "good", "moderate")
    ),
    list(
      ba_2a_o = c("suboptimal", "optimal"),
      ba_2b_o = c("suboptimal", "optimal"),
      ba_2c_o = c("suboptimal", "optimal")
    ),
    list(
      se_2d_o = c("poor", "moderate", "good"),
      se_2e_o = c("poor", "good"),
      se_2f_o = c("poor", "good")
    ),
    list(
      ba_1_o = c("suboptimal", "optimal"),
      se_1_o = c("poor", "moderate", "good")
    ))


fn_create_rb <- function(lower_conc_values, weights, rb_conc_name) {
  
  # Create conc_options default
    conc_options <- c("suboptimal", "suboptimal", "optimal")
    c_o <- "ba"
    
  # Check if the text string is present in lower_conc_values
  if (any(grepl("good",lower_conc_values))) {
    conc_options <- c("poor", "moderate", "good")
    c_o <- "sef"
    }
  
  cat(paste("lower_conc_values =", lower_conc_values, "\n"))
  n <- length(lower_conc_values)
  weights[is.na(weights)] <- (1/n) # replace NA values in weights with values that sum to 1
  
  rb <- reduce(lower_conc_values, crossing)
  n_rb <- nrow(rb)
  cat(paste("str(rb) =", str(rb), "\n"))
  cat(paste("Number of rules =", n_rb, "\n"))
  
  #rb[,] <- apply(rb, function(x) type.convert(as.character(x), as.is = TRUE))
  
  rb_integer <- rb %>%
    mutate(across(
      where(is.character),
      ~ case_when(. == "poor" ~ -1,
                  . == "suboptimal" ~ -1,
                  . == "moderate" ~ 0,
                  . == "good"  ~ 1,
                  . == "optimal" ~ 1,
                  TRUE ~ NA_integer_),
      .names = "{col}_integer"
    ))  %>% select(-where(is.character)) %>% drop()
  
  # Display the modified data frame
 
  cat(paste("str(rb_integer) =", str(rb_integer), "\n"))
  cat(paste("Weights =", weights, "\n"))
  cat(paste("Possible Conclusions =", conc_options, "\n"))
  
  rb_integer_weighted <- sweep(rb_integer, 2, weights, `*`)
  rb_integer_weighted$conc <- rowSums(rb_integer_weighted, na.rm = TRUE)
  rb_integer_weighted <- cbind(rb, rb_integer_weighted)
  
  if (c_o == "sef") {
    rb_integer_weighted$conclusion <- 
    ifelse(
      rb_integer_weighted$conc <= (-1 / 3),
      conc_options[1],
      ifelse(
        rb_integer_weighted$conc <= (1 / 3),
        conc_options[2],
        conc_options[3]
      )
    )
  } else {
    rb_integer_weighted$conclusion <-
      ifelse(rb_integer_weighted$conc < 1,
           conc_options[2],
           conc_options[3])
  }

  
  cat(paste("str(rb_integer_weighted) =", str(rb_integer_weighted), "\n"))
  names(rb_integer_weighted)[names(rb_integer_weighted)=="conclusion"] <- rb_conc_name
  cat(paste("str(rb_integer_weighted) =", str(rb_integer_weighted), "\n"))
   
    # new proposition object is made here
  prop <- new("Proposition", table = rb %>% select(where(is.character)))
  # new conclusion object is made here
  conc <- new("Conclusion", table = select(rb_integer_weighted, {{ rb_conc_name }}))
  # create a rule base
  rulebase <- RuleBase(prop, conc) %>% print()
  
  return_list <- list(rulebase, conc)

  return(return_list)
}

#mapply(fn_create_rb, weights, lower_conc_values)
#lapply(lower_rb_concs_glob, fn_create_rb,  weights_glob)

#fn_create_rb(lower_rb_concs_glob, weights_glob_unlist, "hello" )

``` 

### Function to get all previous fuzzy partition names

Logic:

1) Does the row of the one-to-many df have data
If yes:
A2)  get fp name using rulebase number
A3)  append the fp name to the fp_list for the one-to-many df
If no:
B2) this row has an existing fp_list - get fp_list
B3) append this list to the fp_list for the one-to-many df

return the fp_list for the one-to-many df

``` {r  }

test_one_to_many_df <-
  data.frame(
    data_file_prefix = c(NA, NA, "data", "data"),
    rulebase_number.y = c("test_stack1", "test_stack2", "test_data1", "test_data2")
  )

fp_test_stack1_list <- as.list(c("test1 = fp_test1", "test2 = fp_test2"))
fp_test_stack2_list <- as.list(c("test3 = fp_test3", "test4 = fp_test4"))

fn_fill_fp_list <- function(df_one_many) {
  
  fp_list <- list() #initialise list
  df_one_many_data <-
    filter(df_one_many, !is.na(data_file_prefix)) # get rows that have a fuzzy partition
  df_one_many_nodata <-
    filter(df_one_many, is.na(data_file_prefix)) # get rows that have a fuzzy partition
  
  print(paste("nrow data = ", nrow(df_one_many_data)))
  
  if (nrow(df_one_many_data) > 0) {
    fp_prefix <- "fp_"
    df_one_many_data$fp <-
      paste(fp_prefix, df_one_many_data$rulebase_number.y, sep = "")
    str(df_one_many_data)
    fp_list <-
      append(fp_list, list(
        paste(
          df_one_many_data$rulebase_number.y,
          " = ",
          df_one_many_data$fp
        )
      ))
    fp_list <- as.list(unlist(fp_list))
  }
  
  print(paste("nrow no data = ", nrow(df_one_many_nodata)))
  
  if (nrow(df_one_many_nodata) > 0) {
    for (i in 1:nrow(df_one_many_nodata)){
    fp_list <-
      append(fp_list, get(
        paste0("fp_",
          df_one_many_nodata$rulebase_number.y[i],
          "_list")
      ))
  }}
  
  return(fp_list)
}

test_fp_list <- fn_fill_fp_list(test_one_to_many_df )

``` 

### Function to get all previous rule base names

Logic:

1) Does the row of the one-to-many df have data
If yes:
A2)  get rb name using rulebase number
A3)  append the rb name to a rule base list for the one-to-many df
If no:
B2) this row has an existing rule base stack - get the rule base stack list
B3) append this rule base stack list to the rule base list for the one-to-many df

return the rule base list for the one-to-many df

``` {r  }

test_one_to_many_df <-
  data.frame(
    data_file_prefix = c(NA, NA, "data", "data"),
    rulebase_number.y = c("test_data7", "test_data8", "test_data1", "test_data2"),
    rulebase_stack = c("test_data9", "test_data9", "test_data9", "test_data9"),
    rb = c("rb_test_data7", "rb_test_data8", "rb_test_data1", "rb_test_data2")
  )


# test input rule bases for data rows
rb_test_data1 <-
  RuleBase(new("Proposition", table = tibble(test_data1 = c("low", "high"))),
           new("Conclusion", table = tibble(test_data1_o = c("poor", "good"))))
rb_test_data2 <-
  RuleBase(new("Proposition", table = tibble(test_data2 = c("low", "high"))),
           new("Conclusion", table = tibble(test_data2_o = c("poor", "good"))))


# test input rule bases for stack rows
rb_test_data3 <-
  RuleBase(new("Proposition", table = tibble(test_data3 = c("low", "high"))),
           new("Conclusion", table = tibble(test_data3_o = c("poor", "good"))))
rb_test_data4 <-
  RuleBase(new("Proposition", table = tibble(test_data4 = c("low", "high"))),
           new("Conclusion", table = tibble(test_data4_o = c("poor", "good"))))
rb_test_data5 <-
  RuleBase(new("Proposition", table = tibble(test_data5 = c("low", "high"))),
           new("Conclusion", table = tibble(test_data5_o = c("poor", "good"))))
rb_test_data6 <-
  RuleBase(new("Proposition", table = tibble(test_data6 = c("low", "high"))),
           new("Conclusion", table = tibble(test_data6_o = c("poor", "good"))))


# test input higher level rule bases for stack rows
rb_test_data7 <-
  RuleBase(new("Proposition", table = tibble(test_data3_o = c("poor", "good","poor", "good"), test_data4_o = c("poor", "poor","good", "good"))),
           new("Conclusion", table = tibble(test_data7 = c("poor", "moderate", "moderate", "good"))))

rb_test_data8 <-
  RuleBase(new("Proposition", table = tibble(test_data5_o = c("poor", "good","poor", "good"), test_data6_o = c("poor", "poor","good", "good"))),
           new("Conclusion", table = tibble(test_data8 = c("poor", "good","poor", "good"))))

# test input higher level rule bases for the whole one-to-many table (24 rules)
rb_test_data9 <-
  RuleBase(new(
    "Proposition",
    table = tibble(
      test_data7 = c(
        "poor",
        "moderate",
        "good",
        "poor",
        "moderate",
        "good",
        "poor",
        "moderate",
        "good",
        "poor",
        "moderate",
        "good",
        "poor",
        "moderate",
        "good",
        "poor",
        "moderate",
        "good",
        "poor",
        "moderate",
        "good",
        "poor",
        "moderate",
        "good"
      ),
      test_data8 = c(
        "poor",
        "poor",
        "poor",
        "good",
        "good",
        "good",
        "poor",
        "poor",
        "poor",
        "good",
        "good",
        "good",
        "poor",
        "poor",
        "poor",
        "good",
        "good",
        "good",
        "poor",
        "poor",
        "poor",
        "good",
        "good",
        "good"
      ),
      test_data1_o = c(
        "poor",
        "poor",
        "poor",
        "poor",
        "poor",
        "poor",
        "good",
        "good",
        "good",
        "good",
        "good",
        "good",
        "poor",
        "poor",
        "poor",
        "poor",
        "poor",
        "poor",
        "good",
        "good",
        "good",
        "good",
        "good",
        "good"
      ),
      test_data2_o = c(
        "poor",
        "poor",
        "poor",
        "poor",
        "poor",
        "poor",
        "poor",
        "poor",
        "poor",
        "poor",
        "poor",
        "poor",
        "good",
        "good",
        "good",
        "good",
        "good",
        "good",
        "good",
        "good",
        "good",
        "good",
        "good",
        "good"
      )
    )
  ),
  new("Conclusion", table = tibble(
    test_data8 = c(
      "poor",
      "good",
      "poor",
      "good",
      "poor",
      "good",
      "poor",
      "good",
      "poor",
      "good",
      "poor",
      "good",
      "poor",
      "good",
      "poor",
      "good",
      "poor",
      "good",
      "poor",
      "good",
      "poor",
      "good",
      "poor",
      "good"
    )
  )))

# test input rule base stacks for stack rows
rbs_test_data7 <-  stack(rb_test_data7, rb_test_data3, rb_test_data4)
rb_list_test_data7 <-  list("rb_test_data7", "rb_test_data3", "rb_test_data4")
rbs_test_data8 <-  stack(rb_test_data8, rb_test_data5, rb_test_data6)
rb_list_test_data8 <-  list("rb_test_data8", "rb_test_data5", "rb_test_data6")


# test input rule base stack for the whole one-to-many table
x <-        paste("stack(rb_test_data9,", gsub(",$", "", paste0(
  rb_list_test_data7, sep = ",", collapse = ""
)),"," ,gsub(",$", "", paste0(
  rb_list_test_data8, sep = ",", collapse = ""
)),", rb_test_data1,  rb_test_data2)")




fn_fill_rb_list <- function(df_one_many) {
  
  rb_list <- list() #initialise list
  df_one_many_data <-
    filter(df_one_many, !is.na(data_file_prefix)) # get rows that have a fuzzy partition
  df_one_many_nodata <-
    filter(df_one_many, is.na(data_file_prefix)) # get rows that have a fuzzy partition
  
  print(paste("nrow data = ", nrow(df_one_many_data)))
  
  if (nrow(df_one_many_data) > 0) {
    # rb_prefix <- "rb_"
    # df_one_many_data$rb <-
    #   paste(rb_prefix, df_one_many_data$rulebase_number.y, sep = "")
    # str(df_one_many_data)
    rb_list <-
      append(rb_list, list(
        paste(df_one_many_data$rb
        )
      ))
    rb_list <- as.list(unlist(rb_list))
  }
  
  print(paste("nrow no data = ", nrow(df_one_many_nodata)))
  
  if (nrow(df_one_many_nodata) > 0) {
    for (i in 1:nrow(df_one_many_nodata)) {
      print(paste0("rb_list_",
                   df_one_many_nodata$rulebase_number.y[i]))
      rb_list <-
        append(rb_list, get(
          paste0("rb_list_",
                 df_one_many_nodata$rulebase_number.y[i])
        ))
    }
  }
  
  return(rb_list)
}

test_rb_list <- fn_fill_rb_list(test_one_to_many_df )

``` 


## Get the lowest level non-data rulebases

Any criterion which is a leaf should be removed from the priorities df.
Then get the hierarchy level for the remaining rows.

Start with the criteria with the highest level and proceed to the root level

``` {r eval = F }

# inverse join df_leaves_data to df_priorities_new_columns

df_rulebases <-
  anti_join(df_priorities_new_columns,
            df_leaves_data,
            by = 'rulebase_number',
            copy = FALSE)

#  join df_rulebases to hierarchies

# first split hierarchies based on hierarchy level

# get highest level

hierarchy_level_max <- max(unique(hierarchies$level_number))
print(paste("highest hierarchy level = ", hierarchy_level_max))

# for loop to run through all hierarchy levels from biggest to smallest
for (i in hierarchy_level_max:1) {
  print(paste0('level', i))
  
  # join to the rulebases
  assign(paste0("df_hierarchy_", i),
         inner_join(
           select(df_rulebases, rulebase_number),
           filter(select(
             hierarchies, level_number, paste0('level', i)
           ), level_number == i),
           by = c('rulebase_number' = paste0('level', i))
         ))
  
  # if no data move to next
  if (nrow(get(paste0("df_hierarchy_", i)) != 0)) {
    print(paste0('level', i))
    
    # each row in the df is a rulebase stack
    # for each row need to join to original priorities
    
    # Main function
    # apply(get(paste0("df_hierarchy_", i)), 1, function(df_row)) {
    #   df_temp <-
    #     inner_join(
    #       df_hierarchy,
    #       df_priorities_new_columns,
    #       by = c('rulebase_number' = 'rulebase_stack')
    #     )
    #   print(df_temp)
    # }
    
    #Custom function to perform one-to-many join for each row
    custom_join_function <- function(row) {
      row_df <- data.frame(rulebase_number = row[["rulebase_number"]])
      result_df <-
        left_join(
          row_df,
          df_priorities_new_columns,
          by = c('rulebase_number' = 'rulebase_stack'),
          keep = TRUE
        )
      return(result_df)
    }
    
        # Apply the custom function to each row of df1
    assign(paste0("result_df", i), apply(get(paste0("df_hierarchy_", i)), 1, custom_join_function)
    
    # Print the list of result data frames
    print(result_list)
    
    
  }
}


```

## Get the one-to-many data frames of rule base stacks and the conclusions from the weights in each rulebase stack

This uses the code from the previous chunk, as well as the computation of the weights from above

``` {r eval = F }

# inverse join df_leaves_data to df_priorities_new_columns

df_rulebases <-
  anti_join(df_priorities_new_columns,
            df_leaves_data,
            by = 'rulebase_number',
            copy = FALSE)

#  join df_rulebases to hierarchies

# first split hierarchies based on hierarchy level

# get highest level

hierarchy_level_max <- max(unique(hierarchies$level_number))
print(paste("highest hierarchy level = ", hierarchy_level_max))

# for loop to run through all hierarchy levels from biggest to smallest
for (i in hierarchy_level_max:1) {
  print(paste0('level', i))
  
  # join to the rulebases
  assign(paste0("df_hierarchy_", i),
         inner_join(
           select(df_rulebases, rulebase_number),
           filter(select(
             hierarchies, level_number, paste0('level', i)
           ), level_number == i),
           by = c('rulebase_number' = paste0('level', i))
         ))
  
  # if no data move to next
  if (nrow(get(paste0("df_hierarchy_", i)) != 0)) {
    print(paste0('level', i))
    
    #Custom function to perform one-to-many join for each row
    custom_join_function <- function(row) {
      df_row <- data.frame(rulebase_number = row[["rulebase_number"]])
      df_one_many <-
        left_join(
          df_row,
          df_priorities_new_columns,
          by = c('rulebase_number' = 'rulebase_stack'),
          keep = TRUE
        )
      
      weights <- list(df_one_many$weight)
      print(weights)
      results_classes_unique <- lapply(weights, conc_values) # applies the conc_values function from above
      newList <- list("df" = df_one_many, "conlusions" = results_classes_unique)
      return(newList)
      
     }
    
    # Apply the custom function to each row of df1
    assign(paste0("df_one_many_", i),
           apply(get(paste0("df_hierarchy_", i)), 1, custom_join_function))
    
    # Print the list of result data frames
    #print(result_list)
    
    
  }
}


```

## Get the data frames conclusions and rule base for each rulebase stack

This uses the code from the previous chunks.

In addition to before the chunk will get the rule base names

``` {r eval = F }

# inverse join df_leaves_data to df_priorities_new_columns

df_rulebases <-
  anti_join(df_priorities_new_columns,
            df_leaves_data,
            by = 'rulebase_number',
            copy = FALSE)

#  join df_rulebases to hierarchies

# first split hierarchies based on hierarchy level

# get highest level

hierarchy_level_max <- max(unique(hierarchies$level_number))
print(paste("highest hierarchy level = ", hierarchy_level_max))

# for loop to run through all hierarchy levels from biggest to smallest
for (i in hierarchy_level_max:1) {
  print(paste0('level', i))
  
  # join to the rulebases
  assign(paste0("df_hierarchy_", i),
         inner_join(
           select(df_rulebases, rulebase_number),
           filter(select(
             hierarchies, level_number, paste0('level', i)
           ), level_number == i),
           by = c('rulebase_number' = paste0('level', i))
         ))
  
  # if no data move to next
  if (nrow(get(paste0("df_hierarchy_", i)) != 0)) {
    print(paste0('level', i))
    
    #Custom function to perform one-to-many join for each row
    custom_join_function <- function(row) {
      df_row <- data.frame(rulebase_number = row[["rulebase_number"]])
      df_one_many <-
        left_join(
          df_row,
          df_priorities_new_columns,
          by = c('rulebase_number' = 'rulebase_stack'),
          keep = TRUE
        )
      
      weights <- list(df_one_many$weight)
      print(paste("weights = ", weights))
      #str(df_one_many)
      lower_rb <- list(df_one_many$rulebase_number.y)      # get the rule bases
      print(paste("lower_rb = ", lower_rb))
      
      results_classes_unique <- lapply(weights, conc_values) # applies the conc_values function from above
      newList <- list("df" = df_one_many, "conlusions" = results_classes_unique, "lower rule bases" = lower_rb)
      return(newList)
      
     }
    
    # Apply the custom function to each row of df1
    assign(paste0("df_one_many_", i),
           apply(get(paste0("df_hierarchy_", i)), 1, custom_join_function))
    
    # Print the list of result data frames
    #print(result_list)
    
    
  }
}


```

## Get the data frames, conclusions, rule bases and fuzzy partitions for each rulebase stack

This uses the code from the previous chunks.

In addition to before the chunk will get the fuzzy partition names.

``` {r  eval = F}

# inverse join df_leaves_data to df_priorities_new_columns

df_rulebases <-
  anti_join(df_priorities_new_columns,
            df_leaves_data,
            by = 'rulebase_number',
            copy = FALSE)

#  join df_rulebases to hierarchies

# first split hierarchies based on hierarchy level

# get highest level

hierarchy_level_max <- max(unique(hierarchies$level_number))
print(paste("highest hierarchy level = ", hierarchy_level_max))

# for loop to run through all hierarchy levels from biggest to smallest
for (i in hierarchy_level_max:1) {
  print(paste0('level', i))
  
  # join to the rulebases
  assign(paste0("df_hierarchy_", i),
         inner_join(
           select(df_rulebases, rulebase_number),
           filter(select(
             hierarchies, level_number, paste0('level', i)
           ), level_number == i),
           by = c('rulebase_number' = paste0('level', i))
         ))
  
  # if no data move to next
  if (nrow(get(paste0("df_hierarchy_", i)) != 0)) {
    print(paste0('level', i))
    
    #Custom function to perform one-to-many join for each row
    custom_join_function <- function(row) {
      df_row <- data.frame(rulebase_number = row[["rulebase_number"]])
      df_one_many <-
        left_join(
          df_row,
          df_priorities_new_columns,
          by = c('rulebase_number' = 'rulebase_stack'),
          keep = TRUE
        )
      
      df_one_many_data <-
        filter(df_one_many,!is.na(data_file_prefix)) # get rows that have a fuzzy partition
      
      print(paste("nrow = ", nrow(df_one_many_data)))
      if (nrow(df_one_many_data) > 0) {
        fp_prefix <- "fp_"
        df_one_many_data$fp <-
          paste(fp_prefix, df_one_many_data$rulebase_number.y, sep = "")
        fp_list <- list(df_one_many_data$fp) # get the fp names
        print(paste("fp_list = ", fp_list))
      }
      
      weights <- list(df_one_many$weight)
      print(paste("weights = ", weights))

      lower_rb <- list(df_one_many$rulebase_number.y)      # get the rule bases
      print(paste("lower_rb = ", lower_rb))
      
      results_classes_unique <- lapply(weights, conc_values) # applies the conc_values function from above
      newList <- list("df" = df_one_many, "conlusions" = results_classes_unique, "lower rule bases" = lower_rb)
      
      return(newList)
      
     }
    
    # Apply the custom function to each row of df1
    assign(paste0("df_one_many_", i),
           apply(get(paste0("df_hierarchy_", i)), 1, custom_join_function))
    
    # Print the list of result data frames
    #print(result_list)
    
    
  }
}


```

## Get the data frames, conclusions (labels from a different list still using lapply), rule bases and fuzzy partitions for each rulebase stack

This uses the code from the previous chunks.

In addition to before the chunk will get the fuzzy partition and lower rule base names.

``` {r  eval = F}

# inverse join df_leaves_data to df_priorities_new_columns

df_rulebases <-
  anti_join(df_priorities_new_columns,
            df_leaves_data,
            by = 'rulebase_number',
            copy = FALSE)

#  join df_rulebases to hierarchies

# first split hierarchies based on hierarchy level

# get highest level

hierarchy_level_max <- max(unique(hierarchies$level_number))
print(paste("highest hierarchy level = ", hierarchy_level_max))

# for loop to run through all hierarchy levels from biggest to smallest
for (i in hierarchy_level_max:1) {
  print(paste0('level', i))
  
  # join to the rulebases
  assign(paste0("df_hierarchy_", i),
         inner_join(
           select(df_rulebases, rulebase_number, conclusion_1, conclusion_2, conclusion_3),
           filter(select(
             hierarchies, level_number, paste0('level', i)
           ), level_number == i),
           by = c('rulebase_number' = paste0('level', i))
         ))
  
  # if no data move to next
  if (nrow(get(paste0("df_hierarchy_", i)) != 0)) {
    print(paste0('level', i))
    

    #Custom function to perform one-to-many join for each row
    custom_join_function <- function(row) {
      
      conc_options <-
        c(row[["conclusion_1"]], row[["conclusion_2"]], row[["conclusion_3"]])
      print(conc_options)
      print(paste("conc_options = ", conc_options))
      
      df_row <- data.frame(rulebase_number = row[["rulebase_number"]])
      df_one_many <-
        left_join(
          df_row,
          df_priorities_new_columns,
          by = c('rulebase_number' = 'rulebase_stack'),
          keep = TRUE
        )

      df_one_many_data <-
        filter(df_one_many,!is.na(data_file_prefix)) # get rows that have a fuzzy partition
      
      print(paste("nrow = ", nrow(df_one_many_data)))
      if (nrow(df_one_many_data) > 0) {
        fp_prefix <- "fp_"
        df_one_many_data$fp <-
          paste(fp_prefix, df_one_many_data$rulebase_number.y, sep = "")
        fp_list <- list(df_one_many_data$fp) # get the fp names
        print(paste("fp_list = ", fp_list))
      } else {print(paste("no fp_list"))}
      
      weights <- list(df_one_many$weight)
      
      # check if there are NA weights in the list signifying a biophysical aptitude rule
      if (any(sapply(weights, is.na))) {
        print("There are NA values in the weights list.")
        results_classes_unique <- list("suboptimal", "optimal")
        
      } else {
        print("There are no NA values in the weights list.")
        print(paste("weights = ", weights))
        results_classes_unique <-
          lapply(weights, conc_values_m, conc_options) # applies the conc_values function from above
      }
      
      rb_prefix <- "rb_"
        df_one_many$rb <-
          paste(rb_prefix, df_one_many$rulebase_number.y, sep = "")
      lower_rb <- list(df_one_many$rb)      # get the rule bases
      print(paste("lower_rb = ", lower_rb))
      
      newList <- list("df" = df_one_many, "conlusions" = results_classes_unique, "lower rule bases" = lower_rb)
      
      return(newList)
      
     }
    
    # Apply the custom function to each row of df1
    assign(paste0("df_one_many_", i),
           apply(get(paste0("df_hierarchy_", i)), 1, custom_join_function))
    
    # Print the list of result data frames
    #print(result_list)
    
    
  }
}


```

## Get the data frames, conclusions (labels from a different list still using lapply), rule bases and fuzzy partitions for each rulebase stack - create the new rule base from the propositions and conclusions.

This uses the code from the previous chunks.

``` {r }

# function to get a list of lower level conclusions values in this format
#list(se_4a_o = c("poor", "moderate", "good"),
#      se_4b_o = c("poor", "good")
#    )

get_rb <- function(list_object) {
  print(paste("rb list_object =" , list_object))
  rb_list_object <- get(paste(list_object))
  #print(rb_list_object)
  #str(rb_list_object)
  lower_conc_table <-
    rb_list_object@conclusion@table # gets the tibble of values
  # print(lower_conc_table)
  # str(lower_conc_table)
  # lower_conc_table_varname <-
  # names(lower_conc_table) # gets the name
  # print(paste("lower_conc_table_varname = ", lower_conc_table_varname))
  # lower_conc_list <- setNames(list(as.character(lower_conc_table[[lower_conc_table_varname]])), lower_conc_table_varname)
  # 
  # #str(lower_conc_list)
  # print(paste("lower_conc_list =" , str(lower_conc_list)))
  return(lower_conc_table)
  
}

``` 

``` {r }

# inverse join df_leaves_data to df_priorities_new_columns

df_rulebases <-
  anti_join(df_priorities_new_columns,
            df_leaves_data,
            by = 'rulebase_number',
            copy = FALSE)

#  join df_rulebases to hierarchies

# first split hierarchies based on hierarchy level

# get highest level

hierarchy_level_max <- max(unique(hierarchies$level_number))
print(paste("Highest hierarchy level = ", hierarchy_level_max))

# for loop to run through all hierarchy levels from biggest to smallest
for (i in hierarchy_level_max:1) {
  cat(paste0('\nLevel', i, "\n"))
  
  # join to the rulebases
  assign(paste0("df_hierarchy_", i),
         inner_join(
           select(df_rulebases, rulebase_number, conclusion_1, conclusion_2, conclusion_3),
           filter(select(
             hierarchies, level_number, paste0('level', i)
           ), level_number == i),
           by = c('rulebase_number' = paste0('level', i))
         ))
  
  # if no data move to next
  if (nrow(get(paste0("df_hierarchy_", i)) != 0)) {
    print(paste0('Level', i, " has higher rule bases"))
    
    #Custom function to perform one-to-many join for each row
    custom_join_function <- function(row) {
      
      # conc_options <-
      #   c(row[["conclusion_1"]], row[["conclusion_2"]], row[["conclusion_3"]])
      # print(conc_options)
      # print(paste("conc_options = ", conc_options))
      
      df_row <- data.frame(rulebase_number = row[["rulebase_number"]])
      df_one_many <-
        left_join(
          df_row,
          df_priorities_new_columns,
          by = c('rulebase_number' = 'rulebase_stack'),
          keep = TRUE
        )
      
      
      print(paste("Stack = ", df_one_many[["rulebase_stack"]], df_one_many[["stack"]]))
      print(paste("Criterion = ", df_one_many[["criterion"]]))
      conc_name <- unique(df_one_many[["rulebase_stack"]])
      print(paste("conc_name = ", conc_name))
      
      
      ### GET OR ADD TO THE FUZZY PARTITION LIST ###
      
      fp_list <- fn_fill_fp_list(df_one_many) # function gets the fp list
      
      assign(paste0("fp_", conc_name, "_list"),
             fp_list,
             .GlobalEnv) # make a globally available named list
      
      ### GET WEIGHTS ###
      
      weights <- df_one_many$weight
      weights_glob <<- weights
      print(weights)
      
      ### CONSTRUCT THE NEW RULE BASE ###    
      
      rb_prefix <- "rb_"
      df_one_many$rb <-
        paste(rb_prefix, df_one_many$rulebase_number.y, sep = "")

      lower_rb <- df_one_many$rb      # get the rule bases
      # get and print the lower rule bases to ensure that these are available
      print(paste("lower_rb = ", lower_rb))
      str(lower_rb)

      lower_rb_glob <<-
        lower_rb      # save to global env for debugging
      lower_rb_concs <- lapply(lower_rb, get_rb)
      lower_rb_concs_glob <<- (lower_rb_concs)
       
      print(paste("str(lower_rb_concs) =", str(lower_rb_concs)))
      print(paste("lower_rb_concs =", lower_rb_concs))
      
      cat(paste("\nDEBUG2 START\n\n"))
      
      #### HERE
      
      
      #result_rb <- mapply(weights, fn_create_rb, lower_rb_concs) 
      results_rb  <- fn_create_rb(lower_rb_concs, weights, conc_name)
      str(results_rb)
      result_rb <- unlist(results_rb[[1]])
      print(result_rb)
      result_rb_conc <- unlist(results_rb[[2]])
      print(result_rb_conc)
      
      cat(paste("\nDEBUG2 END\n\n"))
                  
      assign(paste0("rb_",conc_name), result_rb, .GlobalEnv)
      
      
      ### GET OR ADD TO THE RULE BASE STACK ###
      
      rb_list <- fn_fill_rb_list(df_one_many)
      rb_list <-  append(rb_list, paste0("rb_", conc_name))
      rb_list_glob <<- rb_list
      print(rb_list)   
      
      assign(paste0("rb_list_", conc_name), rb_list,
             .GlobalEnv) # convert to rule base list

      newList <- list("df" = df_one_many, "fp" = fp_list , "rb" = result_rb, rbs = rb_list)

      
 
      
      # print(get(paste0("rb_list_", conc_name)))
      # str(get(paste0("rb_list_", conc_name)))
      
      # # create the rule base stack from the list
      x <-
        paste("stack(", gsub(",$", "", paste0(
          get(paste0("rb_list_", conc_name)), sep = ",", collapse = ""
        )), ")")
      
      print(x)
      
      assign(paste0("rbs_", conc_name), eval(parse(text = x)))
      #print(get(paste0("rbs_", conc_name)))
      
      # # evaluate the rule base stack
      
      w <-
        paste0("predict(",
              "rbs_",
              conc_name,
              ", newdata = df_irm,",
              gsub(",$", "", paste0(
                fp_list, sep = ",", collapse = ""
              )),
              ")")
      print(w)
      assign(paste0("fpm_", conc_name), eval(parse(text = w)),
             .GlobalEnv)

      
      # columns defined by conclusions to rule base
      
      fpm_colnames <<- pull(distinct(result_rb_conc@table))
      
      print(fpm_colnames)
      
      for (i in 1:length(fpm_colnames)) {
        
      col_suffix <-   substr( fpm_colnames[[i]] , start = 1 , stop = 1 )
      print(col_suffix)
      
      mem_text <- paste0("getMembership(","fpm_", conc_name,"$", fpm_colnames[[i]],")")
      print(mem_text)
      membership <- eval(parse(text = mem_text))
      
      df_irm <<-
        mutate(df_irm,!!as.character(paste0(conc_name, "_", col_suffix)) := membership, .keep = c("all"))
        
      }
      
      # o_col <- getMembership(get(paste0("fpm_",
      #                                   df_criteria_ba1[1, 2]))$optimal)
      # s_col <- getMembership(get(paste0("fpm_",
      #                                   df_criteria_ba1[1, 2]))$suboptimal)
      # df_irm <-
      #   mutate(df_irm,!!as.character(paste0(df_criteria_ba1[1, 2], "_o")) := o_col, .keep = c("all"))
      # df_irm <-
      #   mutate(df_irm,!!as.character(paste0(df_criteria_ba1[1, 2], "_s")) := s_col, .keep = c("all"))
      # 
      # g_col <- getMembership(get(paste0("fpm_",
      #                                   df_criteria_se3a_4a[1, 3]))$good)
      # df_irm <-
      #   mutate(df_irm, !!as.character(paste0(df_criteria_se3a_4a[1, 3], "_g")) := g_col, .keep = c("all"))
      # 
      # if (ext_conclusion2 == "moderate" |
      #     ext_conclusion3 == "moderate") {
      #   m_col <- getMembership(get(paste0("fpm_",
      #                                     df_criteria_se3a_4a[1, 3]))$moderate)
      #   df_irm <-
      #     mutate(df_irm,!!as.character(paste0(df_criteria_se3a_4a[1, 3], "_m")) := m_col, .keep = c("all"))
      #   
      #   ext_rb <- "gmp"
      # } else
      #   ext_rb <- "gp"
      # 
      # p_col <- getMembership(get(paste0("fpm_",
      #                                   df_criteria_se3a_4a[1, 3]))$poor)
      # df_irm <-
      #   mutate(df_irm,!!as.character(paste0(df_criteria_se3a_4a[1, 3], "_p")) := p_col, .keep = c("all"))
            
      # ### TO BE DONE 16/02/2024 ### START
      #
      
      cat(paste("\nDEBUG1 START\n\n"))
      n = 2
      fpm_conc_var <-
        c(as.character(paste0(df_criteria_se3a_4a[1, 3], "_g")),  as.character(paste0(df_criteria_se3a_4a[1, 3], "_p")), "x" , "y")
      fpm_conc_name <-
        c(as.character(paste0(df_criteria_se3a_4a[1, 4], " good")),  as.character(paste0(df_criteria_se3a_4a[1, 4], " poor")))
      
    }
    fpm_plot_title <-
      "Extension\nAccess\noptimality\nmembership"
    
    plot_fpm <-
      rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
    #
    cat(paste("\nDEBUG1 END\n\n"))      #
      
      
      ### TO BE DONE 16/02/2024 ### END
      
      
      cat(paste("\nEND \n\n"))
            
      return(newList)
      
     }
    
    # Apply the custom function to each row of df1
    assign(paste0("df_one_many_", i),
           apply(get(paste0("df_hierarchy_", i)), 1, custom_join_function))
    
  }
}


```




