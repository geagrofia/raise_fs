---
title: Fuzzy rule based modelling of the biophysical aptitude and the socio-economic feasibility
author: ""
date: "`r Sys.Date()`"
output:
  html_document:  
    code_folding: "hide"
    theme: united
    number_sections: no
    toc: yes
    toc_float: true
    toc_depth: 6
    css: js/style.css
params:
  INT: NA
  SYS: comparison
  Agg: 1
  MASK: 1000
  INN1: lg_potato
  RES1: 3
  SOS1: 1
  SUBDIV1: Kebelle
  TRI1: Aptitude
  INN2: lg_superpotato
  RES2: 3
  SOS2: 1
  SUBDIV2: Kebelle
  TRI2: Aptitude

---

<style>
pre {
  overflow-x: auto;
}
pre code {
  word-wrap: normal;
  white-space: pre;
}

div.INN { background-color:#e6f0ff; border-radius: 5px; padding: 10px; font-size: 200%;  color: orange;}
div.Agg { background-color:#e6f0ff; border-radius: 5px; padding: 10px; font-size: 150%;  color: orange;}

</style>

<script src="js/hideOutput.js"></script>


```{r i1_i1_parameter_description, echo=FALSE, message=FALSE, warning=FALSE}

# The parameters above are set to NA here, but when this rmd script is run from the shiny app then the parameters are passed with values.

# The first four parameters are general: 

# INT defines whether interface provides the parameter values - any value other than NA passed from the interface will tell this rmd script to use all parameters. The interface passes a value of 1 automatically.

# SYS is only relevant when more than one innovation is being tested. It sets whether the system is an intercrop, a comparison between crops or a rotation. Allowed values are "comparison","intercrop" and  "rotation"

# Agg defines the aggregation factor. This can be set above in the header with an integer value, or can be passed from the interface. The larger the aggregation factor the quicker the computation. The minimum value is 1.

# MASK defines the spatial resolution of the mask in metres

# The following parameters are specific to each innovation: 

# INN denotes the innovation, this is a unique code for each location/innovation and is used to locate the data and parameters that are used in IRM

# SOS sets whether the season onset is spatially defined. If so, SOS has a value of 1 and the start of the growing period is set using a raster rather than the value in the growth stage csv file. Otherwise SOS is 0.

# RES defines whether 3-class adoption (2 class aptitude), or FAO style 5-class adoption (5-class aptitude with added maps on the limitations) or both classes are computed. Computing both classes will increase the time to run the script!
#A value of 1 will only compute the 3-class suitability maps. A value of 2 will only compute the 5-class suitability map. A value of 3 will compute both suitability class maps. Other classified maps will be shown but only require a re-classification of the other results.

# TRI is the field name used for the triangulation points

# SUBDIV is the field name used to identify the subdivision polygons


```

```{r i1_i1_folding_outputs_chunks, echo=FALSE, message=FALSE, warning=FALSE}

# Folding outputs chunks

# hideOutput.js and style.css courtesy of Martin Schmelzer https://stackoverflow.com/users/1777111/martin-schmelzer
# https://stackoverflow.com/questions/37755037/how-to-add-code-folding-to-output-chunks-in-rmarkdown-html-documents
 

```

```{r i1_i1_initialise01, cache = FALSE, echo=FALSE, message=FALSE, warning=FALSE}

# initialisation
 # library(raster)
 # library(maptools)
  library(tidyverse)
  library(fuZR)
  library(knitr)
  library(irm)
  #library(rgdal)
  library(tinytex)
  library(ggplot2)
  library(conflicted)
  library(kableExtra)
  library(shiny)
  library(leaflet)
  library(tibble)
  library(sf)
  #library(stars)
  library(widgetframe)
  library(patchwork)
  library(here)
  library(DiagrammeR)
  library(lava)
  library(svgPanZoom)
  library(scales)
  library(terra)
  library(tidyterra)
  library(lubridate)
```

```{r i1_i1_initialise02, echo=FALSE, message=FALSE, warning=FALSE}

r_filename <- function(filename) {
  here::here("code/r/", filename)
}

# Prefer over all other packages
conflict_prefer("union", "dplyr")

source(r_filename("irm_functions.R"))


#set (chunk) options - figure path is necessary to avoid an error message
opts_chunk$set(
  comment = NA,
  dpi = 96,
  echo = FALSE,
  fig.path = paste0("figures/", params$INN1,"/"),
  warning = FALSE,
  cache = TRUE
)

options(width = 250, dplyr.width = 120)

```

```{r i1_i1_innovation_name1, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

cat("# First Innovation
    ")
```

```{r i1_i1_innovation_name2, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

cat("<div class='INN'>")
cat("Innovation name =", params$INN1)
cat("</div>")
cat("<div class='Agg'>")
cat("Mask Resolution =", params$MASK)
cat("\nSpatial Aggregation =", params$Agg)
cat("</div>")

```

# Basic Settings

## Parameters, Criteria and Rule Bases

Here we load some parameters used in the IRM model, load the table of criteria and their threshold values, weights (if relevant) and data, and display the rule bases in a graphical diagramme. 

### Parameters and Criteria

<div class="fold o"> 
```{r i1_i1_parameters_location, results='asis'}

# Each innovation has potentially different growing periods, rule bases, rule base priorities, and thresholds

# The next set of parameters are for the priorities of the socio-economic rule base.
# Following this there are parameters for the growing period length.
# There then follow parameters for thresholds and threshold widths

# get the priorities filename using the innovation parameter
priorities_filename <-
  as.character(paste("tab_data/input/priorities_", params$INN1, ".csv", sep = ""))

df_priorities <- read.csv(here(priorities_filename), na.strings = c("NA"))

df_priorities %>%

kable(digits = 3) %>% kable_styling("striped", full_width = T) %>%
  row_spec(0, angle = -45) %>%  scroll_box(height = "500px")

```
</div>

### Rule Base Diagramme

Boxes in green show basic rule bases which have data and a fuzzy partition defined. Circles in red are complex rule base stacks, which depend on the results of other rule bases. 

<div class="fold o"> 
```{r i1_i1_rule_base_graphs, results='asis'}

priorities_new_columns_filename <-
  as.character(paste("tab_data/input/priorities_new_columns_", params$INN1, ".csv", sep = ""))

df_priorities_new_columns <- read.csv(here(priorities_new_columns_filename), na.strings = c("NA"))

df_edges <-  select(df_priorities_new_columns, criterion, stack) %>% dplyr::filter( !is.na(stack)) # %>% 
#as.matrix(ncol = 2)

df_vertices <-  select(df_priorities_new_columns, criterion) 

library(igraph)
#graph_rb <- graph_from_edgelist(df_edges)
graph_rb <- graph_from_data_frame(df_edges, directed=TRUE, vertices=df_vertices)
#dotfile_graph_rb <- write_graph(graph_rb, paste0("../../tab_data/output/graph_rb", "dot"))
#if (!interactive()) {
#  unlink(file)
#}
plot(graph_rb)
print(graph_rb, e=TRUE, v=TRUE)
adj_list <- as_adj_list(graph_rb, mode = c("in"))

```
</div>


<div class="fold o"> 
```{r i1_i1_rule_base_graphs2, results='asis'}
# In this chunk we will use the DiagrammeR package to produce a graph diagram of the rule bases, using the information provided by the priorities csv file loaded in the previous chunk.

# the DiagrammeR package expects a valid graph specification in the DOT language. The graph is a kind of network with nodes and edges. For our purposes the nodes are the criteria and the rule bases. The edges are directed lines that show how each contributes and can also the weight of each criteria (or the results of previously run rule bases)

# the graph has a statement followed by the list of nodes and edges

# in this chunk we will construct the string that is equivalent to a .gv file


# this creates a new df with a string of rulebase number and labels

df_rbnumber1 <- unite(df_priorities, "id_label0", "rulebase_number","criterion", sep = " [ label = '", remove = FALSE, na.rm = FALSE)
df_rbnumber1 <- unite(df_rbnumber1, "id_label1", "id_label0", "rulebase_number", sep = " \n", remove = FALSE, na.rm = FALSE)
df_rbnumber1$cl_br <- c(" ']")
df_rbnumber1 <- unite(df_rbnumber1, "id_label", "id_label1","cl_br", sep = "", remove = TRUE, na.rm = FALSE)

rbstacklist1 <- df_rbnumber1[,"rulebase_stack"]  
rbstacklist2 <- rbstacklist1[!is.na(rbstacklist1)] 
rbstacklist3 <- unique(rbstacklist2)
rbstacklist4 <- paste(rbstacklist3, collapse=";")

rbnumberlist1 <- df_rbnumber1[,"rulebase_number"]  
rbnumberlist2 <- rbnumberlist1[!is.na(rbnumberlist1)] 
rbnumberlist3 <- unique(rbnumberlist2)
rbnumberlist4 <- rbnumberlist3[rbnumberlist3 %ni% rbstacklist3]
rbnumberlist5 <- paste(rbnumberlist4, collapse=";")

rbnumberlist2 <- rbnumberlist2[! rbnumberlist2 %in% c('adop_0')]

edges1 <- paste(rbnumberlist2,rbstacklist2, sep="->")  
edges2 <- paste(edges1, collapse=" ")

rbnumberlabellist1 <- df_rbnumber1[,"id_label"]  
rbnumberlabellist2 <- rbnumberlabellist1[!is.na(rbnumberlist1)] 
rbnumberlabellist3 <- unique(rbnumberlabellist2)
rbnumberlabellist4 <- rbnumberlabellist3[rbnumberlist3 %ni% rbstacklist3]
rbnumberlabellist5 <- paste(rbnumberlabellist4, collapse=";")

rbstacklabellist1 <- df_rbnumber1[,"id_label"]
rbstacklabellist2 <- rbstacklabellist1[!is.na(rbstacklist1)] 
rbstacklabellist3 <- rbstacklabellist2[rbnumberlist3 %in% rbstacklist3]
rbstacklabellist4 <- paste(rbstacklabellist3, collapse=";")

rulebasegraph_name <- paste("digraph simple_rule_base")
rulebasegraph_graph_stmt <- paste("graph [overlap = true, fontsize = 100, fontname = Calibri, rankdir = LR, label = 'Rule bases for ", params$INN1, "', labelloc = t]")
rulebasegraph_node_stmt <- paste("node [shape = box, fontsize = 50, fontname = Helvetica, color = 'DarkOliveGreen4', fillcolor = 'OliveDrab2', style = filled]",
  rbnumberlabellist5,
  "node [shape = oval, fixedsize = false, width = 0.9, color = 'red', fillcolor = 'IndianRed3', fontsize = 50, fontname = Helvetica, style = filled] ",
  rbstacklabellist4
  )

rulebasegraph_edge_stmt <- paste(edges2)

rulebasegraph <- paste(rulebasegraph_name, "{", rulebasegraph_graph_stmt, rulebasegraph_node_stmt, rulebasegraph_edge_stmt, "}")

grViz(rulebasegraph)

#frameWidget(grViz(rulebasegraph) , options = frameOptions(allowfullscreen = FALSE))


#knitr::knit_exit() # this stops knitting useful for debugging

```
</div>

```{r i1_i1_rule_base_stack_binary, results='asis'}


# adoption rule base exists?
if (("adop_0" %in% rbstacklist3) & ("ba_1" %in% rbstacklist3) & ("se_1" %in% rbstacklist3)){
    adop_crit <- TRUE
} else {adop_crit <- FALSE}


# biophysical aptitude rule base exists?
if ("ba_1" %in% rbstacklist3) {
    ba_crit <- TRUE
} else {ba_crit <- FALSE}

# agricultural land rule base exists?
if ("ba_2a" %in% rbnumberlist3) {
    land_crit <- TRUE
} else {land_crit <- FALSE}

# season onset non-spatial?
if (params$SOS1 != 1){
    nonsos_crit <- TRUE
} else {nonsos_crit <- FALSE}

# season onset spatial?
if (params$SOS1 == 1){
    sos_crit <- TRUE
} else {sos_crit <- FALSE}


# climate rule base exists?
if ("ba_2b" %in% rbstacklist3) {
    clim_crit <- TRUE
} else {clim_crit <- FALSE}

# soil physical properties rule base exists?
if ("ba_2c" %in% rbstacklist3) {
    soil_p_crit <- TRUE
  } else {soil_p_crit <- FALSE}

# soil fertility rule base exists?
if ("ba_2d" %in% rbstacklist3) {
    soil_f_crit <- TRUE
} else {soil_f_crit <- FALSE}

# landscape rule base exists?
if ("ba_2e" %in% rbstacklist3) {
    lscape_crit <- TRUE
} else {lscape_crit <- FALSE}

# rainfall rule base exists?
if ("ba_3a" %in% rbstacklist3) {
    prec_crit <- TRUE
} else {prec_crit <- FALSE}

# temperature rule base exists?
if ("ba_3b" %in% rbstacklist3) {
    tmp_crit <- TRUE
} else {tmp_crit <- FALSE}

# socio-economic feasibility rule base exists?
if ("se_1" %in% rbstacklist3) {
    sef_crit <- TRUE
} else {sef_crit <- FALSE}

# farm production feasibility rule base exists?
if ("se_2a" %in% rbstacklist3) {
    fpf_crit <- TRUE
} else {fpf_crit <- FALSE}

# market access rule base exists?
if ("se_2b" %in% rbstacklist3) {
    mktaccess_crit <- TRUE
} else {mktaccess_crit <- FALSE}

# management rule base exists?
if ("se_3a" %in% rbstacklist3) {
    management_crit <- TRUE
} else {management_crit <- FALSE}

# inputs access rule base exists?
if ("se_3b" %in% rbstacklist3) {
    inpaccess_crit <- TRUE
} else {inpaccess_crit <- FALSE}

# extension access rule base exists?
if ("se_4a" %in% rbstacklist3) {
    extaccess_crit <- TRUE
} else {extaccess_crit <- FALSE}

# labour access rule base exists?
if ("se_4b" %in% rbstacklist3) {
    lab_crit <- TRUE
} else {lab_crit <- FALSE}

# fertiliser/pesticides access rule base exists?
if ("se_4c" %in% rbstacklist3) {
    fp_crit <- TRUE
} else {fp_crit <- FALSE}


```



# Load Spatial Data

Here we load all the spatial data. The data are used in different chunks below but it is easier to modify filenames if all the spatial data are imported in the same chunk.

## Vector Data

The vector data include the sub-divisions of the area that is being modelled, and triangulation points if available.

The vector data are not projected and in geojson format. Here they are loaded and projected to the working crs


<div class="fold o">   
```{r i1_i1_spatialdataload_vector_01, cache = FALSE, out.width="100%", include = TRUE, echo=FALSE}


vect_subdiv <- load_vector_data( paste0("subdiv_", params$INN1))

vect_subdiv$id <- seq.int(nrow(vect_subdiv))# add an id field
vect_subdiv$id <- formatC(vect_subdiv$id, width = 2, format = "d", flag = "0") #format the id field

vect_subdiv_extent <- ext(vect_subdiv) # get the extent
nudge_xval <-
  ((vect_subdiv_extent[2] - vect_subdiv_extent[1]) /  (nrow(vect_subdiv) * 2.5))
#cat("nudge_xval =", nudge_xval)
nudge_yval <-
  ((vect_subdiv_extent[4] - vect_subdiv_extent[3]) /  (nrow(vect_subdiv) * 2.5))
#cat("nudge_yval =", nudge_yval)

vect_subdiv_pt <- centroids(vect_subdiv)
expr <- paste0("vect_subdiv_pt$", params$SUBDIV1)
vect_subdiv_pt$subdiv_label <- paste(vect_subdiv_pt$id, "=", eval(parse(text=(expr))))
vect_subdiv_pt$subdiv_label <- factor(vect_subdiv_pt$subdiv_label)

g <- ggplot()
gsubdiv <- add_subdiv_plot(g)
gsubdiv

```
</div>

<div class="fold o">   
```{r i1_i1_spatialdataload_vector_02, cache = FALSE, out.width="100%", include = TRUE, echo=FALSE}

vect_triangulation <- load_vector_data( paste0("triangulation_", params$INN1))

vect_triangulation$id <- seq.int(nrow(vect_triangulation))# add an id field
vect_triangulation$id <- formatC(vect_triangulation$id, width = 2, format = "d", flag = "0") #format the id field

vect_triangulation_extent <- ext(vect_triangulation) # get the extent
nudge_xvaltri <-
  ((vect_triangulation_extent[2] - vect_triangulation_extent[1]) /  (nrow(vect_triangulation) * 2.5))
#cat("nudge_xvaltri =", nudge_xvaltri)
nudge_yvaltri <-
  ((vect_triangulation_extent[4] - vect_triangulation_extent[3]) /  (nrow(vect_triangulation) * 2.5))
#cat("nudge_yvaltri =", nudge_yvaltri)

expr <- paste0("vect_triangulation$", params$TRI1)
vect_triangulation$tri_label <- paste(vect_triangulation$id, "=", eval(parse(text=(expr))))
vect_triangulation$tri_label <- factor(vect_triangulation$tri_label)

g <- ggplot()
gtriangulation <- add_triangulation_plot_no_labels(g)

gtriangulation <- add_subdiv_simple_plot(gtriangulation)
gtriangulation

```
</div>


## Raster Data

The raster spatial data are loaded first.
Only the mask need be in the working crs.

<div class="fold o">   
```{r i1_i1_spatialdataload_raster_01, results='asis', warning=FALSE}

# set the working crs using WKT arguments

wkt_lam <-  paste0(
    "PROJCRS[\"unknown\",
    BASEGEOGCRS[\"unknown\",
        DATUM[\"World Geodetic System 1984\",
            ELLIPSOID[\"WGS 84\",6378137,298.257223563,
                LENGTHUNIT[\"metre\",1]],
            ID[\"EPSG\",6326]],
        PRIMEM[\"Greenwich\",0,
            ANGLEUNIT[\"degree\",0.0174532925199433],
            ID[\"EPSG\",8901]]],
    CONVERSION[\"unknown\",
        METHOD[\"Lambert Azimuthal Equal Area\",
            ID[\"EPSG\",9820]],
        PARAMETER[\"Latitude of natural origin\",",
vect_subdiv_extent[3],
    ",ANGLEUNIT[\"degree\",0.0174532925199433],
            ID[\"EPSG\",8801]],
        PARAMETER[\"Longitude of natural origin\",",
vect_subdiv_extent[1],
    ",ANGLEUNIT[\"degree\",0.0174532925199433],
            ID[\"EPSG\",8802]],
        PARAMETER[\"False easting\",1000000,
            LENGTHUNIT[\"metre\",1],
            ID[\"EPSG\",8806]],
        PARAMETER[\"False northing\",1000000,
            LENGTHUNIT[\"metre\",1],
            ID[\"EPSG\",8807]]],
    CS[Cartesian,2],
        AXIS[\"(E)\",east,
            ORDER[1],
            LENGTHUNIT[\"metre\",1,
                ID[\"EPSG\",9001]]],
        AXIS[\"(N)\",north,
            ORDER[2],
            LENGTHUNIT[\"metre\",1,
                ID[\"EPSG\",9001]]]]"
  )


# project the country boundary to LAM

vect_subdiv_proj <-  project(vect_subdiv, wkt_lam)
vect_subdiv_proj_extent <- terra::ext(vect_subdiv_proj)

# make a basic raster with dimensions with 100m resolution 
# and projected crs 

rast_subdiv_mask_proj_extent <- rast(crs = wkt_lam, extent = vect_subdiv_proj_extent, resolution = params$MASK)

# make the mask based on the country boundary

rast_subdiv_mask_proj <- terra::rasterize(
      vect_subdiv_proj,
      rast_subdiv_mask_proj_extent,
      field = 1,
      background = NA
    ) 


# subset the priorities dataframe to keep only the records that have distinct raster data files

df_raster_data <- droplevels(distinct(df_priorities,
                                      data_file_prefix,
                                      .keep_all = T)) %>% drop_na(data_file_prefix)


# for each record in the df_raster_data data frame use the data file prefix and the raster or brick variable to load the raster data, the name of the raster is generated automatically from the data file name
# these rasters needn't have the same crs as the working crs but must have the crs in the metadata (e.g. geotiff format)

for (i in seq(from = 1,
              to = nrow(df_raster_data),
              by = 1)) {
  assign(
    paste0("rast_", df_raster_data[i, 11]),
    load_raster_data(
      as.character(df_raster_data[i, 11]),
      paste0("rast_", df_raster_data[i, 11])
    )
  )
  cat(paste0("\nrast_", df_raster_data[i, 11], " :"))
  #print(crs(get(paste0(
  #  "rast_", df_raster_data[i, 11]
  #))))
  print(get(paste0(
    "rast_", df_raster_data[i, 11]
  )))
}


```
</div>


# Common spatial resolution and extent

## Mask

Let's start with creating a 'mask', _i.e._, a raster map of the area of interest (1 = area to be modelled, NA = ignored). 

The properties of this map are given below:

<div class="fold o">  
```{r i1_i1_mask01, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE}

if (params$Agg == 1){rast_mask_proj <- rast_subdiv_mask_proj} else {
  rast_mask_proj <- aggregate(rast_subdiv_mask_proj, fact = params$Agg, expand = TRUE)}


g <- base_raster_plot(rast_mask_proj, "layer", 'red', 'blue', paste0("Aggregated mask - Resolution = ", res(rast_mask_proj), "m"))

gsubdivsimple <- add_subdiv_simple_plot(g)
gsubdivsimple

```
</div>

A factor is calculated to determine the area of each raster cell in hectares.

```{r i1_i1_mask02, cache = FALSE, warning=FALSE }

Stat_factor_ha <- ((xres(rast_mask_proj)^2) / 10000) # factor used for statistical calculations divides the area of a raster cell (in m2) by 10000 to give the area of the cell in hectares 

cat(paste(Stat_factor_ha, "hectares in each cell"))

```

This mask designates the locations where predictions should be made, and an empty dataframe (tibble) is created with records for all locations.


<div class="fold o">   
```{r i1_i1_mask03, cache = TRUE, cache.whatever=params$Agg, warning=FALSE }

# only run the models for the areas in the mask

df_irm <- geom(terra::as.points(rast_mask_proj)) %>% as_tibble()

x <-  pull(df_irm, x)
y <-  pull(df_irm, y)
xy <- cbind(x, y)

str(df_irm)

if (params$INT == 1)
  shiny::setProgress(0.17, message = "Resampling data 1st Innovation")  # set progress to 17%
``` 
</div>


## Rough crop, Reproject, Aggregate and Resample

In this section the input spatial data are cropped to the extent of the sub-division boundary, projected if necessary and then aggregated and resampled if necessary.


```{r i1_i1_agg_resample_01, message=FALSE, warning=FALSE, cache=TRUE, out.width="100%", results='hide'}

# do a rough crop of the thematic data for the country extent in the CRS of the thematic data

for (i in seq(from = 1,
              to = nrow(df_raster_data),
              by = 1)) {
  
  temp_crs <- crs(get(paste0("rast_", df_raster_data[i, 11])))
  assign("vect_subdiv_temp_crs", terra::project(vect_subdiv, temp_crs))
  assign("vect_subdiv_temp_crs_extent", terra::ext(vect_subdiv_temp_crs))
    
  assign(
    paste0("rast_", df_raster_data[i, 11], "_roughcrop"),
    crop(get(paste0("rast_", df_raster_data[i, 11])),
      vect_subdiv_temp_crs_extent)
  )  
}

```



<div class="fold o">   
```{r i1_i1_agg_resample_02, cache = TRUE, out.width="100%", results='asis', warning=FALSE, message=FALSE}

# reproject the raster data if necessary

for (i in seq(from = 1,
              to = nrow(df_raster_data),
              by = 1)) {

# compare the crs of the raster with the working crs
# when different project the raster  
  
  if ( paste(crs(get(paste0("rast_", df_raster_data[i, 11])))) %ni% paste(wkt_lam)) {  
  
  cat("different crs - ")  
  assign(
    paste0("rast_", df_raster_data[i, 11], "_prj"),
    raster_project(
      get(paste0("rast_", df_raster_data[i, 11], "_roughcrop")),
      #proj4_lam,
      as.character(df_raster_data[i, 14])
    )
  )  
  
  } else {

   cat("same crs - ") 
# when not different just create a new raster with the same prj suffix  
    assign(
    paste0("rast_", df_raster_data[i, 11], "_prj"),
    get(paste0("rast_", df_raster_data[i, 11], "_roughcrop"))
      )
  }

# calculate aggregate factor for each criterion for both dimensions of the raster (these are the same for a square cell shape)
  
#  cat(paste(df_raster_data[i, 10],"\n"))

  calc_agg_factor <-
    (res(rast_mask_proj) / res(get(paste0(
      "rast_", df_raster_data[i, 11], "_prj"
    ))))
  cat(paste("calculated aggregate factor = ", calc_agg_factor))
  cat("\n")

 if (calc_agg_factor[1] < 1) {
    calc_agg_factor[1] <- 1
    
    # this means that the mask has a higher resolution than the precipitation raster so aggregation is not necessary and the precipitation raster will stay the same resolution
    
#    cat(paste("revised calculated aggregate factor 1 = ", calc_agg_factor[1],"\n"))
  }
  
  
  
  if (calc_agg_factor[2] < 1) {
    calc_agg_factor[2] <- 1
    cat(paste("revised calculated aggregate factor 2 = ", calc_agg_factor[2]))
  }
  
  # for each record in the df_raster_data data frame use the data file prefix to recreate the raster name, and the aggregation and resample functions
#  cat(paste("aggregate and resample"))
  assign(
    paste0("rast_", df_raster_data[i, 11], "_rsmp"),
    agg_resample(
      get(paste0("rast_", df_raster_data[i, 11], "_prj")),
      calc_agg_factor,
      as.character(df_raster_data[i, 13]),
      as.character(df_raster_data[i, 14])
    )
  )
  
#  plot_raster <-
    terra::plot(
      get(paste0("rast_", df_raster_data[i, 11], "_rsmp")),
      main = paste0(
        as.character(df_raster_data[i, 10]),
        "\nagg ",
        as.character(df_raster_data[i, 13]),
        " rsmp ",
        as.character(df_raster_data[i, 14])
      ),
      breaks = 10
   )
  #print(plot_raster)
  

  cat(paste("\nDim = ", dim(get(paste0("rast_", df_raster_data[i, 11], "_rsmp")))))
  cat("\n\n")

#  plot_raster
#  terra::plot(rast_mask_proj, title = "") # this is needed (even if it is not actually plotted) to enable the plot of the raster
  
}


```
</div>

# Requirements for successful production and adoption

In this section the requirements for production and adoption are given in terms of membership functions defined by fuzzy partitions. The membership functions are applied to the data, and can be considered as the lowest level rule bases - seen in the green boxes in the figure of the rule bases above.

The requirements are described and applied first for bio-physical criteria (if defined) and then for socio-economic criteria (if defined).

```{r i1_i1_requirements_themes, results='asis'}

# Each innovation has potentially different criteria and rule bases
# This chunk gets the unique themes which are organised around rule base stacks 
# This new data frame is used to see which themes have criteria for a particular innovation

n_theme <- length(rbstacklist3)

```

```{r i1_i1_requirements_ba01, echo=FALSE, results='asis', eval=ba_crit}

cat("## Bio-physical requirements")

```


```{r i1_i1_requirements_climatic01, echo=FALSE, results='asis', eval=clim_crit}

cat("### Climatic Requirements")

```

<div class="fold o">   
```{r i1_i1_requirements_climatic02, results='asis', eval=clim_crit}

df_criteria_ba3 <-
  subset(df_priorities, grepl("^ba_3", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cba3 <- nrow(df_criteria_ba3)
print(paste(n_cba3, "Climatic criteria: "))

for (i in 1:n_cba3) {
  print(paste(df_criteria_ba3[i, 4]))
  rast_clim_mask <- get(paste0("rast_",df_criteria_ba3[i, 11], "_rsmp"))
  if (paste(df_criteria_ba3[i, 23]) == "m") {
  rast_clim_mask_m <- rast_clim_mask
  names(rast_clim_mask_m) <- c(month.name)
  } else {
  rast_clim_mask_d <- rast_clim_mask
  names(rast_clim_mask_d) <- c(1:36)}
}

# then determine and print the names of the rule bases in the climatic theme
df_rulebases_ba3 <-
  distinct(df_criteria_ba3, rulebase_number, .keep_all = T)
n_rbba3 <- nrow(df_rulebases_ba3)

print(paste(n_rbba3, "Climatic rule bases:"))
for (i in 1:n_rbba3) {
  print(paste(df_rulebases_ba3[i, 2]))
  
  if (paste(df_rulebases_ba3[i, 2]) == "ba_3a") {
    prec_crit <- TRUE
    print("Precipitation criteria exist")
  } else {
    if (paste(df_rulebases_ba3[i, 2]) == "ba_3b") {
      tmp_crit <- TRUE
      print("Temperature criteria exist")
    }
  }
}

```
</div>   


```{r i1_i1_requirements_climatic03, echo=FALSE, results='asis', eval=clim_crit}

cat("If there are climatic criteria that are for specific growth stages and which use monthly or dekadal data then the phenological stages need to be distributed over those periods.")

```


<div class="fold o">   
```{r i1_i1_requirements_phen_stages01, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=clim_crit}

## division by zero rainfall is infinitive, thus edited by Atkilt

if (exists('rast_clim_mask_m')) {
  values(rast_clim_mask_m)[values(rast_clim_mask_m) >= 0] = 0
  values(rast_clim_mask_m)[values(rast_clim_mask_m) < 0] = NA
}

if (exists('rast_clim_mask_d')) {
  values(rast_clim_mask_d)[values(rast_clim_mask_d) >= 0] = 0
  values(rast_clim_mask_d)[values(rast_clim_mask_d) < 0] = NA
}

```
</div>


```{r i1_i1_growth_stages01, echo=FALSE, results='asis'}

cat("#### Growth Stages

Here we load the table of the growth stages.")

```


<div class="fold o"> 
```{r i1_i1_growth_stages02, results='asis'}

# get the growth stages filename using the innovation parameter
growth_stages_filename <-
  as.character(paste("tab_data/input/growth_stages_", params$INN1, ".csv", sep = ""))

df_growth_stages <-  read.csv(here(growth_stages_filename))

df_growth_stages %>%
  kable(digits = 3, caption = "Growth Stage Lengths") %>% kable_styling("striped", full_width = T) %>% print

# create a new table just for where growth stage has requirements
df_growth_stages_req <-
  dplyr::filter(df_growth_stages, (prec_criteria == 1 |
                                  temp_criteria == 1))
df_growth_stages_req_prec <-
  dplyr::filter(df_growth_stages, prec_criteria == 1)
df_growth_stages_req_temp <-
  dplyr::filter(df_growth_stages, temp_criteria == 1)

```
</div>

<div class="fold o"> 
```{r i1_i1_requirements_phen_stages_static01, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=clim_crit, eval=nonsos_crit}

# see if one of the criteria is for the total growing period, if so then generate distribution

# this uses two functions from the irm package called .growth_period_long (for monthly data) and .growth_period_long_dekad (for dekadal data)

# both functions take three arguments: day_begin, and day_end in day numbers (obtained from the growth_stages_req table) and num_years which is calculated based on whether the growing season is spread across more than one calendar year


# for each of the growth stages for which there are requirements create a new raster brick

cat("### Spatially Static Growing Seasons")

  # get the number of variables in growth_stages (excluding sowing/planting date and total length)
  
  # create a list of the growth stages and determine the start and end days of each growth period


phen_tmp <- list()
for (i in 1:(nrow(df_growth_stages) - 2)) {
  phen_tmp[[as.character(df_growth_stages[i + 1, 1])]] <-
    df_growth_stages[i + 1, 3]
}

phen_stages_beg <-
  df_growth_stages$day[1] + c(0, cumsum(phen_tmp)[-length(phen_tmp)])
phen_stages_end <- df_growth_stages$day[1] + cumsum(phen_tmp)
names(phen_stages_beg) <- names(phen_stages_end)

# add the total to the growth stages

phen_stages_beg[["total"]] <- df_growth_stages[1, 2]
phen_stages_end[["total"]] <-
  sum(df_growth_stages[1, 2], df_growth_stages[2, 3])

rbind(start = phen_stages_beg, end = phen_stages_end) %>%
  as.data.frame %>%
  kable(caption = "Growth Stage Days") %>% kable_styling("striped", full_width = T)  %>% print

num_years <- ceiling(phen_stages_end[["total"]] / 365)
cat(paste("Growth Stages span", num_years, "calendar years"))

```
</div>

<div class="fold o"> 
```{r i1_i1_requirements_phen_stages_static02, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=clim_crit, eval=nonsos_crit}

# monthly distribution
if (exists('rast_clim_mask_m')) {
  for (i in 1:(nrow(df_growth_stages_req))) {
    period_name <- as.character(df_growth_stages_req[i, 1])
    v_m <-
      .growth_period_long(phen_stages_beg[period_name], phen_stages_end[period_name], num_years)
    assign(paste0("rast_period_m_", df_growth_stages_req[i, 1]),
           rast_clim_mask_m %>%
             app(function(x) {
               ifelse(is.na(x), NA_real_, v_m)
             }))
    
#    plot_raster <-
      plot(
        get(paste0("rast_period_m_", df_growth_stages_req[i, 1])),
        maxnl = 12,
        breaks = c(0, 0.25, 0.5, 0.75, 1),
        axes = F,
        plg = list(cex = 1, title = paste0(df_growth_stages_req[i, 1]))
      )
#    print(plot_raster)
  }
}
# dekadal distribution
if (exists('rast_clim_mask_d')) {
  for (i in 1:(nrow(df_growth_stages_req))) {
    period_name <- as.character(df_growth_stages_req[i, 1])
    v_d <-
      .growth_period_long_dekad(phen_stages_beg[period_name], phen_stages_end[period_name], num_years)
    assign(paste0("rast_period_d_", df_growth_stages_req[i, 1]),
           rast_clim_mask_d %>%
             app(function(x) {
               ifelse(is.na(x), NA_real_, v_d)
             }))
    
#    plot_raster <-
      plot(
        get(paste0("rast_period_d_", df_growth_stages_req[i, 1])),
        maxnl = 36,
        breaks = c(0, 0.25, 0.5, 0.75, 1),
        axes = F,
        plg = list(cex = 1, title = paste0(df_growth_stages_req[i, 1]))
      )

  }
}

``` 
</div>

```{r i1_i1_requirements_sowing_dates_title, echo=FALSE, results='asis', eval=clim_crit,  eval=sos_crit}

cat("### Spatially Dynamic Growing Seasons")

```

```{r i1_i1_requirements_sowing_dates_intro, echo=FALSE, results='asis', eval=clim_crit,  eval=sos_crit}

cat("For climatic criteria for specific growth stages which use monthly or dekadal data, and which have a spatially variable growth period the phenological stages need to be distributed over those periods and spatially.\n
\n
\n
The maps below give the distribution of each phenological stage over the months.\n
\n
I use the same function as Walvoort (here called growth_period_long_tbl and growth_period_long_dekad_tbl), and apply this on a cell-by-cell basis using the start and end days for each cell.\n
\n
When the function is applied to the tibble using 'apply' it produces a x *x* 12/36 matrix. I transpose this matrix, append it to the original tibble and create a temporary data frame. I save this as a csv, convert this to a spatvector object and create spatrasters for each month/dekad *x* growing period combination. I join the individual rasters in a SpatRaster brick for each growing period - to be used later.")

```


<div class="fold o">   
```{r i1_i1_sowing_dates_sos_onsetdata_01, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=clim_crit, eval=sos_crit}


# get onset for area of interest
rast_filename_onset <-
  as.character(paste("spatial_data/input/rast_onset_",
                     params$INN1,
                     ".tif",
                     sep = ""))
assign(paste0("rast_onset"), rast(here(rast_filename_onset)))
names(rast_onset) <- c("onset")
rast_onset

g <- base_raster_plot(rast_onset, "onset", 'red', 'blue', "Season onset day number (rast_onset)" )

gsubdivsimple <- add_subdiv_simple_plot(g)
gsubdivsimple
```
</div>


<div class="fold o">   
```{r i1_i1_sowing_dates_sos_onsetdata_02, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=clim_crit, eval=sos_crit}

# project onset
rast_onset_proj <- project(rast_onset, rast_mask_proj, method = "near")
rast_onset_proj

g <- base_raster_plot(rast_onset_proj, "onset", 'red', 'blue', "Season onset day number (rast_onset_proj)" )

gsubdivsimple <- add_subdiv_simple_plot(g)
gsubdivsimple

```
</div>


<div class="fold o">   
```{r i1_i1_sowing_dates_sos_onsetdata_03, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=clim_crit, eval=sos_crit}

# do a rough crop to boundaries
rast_onset_crop <- crop(rast_onset_proj, rast_mask_proj)
rast_onset_crop

g <- base_raster_plot(rast_onset_crop, "onset", 'red', 'blue', "Season onset day number (rast_onset_crop)" )

gsubdivsimple <- add_subdiv_simple_plot(g)
gsubdivsimple

```
</div>


<div class="fold o">   
```{r i1_i1_sowing_dates_sos_onsetdata_04, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=clim_crit, eval=sos_crit}

rast_onset_crop_rsmp <- resample(rast_onset_crop, rast_mask_proj,  method="near")
rast_onset_crop_rsmp


g <- base_raster_plot(rast_onset_crop_rsmp, "onset", 'red', 'blue', "Season onset day number (rast_onset_crop_rsmp)" )

gsubdivsimple <- add_subdiv_simple_plot(g)
gsubdivsimple
```
</div>

<div class="fold o">   
```{r i1_i1_sowing_dates_sos_onsetdata_05, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=clim_crit, eval=sos_crit}

# convert to df
df_onset <- as.data.frame(rast_onset_crop_rsmp, xy=TRUE, cells=TRUE, na.rm=NA)
df_onset <- mutate(df_onset, onset = as.integer(onset))

```

<div class="fold o">   
```{r i1_i1_sowing_dates_sos_transpose, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=clim_crit, eval=sos_crit}

df_growth_stages_lengths <- df_growth_stages[-1, ]
#df_growth_stages_lengths

df_growth_stages_lengths1 <- t(select(df_growth_stages_lengths, name, length)) %>% data.frame()
#df_growth_stages_lengths1

df_growth_stages_lengths2 <- setNames(df_growth_stages_lengths1, df_growth_stages_lengths[,1])
#df_growth_stages_lengths2

df_growth_stages_lengths3 <- df_growth_stages_lengths2[-1, ] 
#df_growth_stages_lengths3

df_growth_stages_lengths3[] <- lapply(df_growth_stages_lengths3, as.integer)
df_growth_stages_lengths3 %>%
  kable(caption = "Growth Stage Days") %>% kable_styling("striped", full_width = T)  #%>% print

```
</div>


</div> 

<div class="fold o">   
```{r i1_sowing_dates_sos_onsetdata_06, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=clim_crit, eval=sos_crit}

# add the growth stage lengths to the df
for (i in 1:(nrow(df_growth_stages_lengths))) {
  period_name <- as.character(df_growth_stages_lengths[i, 1])
#  cat(paste(period_name))
#  cat(eval(parse(text = paste0("df_growth_stages_lengths3$", period_name))))
  df_onset <-  mutate(df_onset, !!as.character(paste0(period_name,"_l")) :=  eval(parse(text = paste0("df_growth_stages_lengths3$", period_name))), .keep = c("all"))
} 


# add the start day for the first growth stage (which is the onset)

first_period_name <- as.character(df_growth_stages_lengths[1, 1])
#cat(paste(first_period_name))
df_onset <-
  mutate(df_onset,!!as.character(paste0(first_period_name, "_s")) :=  eval(parse(text = paste0(
    "df_onset$onset"
  ))),
  .keep = c("all"))

# add the start days for each of the growth stages (excluding the first which is the onset)

for (i in 1:(nrow(df_growth_stages_lengths)- 2) ) {
  
#  cat(paste(i))
      
  previous_period_name <- as.character(df_growth_stages_lengths[i, 1])
#  cat(paste("Prev = ", previous_period_name))
#  cat("\n")
  period_name <- as.character(df_growth_stages_lengths[i + 1, 1])
#  cat(paste("Current = ", period_name))
#  cat("\n")
#  cat(paste0("df_growth_stages_lengths3$", period_name))
#  cat(paste(parse(text =paste0("df_onset$", previous_period_name,"_s"))))
#  cat("\n")
#  cat(paste(parse(text =paste0("df_onset$", previous_period_name,"_l"))))
#  cat("\n\n")
 
eval_expr_1 <- eval(parse(text =paste0("df_onset$", previous_period_name, "_s + df_onset$", previous_period_name,"_l")))

  df_onset <-
    mutate(df_onset, !!as.character(paste0(period_name, "_s")) :=  eval_expr_1,
           .keep = c("all"))

}

# add the end days for each of the growth stages

for (i in 1:(nrow(df_growth_stages_lengths) - 1) ) {
  
#  cat(paste(i))
      
#  previous_period_name <- as.character(df_growth_stages_lengths[i, 1])
#  cat(paste("Prev = ", previous_period_name))
#  cat("\n")
  period_name <- as.character(df_growth_stages_lengths[i, 1])
#  cat(paste("Current = ", period_name))
#  cat("\n")
#  cat(paste0("df_growth_stages_lengths3$", period_name))
#  cat(paste(parse(text =paste0("df_onset$", period_name,"_s"))))
#  cat("\n")
#  cat(paste(parse(text =paste0("df_onset$", period_name,"_l"))))
#  cat("\n\n")
 
eval_expr_2 <- eval(parse(text =paste0("df_onset$", period_name, "_s + df_onset$", period_name,"_l - 1")))

  df_onset <-
    mutate(df_onset, !!as.character(paste0(period_name, "_e")) :=  eval_expr_2,
           .keep = c("all"))

}  
  
onset_max <- max(select(df_onset, -cell, -x, -y)) # gets the maximum value of the julian day numbers
num_years <- max(ceiling(onset_max / 365))

cat(paste("Growth Stages span", num_years, "calendar years"))

```
</div>

<div class="fold o">
```{r i1_sowing_dates_sos_maps_m, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=clim_crit, eval=sos_crit}

# to reduce unnecessary processing follow these steps
# for each growth stage:

# (1) does the monthly and/or dekad raster mask exist on file?
#   YES - (i) load raster file to env
#         (ii) plot raster file
#         (iii) move to next growth stage or next chunk
#   NO -  (i) go to (2)

# (2) does the monthly and/or dekad raster mask csv exist on file?
#   YES - (i) load csv file to env as vect
#         (ii) rasterize vect
#         (iii) write raster to file
#         (iv) go to (1)
#   NO -  (i) go to (3)

# (3) does the monthly and/or dekad raster mask df exist in the env?
#   YES - (i) write df to file as csv
#         (ii) go to (2)
#   NO -  (i) go to (4)

# (4) does the monthly and/or dekad raster mask matrix exist in the env?
#   YES - (i) join the matrix to the onset df
#         (ii) write df to file as csv
#         (iii) go to (3)
#   NO -  (i) create the matrix using the growth_period_long functions
#         (ii) join the matrix to the onset df
#         (iii) go to (4)

if (exists('rast_clim_mask_m')) {
  cat(paste("\n1 Monthly data exist"))
    
  # set static vectors of days and months
  days <- 1:365
  day_months <- days %>% as.character %>% as.Date("%j") %>% 
    format("%m") %>% as.integer
  months <- rep.int(day_months, num_years)
  
  
  for (i in 1:(nrow(df_growth_stages_lengths))) {
    period_name <- as.character(df_growth_stages_lengths[i, 1])
    cat(paste("\nCurrent growth stage = ", period_name))
    
    rast_filename_m <-
      as.character(paste0(
        "spatial_data/output/rast_",
        period_name,
        "_m_",
        params$INN1, "_", params$MASK,
        ".tif"
      ))
    
    if (!file.exists(here(rast_filename_m))) {
      cat(paste("\n2 No spatraster"))
      
      if (!exists(paste0("vect_", period_name, "_m"))) {
        cat(paste("\n3 No spatvector"))
        
        csv_filename_m <-
          as.character(
            paste(
              "tab_data/output/df_onset_",
              period_name,
              "_m_",
              params$INN1, "_", params$MASK,
              ".csv",
              sep = ""
            )
          )
        
        if (!file.exists(here(csv_filename_m))) {
          cat(paste("\n4 No csv data"))
          
          if (!exists(paste0("df_onset_", period_name, "_m"))) {
            cat(paste("\n5 No df"))
            
            if (!exists(paste0(period_name, "_matrix_days_m"))) {
              cat(paste("\n6 No matrix"))
              
              if (period_name == "total") {
                expr_3_m <- parse(
                  text = paste0(
                    "t(apply(df_onset, 1, .growth_period_long_tbl_short, day_begin = \"onset\", day_end = \"",
                    df_growth_stages_lengths[nrow(df_growth_stages_lengths) - 1, 1],
                    "_e\", num_years = num_years))"
                  )
                )
              } else {
                expr_3_m <- parse(
                  text = paste0(
                    "t(apply(df_onset, 1, .growth_period_long_tbl_short, day_begin = \"",
                    period_name,
                    "_s\",
        day_end = \"",
        period_name,
        "_e\", num_years = num_years))"
                  )
                )
              }
              
              assign(paste0(period_name, "_matrix_days_m"),
                     eval(expr_3_m))
                            
                            expr_3_m2 <- parse(
                  text = paste0(period_name, "_matrix_days_m * 1000"))
              
              assign(paste0(period_name, "_matrix_days_m"), eval(expr_3_m2))
              
              eval(parse(text = paste0(
                "mode(", period_name, "_matrix_days_m) <- \"integer\""
              )))
              
              cat(paste("\n-6"))
            }
            
            
            assign(paste0("df_onset_", period_name, "_m"),
                   data.frame(df_onset, get(
                     paste0(period_name, "_matrix_days_m")
                   )))
            
            cat(paste("\n-5"))
          }
          
          rm(list = paste0(period_name, "_matrix_days_m")) # remove matrix when df created
          
          write.csv(get(paste0("df_onset_", period_name, "_m")),
                    here(csv_filename_m))
          
          cat(paste("\n-4"))
        }
        rm(list = paste0("df_onset_", period_name, "_m")) # remove df when csv created
        assign(paste0("vect_", period_name, "_m"),
               vect(
                 read_csv(here(csv_filename_m), show_col_types = FALSE),
                 geom = c("x", "y"),
                 crs = wkt_lam
               ))
        cat(paste("\n-3"))
      }
      
      
      assign(paste0("list_rast_", period_name, "_m"),
             list())
      
      #create an empty raster
      assign(paste0("rast_", period_name, "_m"), rast())
      
      for (j in 1:12) {
        assign(
          paste0("rast_", period_name, "_m_", j),
          rasterize(get(
            paste0("vect_", period_name, "_m")
          ), rast_clim_mask_m, field = paste0("X", j))
        )
        
        assign(paste0("list_rast_", period_name, "_m"),
               append(get(
                 paste0("list_rast_", period_name, "_m")
               ), paste0("rast_", period_name, "_m_", j)))
        expr_5_m <-
          parse(text = paste0(
            "add(rast_",
            period_name,
            "_m) <- (rast_",
            period_name,
            "_m_",
            j,
            ")"
          ))
        
        eval(expr_5_m)
        rm(list = paste0("rast_", period_name, "_m_", j)) # remove month rast when added to brick
      }
      
      rm(list = paste0("vect_", period_name, "_m")) # remove vect when raster created
      writeRaster(get(paste0("rast_", period_name, "_m")), here(rast_filename_m), overwrite = TRUE)
      cat(paste("\n-2"))
    }
    
    assign(paste0("rast_", period_name, "_m"), rast(here(rast_filename_m)))
    cat(paste0("\n", rast_filename_m))
    
    expr_6_m <-
      parse(
        text = paste0(
          "names(rast_",
          period_name,
          "_m) <- c(\"January\", \"February\", \"March\", \"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\")"
        )
      )
    
    eval(expr_6_m)
    
#    plot(
#      get(paste0("rast_", period_name, "_m")),
#      maxnl = 12,
#      breaks = c(0, 0.25, 0.5, 0.75, 1),
#      axes = F,
#      plg = list(cex = 1, title = paste0(period_name))
#    )
    
  }
  cat(paste("\n-1"))
}

```
</div>

<div class="fold o">
```{r i1_sowing_dates_sos_maps_d, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=clim_crit, eval=sos_crit}

# to reduce unnecessary processing follow these steps
# for each growth stage:

# (1) does the monthly and/or dekad raster mask exist on file?
#   YES - (i) load raster file to env
#         (ii) plot raster file
#         (iii) move to next growth stage or next chunk
#   NO -  (i) go to (2)

# (2) does the monthly and/or dekad raster mask csv exist on file?
#   YES - (i) load csv file to env as vect
#         (ii) rasterize vect
#         (iii) write raster to file
#         (iv) go to (1)
#   NO -  (i) go to (3)

# (3) does the monthly and/or dekad raster mask df exist in the env?
#   YES - (i) write df to file as csv
#         (ii) go to (2)
#   NO -  (i) go to (4)

# (4) does the monthly and/or dekad raster mask matrix exist in the env?
#   YES - (i) join the matrix to the onset df
#         (ii) write df to file as csv
#         (iii) go to (3)
#   NO -  (i) create the matrix using the growth_period_long functions
#         (ii) join the matrix to the onset df
#         (iii) go to (4)


if (exists('rast_clim_mask_d')) {
  cat(paste("\n1 Dekad data exist"))
  
  # set static vectors of days and dekads
  days <- 1:365
  day_dekads <- days %>% as.character %>% as.Date("%j") %>%
    dekad(type = "year") %>% as.integer
  dekads <- rep.int(day_dekads, num_years)
  
  
  for (i in 1:(nrow(df_growth_stages_lengths))) {
    period_name <- as.character(df_growth_stages_lengths[i, 1])
    cat(paste("\nCurrent growth stage = ", period_name))
    
    
    rast_filename_d <-
      as.character(paste0(
        "spatial_data/output/rast_",
        period_name,
        "_d_",
        params$INN1, "_", params$MASK, 
        ".tif"
      ))
    
    if (!file.exists(here(rast_filename_d))) {
      cat(paste("\n2 No spatraster"))
      
      if (!exists(paste0("vect_", period_name, "_d"))) {
        cat(paste("\n3 No spatvector"))
        
        csv_filename_d <-
          as.character(
            paste(
              "tab_data/output/df_onset_",
              period_name,
              "_d_",
              params$INN1, "_", params$MASK,
              ".csv",
              sep = ""
            )
          )
        
        if (!file.exists(here(csv_filename_d))) {
          cat(paste("\n4 No csv data"))
          
          if (!exists(paste0("df_onset_", period_name, "_d"))) {
            cat(paste("\n5 No df"))
            
            if (!exists(paste0(period_name, "_matrix_days_d"))) {
              cat(paste("\n6 No matrix"))
              
              if (period_name == "total") {
                expr_3_d <- parse(
                  text = paste0(
                    "t(apply(df_onset, 1, .growth_period_long_dekad_tbl_short, day_begin = \"onset\", day_end = \"",
                    df_growth_stages_lengths[nrow(df_growth_stages_lengths) - 1, 1],
                    "_e\", num_years = num_years))"
                  )
                )
              } else {
                expr_3_d <- parse(
                  text = paste0(
                    "t(apply(df_onset, 1, .growth_period_long_dekad_tbl_short, day_begin = \"",
                    period_name,
                    "_s\",
        day_end = \"",
        period_name,
        "_e\", num_years = num_years))"
                  )
                )
              }
              
              assign(paste0(period_name, "_matrix_days_d"),
                     eval(expr_3_d))
              expr_3_d2 <- parse(
                  text = paste0(period_name, "_matrix_days_d * 1000"))
              
              assign(paste0(period_name, "_matrix_days_d"), eval(expr_3_d2))
              
              eval(parse(text = paste0(
                "mode(", period_name, "_matrix_days_d) <- \"integer\""
              )))
              
              cat(paste("\n-6"))
            }
            
            assign(paste0("df_onset_", period_name, "_d"),
                   data.frame(df_onset, get(
                     paste0(period_name, "_matrix_days_d")
                   )))
            
            cat(paste("\n-5"))
          }
          rm(list = paste0(period_name, "_matrix_days_d")) # remove matrix when df created
          write.csv(get(paste0("df_onset_", period_name, "_d")),
                    here(csv_filename_d))
          
          cat(paste("\n-4"))
        }
        rm(list = paste0("df_onset_", period_name, "_d")) # remove df when csv created
        assign(paste0("vect_", period_name, "_d"),
               vect(
                 read_csv(here(csv_filename_d), show_col_types = FALSE),
                 geom = c("x", "y"),
                 crs = wkt_lam
               ))
        cat(paste("\n-3"))
      }
      assign(paste0("list_rast_", period_name, "_d"),
             list())
      
      #create an empty raster
      assign(paste0("rast_", period_name, "_d"), rast())
      
      for (j in 1:36) {
        assign(
          paste0("rast_", period_name, "_d_", j),
          rasterize(get(
            paste0("vect_", period_name, "_d")
          ), rast_clim_mask_d, field = paste0("X", j))
        )
        
        assign(paste0("list_rast_", period_name, "_d"),
               append(get(
                 paste0("list_rast_", period_name, "_d")
               ), paste0("rast_", period_name, "_d_", j)))
        expr_5_d <-
          parse(text = paste0(
            "add(rast_",
            period_name,
            "_d) <- (rast_",
            period_name,
            "_d_",
            j,
            ")"
          ))
        
        eval(expr_5_d)
        rm(list = paste0("rast_", period_name, "_d_", j)) # remove dekad rast when added to brick
        
      }
      
      rm(list = paste0("vect_", period_name, "_d")) # remove vect when raster created
      writeRaster(get(paste0("rast_", period_name, "_d")), here(rast_filename_d), overwrite = TRUE)
      cat(paste("\n-2"))
    }
    
    assign(paste0("rast_", period_name, "_d"), rast(here(rast_filename_d)))
    cat(paste0("\n", rast_filename_d))
    
    expr_6_d <-
      parse(
        text = paste0(
          "names(rast_",
          period_name,
          "_d) <- c(\"Ja1\", \"Ja2\", \"Ja3\", \"Fe1\", \"Fe2\", \"Fe3\",\"Mr1\", \"Mr2\", \"Mr3\",\"Ap1\", \"Ap2\", \"Ap3\",\"My1\", \"My2\", \"My3\",\"Jn1\", \"Jn2\", \"Jn3\",\"Jl1\",\"Jl2\", \"Jl3\",\"Ag1\",\"Ag2\", \"Ag3\",\"Sp1\",\"Sp2\", \"Sp3\",\"Oc1\",\"Oc2\", \"Oc3\",\"No1\",\"No2\", \"No3\",\"De1\",\"De2\", \"De3\")"
        )
      )
    
    eval(expr_6_d)
    
#    plot(
#      get(paste0("rast_", period_name, "_d")),
#      maxnl = 36,
#      breaks = c(0, 0.25, 0.5, 0.75, 1),
#      axes = F,
#      plg = list(cex = 1, title = paste0(period_name))
#    )
    
  }
  cat(paste("\n-1"))
}

```
</div>

<div class="fold o">   
```{r i1_requirements_phen_stages01_sos_m, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=clim_crit, eval=sos_crit}

##-- monthly distribution --

if (exists('rast_clim_mask_m')) {
  for (i in 1:(nrow(df_growth_stages_req))) {
    period_name <- as.character(df_growth_stages_req[i, 1])
    cat("period_name = ", period_name, "\n")
    
    
    # load growth period rasters
    rast_filename_m <-
      as.character(paste0(
        "spatial_data/output/rast_",
        period_name,
        "_m_",
        params$INN1, "_", params$MASK,
        ".tif"
      ))
    
    assign(paste0("rast_period_m_", period_name, "_original"),
           rast(here(rast_filename_m))/1000) # divide by 1000 because the values were multiplied by 1000 when creating the matrix
    
    # reproject growth period rasters
    
    assign(
      paste0("rast_period_m_", period_name, "_prj"),
      terra::project(get(
        paste0("rast_period_m_", period_name, "_original")
      ),   rast_mask_proj, "near")
    )
    
    # aggregate if necessary
    
    #calc_agg_factor_m <-
    #    (res(rast_mask_proj) / res(rast_period_m_total_prj))
    #  cat(paste("calculated aggregate factor m = ", calc_agg_factor_m))
    
    calc_agg_factor_m <-
      (res(rast_mask_proj) / res(get(
        paste0("rast_period_m_", period_name, "_prj")
      )))
    
    cat(paste("calculated aggregate factor m = ", calc_agg_factor_m))
    
    
    if (calc_agg_factor_m[1] < 1) {
      calc_agg_factor_m[1] <- 1
      
      # this means that the mask has a higher resolution than the precipitation raster so aggregation is not necessary and the precipitation raster will stay the same resolution
      
      cat(paste(
        "revised calculated aggregate factor m1 = ",
        calc_agg_factor_m[1]
      ))
    }
    cat("\n")
    
    if (calc_agg_factor_m[2] < 1) {
      calc_agg_factor_m[2] <- 1
      cat(paste(
        "revised calculated aggregate factor m2 = ",
        calc_agg_factor_m[2]
      ))
    }
    
    # resample
    
    cat(paste("aggregate and resample"))
    
    #    rast_period_m_total <-
    #    agg_resample(
    #      rast_period_m_total_prj,
    #      calc_agg_factor_m, "modal", "near")
    
    assign(
      paste0("rast_period_m_", period_name),
      agg_resample(get(
        paste0("rast_period_m_", period_name, "_prj")
      ),
      calc_agg_factor_m, "modal", "near")
    )
    
    # plot
    
    expr_7_m <-
      parse(
        text = paste0(
          "names(rast_period_m_",
          period_name,
          ") <- c(\"January\", \"February\", \"March\", \"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\")"
        )
      )
    
    eval(expr_7_m)
    plot(
      get(paste0("rast_period_m_", period_name)),
      maxnl = 12,
      breaks = c(0, 0.25, 0.5, 0.75, 1),
      axes = F,
      plg = list(cex = 1, title = paste0(period_name))
    )
    
  }
}

```  
</div>    
 
<div class="fold o">   
```{r i1_requirements_phen_stages01_sos_d, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=clim_crit, eval=sos_crit}

# dekadal growth stages have been pre-modelled for the spatial onset of season

# for each of the growth stages for which there are requirements create a new raster brick

##-- dekadal distribution --


if (exists('rast_clim_mask_d')) {
  for (i in 1:(nrow(df_growth_stages_req))) {
    period_name <- as.character(df_growth_stages_req[i, 1])
    cat("period_name = ", period_name, "\n")
    
    
    # load growth period rasters
    rast_filename_d <-
      as.character(paste0(
        "spatial_data/output/rast_",
        period_name,
        "_d_",
        params$INN1, "_", params$MASK,
        ".tif"
      ))
    
    assign(paste0("rast_period_d_", period_name, "_original"),
           rast(here(rast_filename_d))/1000) # divide by 1000 because the values were multiplied by 1000 when creating the matrix
    
    # reproject growth period rasters
    
    assign(
      paste0("rast_period_d_", period_name, "_prj"),
      terra::project(get(
        paste0("rast_period_d_", period_name, "_original")
      ),   rast_mask_proj, "near")
    )
    
    # aggregate if necessary
    
    #calc_agg_factor_d <-
    #    (res(rast_mask_proj) / res(rast_period_d_total_prj))
    #  cat(paste("calculated aggregate factor m = ", calc_agg_factor_d))
    
    calc_agg_factor_d <-
      (res(rast_mask_proj) / res(get(
        paste0("rast_period_d_", period_name, "_prj")
      )))
    
    cat(paste("calculated aggregate factor d = ", calc_agg_factor_d))
    
    
    if (calc_agg_factor_d[1] < 1) {
      calc_agg_factor_d[1] <- 1
      
      # this means that the mask has a higher resolution than the precipitation raster so aggregation is not necessary and the precipitation raster will stay the same resolution
      
      cat(paste(
        "revised calculated aggregate factor d1 = ",
        calc_agg_factor_d[1]
      ))
    }
    cat("\n")
    
    if (calc_agg_factor_d[2] < 1) {
      calc_agg_factor_d[2] <- 1
      cat(paste(
        "revised calculated aggregate factor d2 = ",
        calc_agg_factor_d[2]
      ))
    }
    
    # resample
    
    cat(paste("aggregate and resample"))
    
    #    rast_period_d_total <-
    #    agg_resample(
    #      rast_period_d_total_prj,
    #      calc_agg_factor_d, "modal", "near")
    
    assign(
      paste0("rast_period_d_", period_name),
      agg_resample(get(
        paste0("rast_period_d_", period_name, "_prj")
      ),
      calc_agg_factor_d, "modal", "near")
    )
    
    # plot
    
    expr_7_d <-
      parse(
        text = paste0(
          "names(rast_period_d_",
          period_name,
          ") <- c(\"Ja1\", \"Ja2\", \"Ja3\", \"Fe1\", \"Fe2\", \"Fe3\",\"Mr1\", \"Mr2\", \"Mr3\",\"Ap1\", \"Ap2\", \"Ap3\",\"My1\", \"My2\", \"My3\",\"Jn1\", \"Jn2\", \"Jn3\",\"Jl1\",\"Jl2\", \"Jl3\",\"Ag1\",\"Ag2\", \"Ag3\",\"Sp1\",\"Sp2\", \"Sp3\",\"Oc1\",\"Oc2\", \"Oc3\",\"No1\",\"No2\", \"No3\",\"De1\",\"De2\", \"De3\")"
        )
      )
    
    eval(expr_7_d)
    plot(
      get(paste0("rast_period_d_", period_name)),
      maxnl = 36,
      breaks = c(0, 0.25, 0.5, 0.75, 1),
      axes = F,
      plg = list(cex = 1, title = paste0(period_name))
    )
    
  }
}

```     
    
 
</div>

```{r i1_requirements_prec01, echo=FALSE, results='asis', eval=prec_crit, eval=clim_crit}

cat("#### Precipitation

By combining precipitation in each month and the phenological stages above, we can derive the precipitation for each phenological stage that has requirements.")

```


<div class="fold o">   
```{r i1_requirements_prec02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=prec_crit, eval=clim_crit}

df_criteria_ba3a <-
    dplyr::filter(df_criteria_ba3, grepl("^ba_3a", rulebase_stack) & temp_resolution == "m") # filter precipitation criteria
  
  for (i in 1:nrow(df_growth_stages_req_prec)) {
        period_name <- as.character(df_growth_stages_req_prec[i, 1])
#      print(period_name)
      if (sum(df_criteria_ba3a[i, 'phen_stage'] == period_name, na.rm = TRUE) == 1) {
        print(paste0("period_name = ", as.character(period_name)))
        crit_rownum <-
          which(df_criteria_ba3a$phen_stage == period_name)
        assign(paste0("rast_",df_criteria_ba3a[crit_rownum, 11], "_rsmp_", df_growth_stages_req_prec[i, 1]),
               sum(get(
                 paste0("rast_",df_criteria_ba3a[crit_rownum, 11], "_rsmp")
               ) * get(
                 paste0("rast_period_", df_growth_stages_req_prec[i, 1])
               )))
        print(paste0("rast_", df_criteria_ba3a[crit_rownum, 11], "_rsmp_", df_growth_stages_req_prec[i, 1]))
#        plot_raster <-
          plot(get(
            paste0("rast_", df_criteria_ba3a[crit_rownum, 11], "_rsmp_", df_growth_stages_req_prec[i, 1])
          ),
          main = paste0("rast_period_m_",
                         as.character(df_growth_stages_req_prec[i, 1])))
#        print(plot_raster)
        
        
        new_col <-
          get(paste0("rast_", df_criteria_ba3a[crit_rownum, 11], "_rsmp_", df_growth_stages_req_prec[i , 1])) %>% terra::extract(xy) # extract the raster values using xy points
        
        new_col <- new_col[[1]]
        
        df_irm <- dplyr::select(df_irm, -any_of(c(as.character(paste0(df_criteria_ba3a[crit_rownum, 3]))))) # remove column if name already exists
        
        df_irm <-
          mutate(df_irm,!!as.character(paste0(df_criteria_ba3a[crit_rownum, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm tibble, this needs to be dynamic so uses the !! and := operators
        
        
      } else {
        print(sum(df_criteria_ba3a[, 'phen_stage'] == period_name, na.rm = TRUE))
      }
    }

df_criteria_ba3a <-
    dplyr::filter(df_criteria_ba3, grepl("^ba_3a", rulebase_stack) & temp_resolution == "d") # filter precipitation criteria
  
  for (i in 1:nrow(df_growth_stages_req_prec)) {
        period_name <- as.character(df_growth_stages_req_prec[i, 1])
#      print(period_name)
      if (sum(df_criteria_ba3a[i, 'phen_stage'] == period_name, na.rm = TRUE) == 1) {
        print(paste0("period_name = ", as.character(period_name)))
        crit_rownum <-
          which(df_criteria_ba3a$phen_stage == period_name)
        assign(paste0("rast_", df_criteria_ba3a[crit_rownum, 11], "_rsmp_", df_growth_stages_req_prec[i, 1]),
               sum(get(
                 paste0("rast_", df_criteria_ba3a[crit_rownum, 11], "_rsmp")
               ) * get(
                 paste0("rast_period_d_", df_growth_stages_req_prec[i, 1])
               )))
        print(paste0("rast_", df_criteria_ba3a[crit_rownum, 11], "_rsmp_", df_growth_stages_req_prec[i, 1]))
#        plot_raster <-
          plot(get(
            paste0("rast_", df_criteria_ba3a[crit_rownum, 11], "_rsmp_", df_growth_stages_req_prec[i, 1])
          ),
          main = paste0("rast_period_d_",
                         as.character(df_growth_stages_req_prec[i, 1])))
#        print(plot_raster)
        
        
        new_col <-
          get(paste0("rast_", df_criteria_ba3a[crit_rownum, 11], "_rsmp_", df_growth_stages_req_prec[i , 1])) %>% terra::extract(xy) # extract the raster values using xy points
        
        new_col <- new_col[[1]]
        
        df_irm <- dplyr::select(df_irm, -any_of(c(as.character(paste0(df_criteria_ba3a[crit_rownum, 3]))))) # remove column if name already exists
        
        df_irm <-
          mutate(df_irm,!!as.character(paste0(df_criteria_ba3a[crit_rownum, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm tibble, this needs to be dynamic so uses the !! and := operators
        
        
      } else {
        print(sum(df_criteria_ba3a[, 'phen_stage'] == period_name, na.rm = TRUE))
      }
    }

``` 
</div>

```{r i1_requirements_prec03, echo=FALSE, results='asis', eval=prec_crit, eval=clim_crit}

cat("##### Precipitation optimality

We used the requirements to construct fuzzy partitions and the rulebases.")

```


<div class="fold o">   
```{r i1_requirements_prec04, cache = TRUE, cache.whatever=params$Agg, out.width="100%", fig.show="hold", warning=FALSE, eval=prec_crit, eval=clim_crit}

for (i in 1:(nrow(df_criteria_ba3a))) {
  if (!is.na(df_criteria_ba3a[i, 18])) {
    # for those criteria with three proposition values
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_criteria_ba3a[i, 16]),
        as.character(df_criteria_ba3a[i, 17]),
        as.character(df_criteria_ba3a[i, 18])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        as.character(df_criteria_ba3a[i, 19]),
        as.character(df_criteria_ba3a[i, 20]),
        as.character(df_criteria_ba3a[i, 21])
      )
    # get  the 2 crossover points
    cross_points <-
      c(df_criteria_ba3a[i, 6],
        df_criteria_ba3a[i, 7])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_criteria_ba3a[i, 8],
        df_criteria_ba3a[i, 9])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_criteria_ba3a[i, 6] - df_criteria_ba3a[i, 8]),
        (df_criteria_ba3a[i, 7] + df_criteria_ba3a[i, 9]))
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    prop_levels <-
      c(as.character(df_criteria_ba3a[i, 16]),
        as.character(df_criteria_ba3a[i, 17]))
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(as.character(df_criteria_ba3a[i, 19]),
        as.character(df_criteria_ba3a[i, 20]))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_criteria_ba3a[i, 6])
    
    # get  the 1 transition width
    trans_width <-
      c(df_criteria_ba3a[i, 8])
    
    # get  the 1 xlim for the plot
    plot_xlim <-
      c((df_criteria_ba3a[i, 6] - df_criteria_ba3a[i, 8]),
        (df_criteria_ba3a[i, 6] + df_criteria_ba3a[i, 8]))
    
  }
  assign(
    paste0("fp_", df_criteria_ba3a[i, 3]),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  plot_fp <-
    plot(
      get(paste0("fp_", df_criteria_ba3a[i, 3])),
      xlim = plot_xlim,
      xlab = as.character(df_criteria_ba3a[i, 4]),
      title = "fuzzy partition"
    )
  print(plot_fp)
  
  # construct the rule bases
  
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_ba3a[i, 3]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_criteria_ba3a[i, 3]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                df_criteria_ba3a[i, 3]),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0("rb_",
                   df_criteria_ba3a[i, 3])))
  
  # apply the fuzzy partitions to the data
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    df_criteria_ba3a[i, 3],
    ", newdata = df_irm,",
    df_criteria_ba3a[i, 3],
    "=",
    "fp_",
    df_criteria_ba3a[i, 3],
    ")"
  )
  
  
  assign(paste0("fpm_",
                df_criteria_ba3a[i, 3]), eval(parse(text = x)))
  
  
  o_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba3a[i, 3]))$optimal)
  s_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba3a[i, 3]))$suboptimal)
  df_irm <-
    mutate(df_irm,!!as.character(paste0(df_criteria_ba3a[i, 3], "_o")) := o_col, .keep = c("all"))
  df_irm <-
    mutate(df_irm,!!as.character(paste0(df_criteria_ba3a[i, 3], "_s")) := s_col, .keep = c("all"))
  
  n <- 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_ba3a[i, 3], "_o")), as.character(paste0(df_criteria_ba3a[i, 3], "_s")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_ba3a[i, 4], " optimal")), as.character(paste0(df_criteria_ba3a[i, 4], " suboptimal")))
  fpm_plot_title <-
    "Precipitation growth\nstages optimality\nmembership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
  print(plot_fpm)
  
  
}

``` 
</div>

```{r i1_requirements_temp01, echo=FALSE, results='asis', eval=tmp_crit, eval=clim_crit}

cat("#### Temperature

By combining temperature in each month and the phenological stages above, we can derive the temperature for each phenological stage that has requirements.")

```

<div class="fold o">   
```{r i1_requirements_temp02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=temp_crit, eval=clim_crit}

#df_criteria_ba3b <-
#    subset(df_criteria_ba3,
#           grepl("^ba_3b", df_criteria_ba3$rulebase_stack)) # subset temperature criteria

df_criteria_ba3b_m <-
    dplyr::filter(df_criteria_ba3, grepl("^ba_3b", rulebase_stack) & temp_resolution == "m") # filter temperature criteria

# A Farrow 01/06/2023 the following assumes that there is only one temperature criterion per growth stage
# In fact there may be multiple so a different way of looping through the criteria is needed


if (nrow(df_criteria_ba3b_m) > 0) {
  for (i in 1:nrow(df_growth_stages_req_temp)) {
      period_name <- as.character(df_growth_stages_req_temp[i, 1])
     # print(paste0("m period_name = ", as.character(period_name)))
     # print(df_criteria_ba3b_m[i, 'phen_stage'])
     # print(sum(df_criteria_ba3b_m[i, 'phen_stage'] == period_name))
      
      if (sum(df_criteria_ba3b_m[i, 'phen_stage'] == period_name, na.rm = TRUE) == 1) {
        print(paste0("m period_name = ", as.character(period_name)))
        
        # get criterion row number for the specific growth stage
        
        crit_rownum <-
          which(df_criteria_ba3b_m$phen_stage == period_name)
        
        # add another for loop if more than one value in crit_rownum vector
        
        for (j in 1:length(crit_rownum)) {
        
        assign(paste0("rast_", df_criteria_ba3b_m[crit_rownum[j], 11], "_rsmp_", df_growth_stages_req_temp[i, 1]),
               (sum(get(
                 paste0("rast_", df_criteria_ba3b_m[crit_rownum[j], 11], "_rsmp")
               ) * get(
                 paste0("rast_period_m_", df_growth_stages_req_temp[i, 1])
               )) / sum(get(
                 paste0("rast_period_m_", df_growth_stages_req_temp[i, 1])
               ))))
        
        #sum(r_tmean_calc_agg_mean_rsmp_bil * r_period_v) / sum(r_period_v)
        
        #print(get(
#          paste0("rast_", df_criteria_ba3b_m[crit_rownum, 11], "_rsmp_", df_growth_stages_req_temp[i, 1])
#        ))
#        plot_raster <-
          plot(get(
            paste0("rast_", df_criteria_ba3b_m[crit_rownum[j], 11], "_rsmp_", df_growth_stages_req_temp[i, 1])
          ),
          main = paste0("rast_period_m_",
                         as.character(df_growth_stages_req_temp[i, 1])))
#        print(plot_raster)
        
        
        new_col <-
          get(paste0("rast_", df_criteria_ba3b_m[crit_rownum[j], 11], "_rsmp_", df_growth_stages_req_temp[i , 1])) %>% terra::extract(xy) # extract the raster values using xy points
        
        new_col <- new_col[[1]]
        
        df_irm <- dplyr::select(df_irm, -any_of(c(as.character(paste0(df_criteria_ba3b_m[crit_rownum[j], 3]))))) # remove column if name already exists
        
        df_irm <-
          mutate(df_irm,!!as.character(paste0(df_criteria_ba3b_m[crit_rownum[j], 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm tibble, this needs to be dynamic so uses the !! and := operators
        
        } 
      } else {
        print(paste0("else m ", period_name, sum(df_criteria_ba3b_m[, 'phen_stage'] == period_name, na.rm = TRUE)))
      }
    }
}


df_criteria_ba3b_d <-
    dplyr::filter(df_criteria_ba3, grepl("^ba_3b", rulebase_stack) & temp_resolution == "d") # filter temperature criteria

if (nrow(df_criteria_ba3b_d) > 0) {  
  for (i in 1:nrow(df_growth_stages_req_temp)) {
        period_name <- as.character(df_growth_stages_req_temp[i, 1])
#      print(period_name)
      if (sum(df_criteria_ba3b_d[i, 'phen_stage'] == period_name, na.rm = TRUE) == 1) {
        print(paste0("period_name = ", as.character(period_name)))
        crit_rownum <-
          which(df_criteria_ba3b_d$phen_stage == period_name)
        assign(paste0("rast_", df_criteria_ba3b_d[crit_rownum, 11], "_rsmp_", df_growth_stages_req_temp[i, 1]),
               (sum(get(
                 paste0("rast_", df_criteria_ba3b_m[crit_rownum, 11], "_rsmp")
               ) * get(
                 paste0("rast_period_d_", df_growth_stages_req_temp[i, 1])
               )) / sum(get(
                 paste0("rast_period_d_", df_growth_stages_req_temp[i, 1])
               ))))
#        print(get(
#          paste0("rast_", df_criteria_ba3b_d[crit_rownum, 11], "_rsmp_", #df_growth_stages_req_temp[i, 1])
#        ))
#        plot_raster <-
          plot(get(
            paste0("rast_", df_criteria_ba3b_d[crit_rownum, 11], "_rsmp_", df_growth_stages_req_temp[i, 1])
          ),
          main = paste0("rast_period_d_",
                         as.character(df_growth_stages_req_temp[i, 1])))
#        print(plot_raster)
        
        
        new_col <-
          get(paste0("rast_", df_criteria_ba3b_d[crit_rownum, 11], "_rsmp_", df_growth_stages_req_temp[i , 1])) %>% terra::extract(xy) # extract the raster values using xy points
        
        new_col <- new_col[[1]]
        
        df_irm <- dplyr::select(df_irm, -any_of(c(as.character(paste0(df_criteria_ba3b_d[crit_rownum, 3]))))) # remove column if name already exists
        
        df_irm <-
          mutate(df_irm,!!as.character(paste0(df_criteria_ba3b_d[crit_rownum, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm tibble, this needs to be dynamic so uses the !! and := operators
        
        
      } else {
        print(sum(df_criteria_ba3b_d[, 'phen_stage'] == period_name, na.rm = TRUE))
      }
    }
}

df_criteria_ba3b <- rbind(df_criteria_ba3b_m, df_criteria_ba3b_d)

```
</div>


```{r i1_requirements_temp03, echo=FALSE, results='asis', eval=tmp_crit, eval=clim_crit}

cat("##### Temperature optimality

We used the requirements to construct fuzzy partitions and the rulebases.")

```

<div class="fold o">   
```{r i1_requirements_temp04, cache = TRUE, cache.whatever=params$Agg, out.width="100%", fig.show="hold", warning=FALSE, eval=tmp_crit, eval=clim_crit}



for (i in 1:(nrow(df_criteria_ba3b))) {
  if (!is.na(df_criteria_ba3b[i, 18])) {
    # for those criteria with three proposition values
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_criteria_ba3b[i, 16]),
        as.character(df_criteria_ba3b[i, 17]),
        as.character(df_criteria_ba3b[i, 18])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        as.character(df_criteria_ba3b[i, 19]),
        as.character(df_criteria_ba3b[i, 20]),
        as.character(df_criteria_ba3b[i, 21])
      )
    # get  the 2 crossover points
    cross_points <-
      c(df_criteria_ba3b[i, 6],
        df_criteria_ba3b[i, 7])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_criteria_ba3b[i, 8],
        df_criteria_ba3b[i, 9])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_criteria_ba3b[i, 6] - df_criteria_ba3b[i, 8]),
        (df_criteria_ba3b[i, 7] + df_criteria_ba3b[i, 9]))
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    prop_levels <-
      c(as.character(df_criteria_ba3b[i, 16]),
        as.character(df_criteria_ba3b[i, 17]))
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(as.character(df_criteria_ba3b[i, 19]),
        as.character(df_criteria_ba3b[i, 20]))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_criteria_ba3b[i, 6])
    
    # get  the 1 transition width
    trans_width <-
      c(df_criteria_ba3b[i, 8])
    
    # get  the 1 xlim for the plot
    plot_xlim <-
      c((df_criteria_ba3b[i, 6] - df_criteria_ba3b[i, 8]),
        (df_criteria_ba3b[i, 6] + df_criteria_ba3b[i, 8]))
    
  }
  assign(
    paste0("fp_", df_criteria_ba3b[i, 3]),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  plot_fp <-
    plot(
      get(paste0("fp_", df_criteria_ba3b[i, 3])),
      xlim = plot_xlim,
      xlab = as.character(df_criteria_ba3b[i, 4]),
      title = "fuzzy partition"
    )
  print(plot_fp)
  
  # construct the rule bases
  
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_ba3b[i, 3]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_criteria_ba3b[i, 3]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                df_criteria_ba3b[i, 3]),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0("rb_",
                   df_criteria_ba3b[i, 3])))
  
  # apply the fuzzy partitions to the data
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    df_criteria_ba3b[i, 3],
    ", newdata = df_irm,",
    df_criteria_ba3b[i, 3],
    "=",
    "fp_",
    df_criteria_ba3b[i, 3],
    ")"
  )
  
  # evaluate the rule base and create the fpm
  
  assign(paste0("fpm_",
                df_criteria_ba3b[i, 3]), eval(parse(text = x)))
  
  # get the membership values from the fpm
  
  o_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba3b[i, 3]))$optimal)
  s_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba3b[i, 3]))$suboptimal)
  df_irm <-
    mutate(df_irm,!!as.character(paste0(df_criteria_ba3b[i, 3], "_o")) := o_col, .keep = c("all"))
  df_irm <-
    mutate(df_irm,!!as.character(paste0(df_criteria_ba3b[i, 3], "_s")) := s_col, .keep = c("all"))
  
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_ba3b[i, 3], "_o")), as.character(paste0(df_criteria_ba3b[i, 3], "_s")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_ba3b[i, 4], " optimal")), as.character(paste0(df_criteria_ba3b[i, 4], " suboptimal")))
  fpm_plot_title <-
    "Temperature growth\nstages optimality\nmembership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
  print(plot_fpm)
  
  
}

``` 
</div>

```{r i1_requirements_soilp01, echo=FALSE, results='asis', eval=soil_p_crit}

cat("### Soil physical properties requirements

If soil texture is a criterion then the USDA codes are reclassified quantitatively so that the fuzzy partitions can be applied.

Soil texture classes are reclassified in with 1, corresponding to S1 in Sys _et al._ (1993, p.159), 0.5 corresponding to S2, and 0 corresponding to S3, N1, N2 in Sys _et al._. 

An example is shown in the table below: 
 
USDA Class | USDA Texture Code | Suitability | Value 
-----------|-------------------|-------------|-------
     '1'   |     'Cl'          |  S2         |  0.5
     '2'   |     'SiCl'        |  S1         |  1
     '3'   |     'SaCl'        |  S1         |  1
     '4'   |     'ClLo'        |  S1         |  1
     '5'   |     'SiClLo'      |  S1         |  1
     '6'   |     'SaClLo'      |  S1         |  1
     '7'   |     'Lo'          |  S1         |  1
     '8'   |     'SiLo'        |  S1         |  1
     '9'   |     'SaLo'        |  S1         |  1
    '10'   |     'Si'          |  S1         |  1
    '11'   |     'LoSa'        |  S1         |  1
    '12'   |     'Sa'          |  S3         |  0
   '255'   |     'NODATA'      |  NA         |  NA")

```


   
```{r i1_requirements_soilp02, results='asis', warning=FALSE, eval=soil_p_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria

df_criteria_ba2c <-
  subset(df_priorities, grepl("^ba_2c", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cba2c <- nrow(df_criteria_ba2c)
cat(paste(n_cba2c, "Soil physical properties criteria:\n\n"))

# then determine and print the names of the rule bases in the soil physical properties theme
cat(paste(n_cba2c, "Soil physical properties rule bases:\n\n"))
for (i in 1:n_cba2c) {
  cat(paste(df_criteria_ba2c[i, 3],"\n", df_criteria_ba2c[i, 4],"\n"))
  
  if (paste(df_criteria_ba2c[i, 4]) == "Soil texture") {
    soil_texture_filename <-
      as.character(paste("tab_data/input/usda_texture_", params$INN1, ".csv", sep = ""))
    
    df_soil_texture <-  read.csv(here(soil_texture_filename))
    
    df_soil_texture %>%
      kable(digits = 3, caption = "Soil Texture ") %>% kable_styling("striped", full_width = T) %>% print
    
    # reclass using df_soil_texture table
    
    rast_texture <-
      get(paste0("rast_", df_criteria_ba2c[i, 11], "_rsmp")) %>% classify(as.matrix(
        dplyr::select(df_soil_texture, USDA_Texture_Class, IRM_Value)
      ))
    
    
    assign(paste0("rast_", df_criteria_ba2c[i, 11], "_rsmp"),  rast_texture[[1:5]])
    
    # standard depths for interpolation
    standard_depths <- c(0.025, 0.10, 0.225, 0.45, 0.80, 1.50)
    
    # thicknesses of individual layers
    bottom_layer <- c(0.05, 0.15, 0.30, 0.60, 1.0)
    thickness <- diff(c(0, bottom_layer))
    stopifnot(max(abs(
      bottom_layer - 0.5 *  thickness - standard_depths[1:5]
    )) < 1.0e-6)
    
    # depth weighted texture class (0-1)
    assign(paste0("rast_", df_criteria_ba2c[i, 11], "_rsmp"),
           get(paste0("rast_", df_criteria_ba2c[i, 11], "_rsmp")) %>% app(function(x) {
             sum((x * thickness) / sum(thickness))
           }))
  } else if (paste(df_criteria_ba2c[i, 4]) == "Coarse fragments") {
    assign(paste0("rast_", df_criteria_ba2c[i, 11], "_rsmp"),  get(paste0("rast_", df_criteria_ba2c[i, 11], "_rsmp"))[[1:5]])
    
    # standard depths for interpolation
    standard_depths <- c(0.025, 0.10, 0.225, 0.45, 0.80, 1.50)
    
    # thicknesses of individual layers
    bottom_layer <- c(0.05, 0.15, 0.30, 0.60, 1.0)
    thickness <- diff(c(0, bottom_layer))
    stopifnot(max(abs(
      bottom_layer - 0.5 *  thickness - standard_depths[1:5]
    )) < 1.0e-6)
    
    # depth weighted map
    assign(paste0("rast_", df_criteria_ba2c[i, 11], "_rsmp"),
           get(paste0("rast_", df_criteria_ba2c[i, 11], "_rsmp")) %>% app(function(x) {
             sum((x * thickness) / sum(thickness))
           }))
  }
}

```

```{r i1_requirements_soilp03, echo=FALSE, results='asis', eval=soil_p_crit}

cat("The reclassified classes are averaged over the entire soil profile from 0 to 0.8 m, taking the layer thicknesses as weights")

```


<div class="fold o">   
```{r i1_requirements_soilp04, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=soil_p_crit}

for (i in 1:n_cba2c) {
  new_col <-
    get(paste0("rast_", df_criteria_ba2c[i, 11], "_rsmp")) %>% terra::extract(xy) # extract the raster values using xy points
          
  new_col <- new_col[[1]]
  
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_ba2c[i, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm tibble, this needs to be dynamic so uses the !! and := operators
  
}

```
</div>

```{r i1_requirements_soilp05, echo=FALSE, results='asis', eval=soil_p_crit}

cat("#### Soil physical properties optimality

We used the requirements to construct fuzzy partitions and the rulebases.")

```


<div class="fold o">   
```{r i1_requirements_soilp06, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=soil_p_crit}

for (i in 1:(nrow(df_criteria_ba2c))) {
  if (!is.na(df_criteria_ba2c[i, 18])) {
    # for those criteria with three proposition values
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_criteria_ba2c[i, 16]),
        as.character(df_criteria_ba2c[i, 17]),
        as.character(df_criteria_ba2c[i, 18])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        as.character(df_criteria_ba2c[i, 19]),
        as.character(df_criteria_ba2c[i, 20]),
        as.character(df_criteria_ba2c[i, 21])
      )
    # get  the 2 crossover points
    cross_points <-
      c(df_criteria_ba2c[i, 6],
        df_criteria_ba2c[i, 7])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_criteria_ba2c[i, 8],
        df_criteria_ba2c[i, 9])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_criteria_ba2c[i, 6] - df_criteria_ba2c[i, 8]),
        (df_criteria_ba2c[i, 7] + df_criteria_ba2c[i, 9]))
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    prop_levels <-
      c(as.character(df_criteria_ba2c[i, 16]),
        as.character(df_criteria_ba2c[i, 17]))
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(as.character(df_criteria_ba2c[i, 19]),
        as.character(df_criteria_ba2c[i, 20]))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_criteria_ba2c[i, 6])
    
    # get  the 1 transition width
    trans_width <-
      c(df_criteria_ba2c[i, 8])
    
    # get  the 1 xlim for the plot
    plot_xlim <-
      c((df_criteria_ba2c[i, 6] - df_criteria_ba2c[i, 8]),
        (df_criteria_ba2c[i, 6] + df_criteria_ba2c[i, 8]))
    
  }
  assign(
    paste0("fp_", df_criteria_ba2c[i, 3]),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  plot_fp <-
    plot(
      get(paste0("fp_", df_criteria_ba2c[i, 3])),
      xlim = plot_xlim,
      xlab = as.character(df_criteria_ba2c[i, 4]),
      title = "fuzzy partition"
    )
  print(plot_fp)
  
  # construct the rule bases
  
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_ba2c[i, 3]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_criteria_ba2c[i, 3]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                df_criteria_ba2c[i, 3]),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0("rb_",
                   df_criteria_ba2c[i, 3])))
  
  # apply the fuzzy partitions to the data
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    df_criteria_ba2c[i, 3],
    ", newdata = df_irm,",
    df_criteria_ba2c[i, 3],
    "=",
    "fp_",
    df_criteria_ba2c[i, 3],
    ")"
  )
  
  # evaluate the rule base and create the fpm
  
  assign(paste0("fpm_",
                df_criteria_ba2c[i, 3]), eval(parse(text = x)))
  
  # get the membership values from the fpm
  
  o_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba2c[i, 3]))$optimal)
  s_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba2c[i, 3]))$suboptimal)
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_ba2c[i, 3], "_o")) := o_col, .keep = c("all"))
  
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_ba2c[i, 3], "_s")) := s_col, .keep = c("all"))
  
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_ba2c[i, 3], "_o")), as.character(paste0(df_criteria_ba2c[i, 3], "_s")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_ba2c[i, 4], " optimal")), as.character(paste0(df_criteria_ba2c[i, 4], " suboptimal")))
  fpm_plot_title <-
    "Soil physical properties optimality membership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
  print(plot_fpm)
  
  
}

``` 
</div>


```{r i1_requirements_soilf01, echo=FALSE, results='asis', eval=soil_f_crit}

cat("### Soil fertility requirements")

```


```{r i1_requirements_soilf02, results='asis', warning=FALSE, eval=soil_f_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria

df_criteria_ba2d <-
  subset(df_priorities, grepl("^ba_2d", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cba2d <- nrow(df_criteria_ba2d)
cat(paste(n_cba2d, "Soil fertility criteria:\n\n "))

# then determine and print the names of the rule bases in the soil fertility theme

cat(paste(n_cba2d, "Soil fertility rule bases:\n\n"))
```


<div class="fold o">   
```{r i1_requirements_soilf03, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=soil_f_crit}

for (i in 1:n_cba2d) {
  new_col <-
    get(paste0("rast_", df_criteria_ba2d[i, 11], "_rsmp")) %>% terra::extract(xy) # extract the raster values using xy points
  
  new_col <- new_col[[1]]
  
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_ba2d[i, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm tibble, this needs to be dynamic so uses the !! and := operators
  
}

```
</div>

```{r i1_requirements_soilf04, echo=FALSE, results='asis', eval=soil_f_crit}

cat("#### Soil fertility optimality

We used the requirements to construct fuzzy partitions and the rulebases.")

```

<div class="fold o">   
```{r i1_requirements_soilf05, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=soil_f_crit}

for (i in 1:(nrow(df_criteria_ba2d))) {
  if (!is.na(df_criteria_ba2d[i, 18])) {
    # for those criteria with three proposition values
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_criteria_ba2d[i, 16]),
        as.character(df_criteria_ba2d[i, 17]),
        as.character(df_criteria_ba2d[i, 18])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        as.character(df_criteria_ba2d[i, 19]),
        as.character(df_criteria_ba2d[i, 20]),
        as.character(df_criteria_ba2d[i, 21])
      )
    # get  the 2 crossover points
    cross_points <-
      c(df_criteria_ba2d[i, 6],
        df_criteria_ba2d[i, 7])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_criteria_ba2d[i, 8],
        df_criteria_ba2d[i, 9])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_criteria_ba2d[i, 6] - df_criteria_ba2d[i, 8]),
        (df_criteria_ba2d[i, 7] + df_criteria_ba2d[i, 9]))
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    prop_levels <-
      c(as.character(df_criteria_ba2d[i, 16]),
        as.character(df_criteria_ba2d[i, 17]))
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(as.character(df_criteria_ba2d[i, 19]),
        as.character(df_criteria_ba2d[i, 20]))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_criteria_ba2d[i, 6])
    
    # get  the 1 transition width
    trans_width <-
      c(df_criteria_ba2d[i, 8])
    
    # get  the 1 xlim for the plot
    plot_xlim <-
      c((df_criteria_ba2d[i, 6] - df_criteria_ba2d[i, 8]),
        (df_criteria_ba2d[i, 6] + df_criteria_ba2d[i, 8]))
    
  }
  assign(
    paste0("fp_", df_criteria_ba2d[i, 3]),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  plot_fp <-
    plot(
      get(paste0("fp_", df_criteria_ba2d[i, 3])),
      xlim = plot_xlim,
      xlab = as.character(df_criteria_ba2d[i, 4]),
      title = "fuzzy partition"
    )
  print(plot_fp)
  
  # construct the rule bases
  
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_ba2d[i, 3]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_criteria_ba2d[i, 3]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                df_criteria_ba2d[i, 3]),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0("rb_",
                   df_criteria_ba2d[i, 3])))
  
  # apply the fuzzy partitions to the data
  
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    df_criteria_ba2d[i, 3],
    ", newdata = df_irm,",
    df_criteria_ba2d[i, 3],
    "=",
    "fp_",
    df_criteria_ba2d[i, 3],
    ")"
  )
  
  # evaluate the rule base and create the fpm
  
  assign(paste0("fpm_",
                df_criteria_ba2d[i, 3]), eval(parse(text = x)))
  
  # get the membership values from the fpm
  
  o_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba2d[i, 3]))$optimal)
  s_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba2d[i, 3]))$suboptimal)
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_ba2d[i, 3], "_o")) := o_col, .keep = c("all"))
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_ba2d[i, 3], "_s")) := s_col, .keep = c("all"))
  
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_ba2d[i, 3], "_o")), as.character(paste0(df_criteria_ba2d[i, 3], "_s")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_ba2d[i, 4], " optimal")), as.character(paste0(df_criteria_ba2d[i, 4], " suboptimal")))
  fpm_plot_title <-
    "Soil fertility optimality membership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
  print(plot_fpm)

}

``` 
</div>

```{r i1_requirements_lscape01, echo=FALSE, results='asis', eval=lscape_crit}

cat("### Landscape requirements

Drainage classes are from ISRIC's SoilGrids (ftp://soilgrids:soilgrids@ftp.soilgrids.org/data/AF/recent/)

Drainage classes are according to the FAO Guidelines for profile description. See ISRIC_report 2008_02.pdf (http://www.isric.org/isric/webdocs/docs/ISRIC_Report_2008_02.pdf)

The drainage classes are:

- V: very poorly drained
- P: poorly drained
- I: somewhat poorly (imperfectly) drained
- M: moderately well drained
- W: well drained
- S: somewhat excessively drained
- E: excessively drained

The map below is a recoded version of this map (1:V, 2:P, 3:I, 4:M, 5:W, 6:S, 7:E)")

```


```{r i1_requirements_lscape02, results='asis', warning=FALSE, eval=lscape_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria
df_criteria_ba2e <-
  subset(df_priorities, grepl("^ba_2e", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cba2e <- nrow(df_criteria_ba2e)
cat(paste(n_cba2e, "Landscape criteria:\n\n"))

# then determine and print the names of the rule bases in the landscape theme

cat(paste(n_cba2e, "Landscape rule bases:\n\n"))
for (i in 1:n_cba2e) {
  cat(paste(df_criteria_ba2e[i, 3], "\n", df_criteria_ba2e[i, 4], "\n"))
}

```

<div class="fold o">   
```{r i1_requirements_lscape03, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=lscape_crit}

for (i in 1:n_cba2e) {
  new_col <-
    get(paste0("rast_", df_criteria_ba2e[i, 11], "_rsmp")) %>% terra::extract(xy) # extract the raster values using xy points
          
  new_col <- new_col[[1]]
  
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_ba2e[i, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm tibble, this needs to be dynamic so uses the !! and := operators
  
}

```
</div>


```{r i1_requirements_lscape04, echo=FALSE, results='asis', eval=lscape_crit}

cat("#### Landscape optimality

We used the requirements to construct fuzzy partitions and the rulebases.")

```


<div class="fold o">   
```{r i1_requirements_lscape05, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=lscape_crit}

for (i in 1:(nrow(df_criteria_ba2e))) {
  if (!is.na(df_criteria_ba2e[i, 18])) {
    # for those criteria with three proposition values
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_criteria_ba2e[i, 16]),
        as.character(df_criteria_ba2e[i, 17]),
        as.character(df_criteria_ba2e[i, 18])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        as.character(df_criteria_ba2e[i, 19]),
        as.character(df_criteria_ba2e[i, 20]),
        as.character(df_criteria_ba2e[i, 21])
      )
    # get  the 2 crossover points
    cross_points <-
      c(df_criteria_ba2e[i, 6],
        df_criteria_ba2e[i, 7])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_criteria_ba2e[i, 8],
        df_criteria_ba2e[i, 9])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_criteria_ba2e[i, 6] - df_criteria_ba2e[i, 8]),
        (df_criteria_ba2e[i, 7] + df_criteria_ba2e[i, 9]))
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    prop_levels <-
      c(as.character(df_criteria_ba2e[i, 16]),
        as.character(df_criteria_ba2e[i, 17]))
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(as.character(df_criteria_ba2e[i, 19]),
        as.character(df_criteria_ba2e[i, 20]))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_criteria_ba2e[i, 6])
    
    # get  the 1 transition width
    trans_width <-
      c(df_criteria_ba2e[i, 8])
    
    # get  the 1 xlim for the plot
    plot_xlim <-
      c((df_criteria_ba2e[i, 6] - df_criteria_ba2e[i, 8]),
        (df_criteria_ba2e[i, 6] + df_criteria_ba2e[i, 8]))
    
  }
  assign(
    paste0("fp_", df_criteria_ba2e[i, 3]),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  plot_fp <-
    plot(
      get(paste0("fp_", df_criteria_ba2e[i, 3])),
      xlim = plot_xlim,
      xlab = as.character(df_criteria_ba2e[i, 4]),
      title = "fuzzy partition"
    )
  print(plot_fp)
  
  # construct the rule bases
  
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_ba2e[i, 3]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_criteria_ba2e[i, 3]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                df_criteria_ba2e[i, 3]),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0("rb_",
                   df_criteria_ba2e[i, 3])))
  
  # apply the fuzzy partitions to the data
  
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    df_criteria_ba2e[i, 3],
    ", newdata = df_irm,",
    df_criteria_ba2e[i, 3],
    "=",
    "fp_",
    df_criteria_ba2e[i, 3],
    ")"
  )
  
  # evaluate the rule base and create the fpm
  
  assign(paste0("fpm_",
                df_criteria_ba2e[i, 3]), eval(parse(text = x)))
  
  # get the membership values from the fpm
  
  o_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba2e[i, 3]))$optimal)
  s_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba2e[i, 3]))$suboptimal)
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_ba2e[i, 3], "_o")) := o_col, .keep = c("all"))
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_ba2e[i, 3], "_s")) := s_col, .keep = c("all"))
  
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_ba2e[i, 3], "_o")), as.character(paste0(df_criteria_ba2e[i, 3], "_s")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_ba2e[i, 4], " optimal")), as.character(paste0(df_criteria_ba2e[i, 4], " suboptimal")))
  fpm_plot_title <-
    "Landscape optimality membership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
  print(plot_fpm)

}

``` 
</div>


```{r i1_requirements_agland01, echo=FALSE, results='asis', eval=land_crit}

cat("### Agricultural Land requirements")

```

```{r i1_requirements_agland02, results='asis', warning=FALSE, eval=land_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria

df_criteria_ba2a <-
  subset(df_priorities, grepl("^ba_2a", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cba2a <- nrow(df_criteria_ba2a)
cat(paste(n_cba2a, "Agricultural Land criteria: \n\n"))

# then determine and print the names of the rule bases in the land theme
# here in contrast to the previous themes we need to account for criteria which have no data but instead use rule base stacks - these are removed now from the criteria data frame and evaluated later

data_rulebase <- !is.na(df_criteria_ba2a$data_file_prefix)
df_criteria_ba2a <- df_criteria_ba2a[data_rulebase,]

n_cse3b <- nrow(df_criteria_ba2a)

cat(paste(n_cba2a, "Agricultural Land rule bases:\n\n"))
for (i in 1:n_cba2a) {
  cat(paste(df_criteria_ba2a[i, 3],"\n", df_criteria_ba2a[i, 4],"\n"))
}

```

<div class="fold o">   
```{r i1_requirements_agland03, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=land_crit}

for (i in 1:n_cba2a) {
  new_col <-
    get(paste0("rast_", df_criteria_ba2a[i, 11], "_rsmp")) %>% terra::extract(xy) # extract the raster values using xy points
          
  new_col <- new_col[[1]]
        
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_ba2a[i, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm tibble, this needs to be dynamic so uses the !! and := operators
  
}

```
</div>

```{r i1_requirements_agland04, echo=FALSE, results='asis', eval=land_crit}

cat("#### Agricultural Land optimality

We used the requirements to construct fuzzy partitions and the rulebases.")

```

<div class="fold o">   
```{r i1_requirements_agland05, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=land_crit}

for (i in 1:(nrow(df_criteria_ba2a))) {
  if (!is.na(df_criteria_ba2a[i, 18])) {
    # for those criteria with three proposition values
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_criteria_ba2a[i, 16]),
        as.character(df_criteria_ba2a[i, 17]),
        as.character(df_criteria_ba2a[i, 18])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        as.character(df_criteria_ba2a[i, 19]),
        as.character(df_criteria_ba2a[i, 20]),
        as.character(df_criteria_ba2a[i, 21])
      )
    # get  the 2 crossover points
    cross_points <-
      c(df_criteria_ba2a[i, 6],
        df_criteria_ba2a[i, 7])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_criteria_ba2a[i, 8],
        df_criteria_ba2a[i, 9])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_criteria_ba2a[i, 6] - df_criteria_ba2a[i, 8]),
        (df_criteria_ba2a[i, 7] + df_criteria_ba2a[i, 9]))
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    prop_levels <-
      c(as.character(df_criteria_ba2a[i, 16]),
        as.character(df_criteria_ba2a[i, 17]))
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(as.character(df_criteria_ba2a[i, 19]),
        as.character(df_criteria_ba2a[i, 20]))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_criteria_ba2a[i, 6])
    
    # get  the 1 transition width
    trans_width <-
      c(df_criteria_ba2a[i, 8])
    
    # get  the 1 xlim for the plot
    plot_xlim <-
      c((df_criteria_ba2a[i, 6] - df_criteria_ba2a[i, 8]),
        (df_criteria_ba2a[i, 6] + df_criteria_ba2a[i, 8]))
    
  }
  assign(
    paste0("fp_", df_criteria_ba2a[i, 3]),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  plot_fp <-
    plot(
      get(paste0("fp_", df_criteria_ba2a[i, 3])),
      xlim = plot_xlim,
      xlab = as.character(df_criteria_ba2a[i, 4]),
      title = "fuzzy partition"
    )
  print(plot_fp)
  
  # construct the rule bases
  
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_ba2a[i, 3]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_criteria_ba2a[i, 3]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                df_criteria_ba2a[i, 3]),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0("rb_",
                   df_criteria_ba2a[i, 3])))
  
  # apply the fuzzy partitions to the data
  
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    df_criteria_ba2a[i, 3],
    ", newdata = df_irm,",
    df_criteria_ba2a[i, 3],
    "=",
    "fp_",
    df_criteria_ba2a[i, 3],
    ")"
  )
  
  # evaluate the rule base and create the fpm
  
  assign(paste0("fpm_",
                df_criteria_ba2a[i, 3]), eval(parse(text = x)))
  
  # get the membership values from the fpm
  
  
  
  o_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba2a[i, 3]))$optimal)
  s_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba2a[i, 3]))$suboptimal)
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_ba2a[i, 3], "_o")) := o_col, .keep = c("all"))
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_ba2a[i, 3], "_s")) := s_col, .keep = c("all"))
  
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_ba2a[i, 3], "_o")), as.character(paste0(df_criteria_ba2a[i, 3], "_s")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_ba2a[i, 4], " optimal")), as.character(paste0(df_criteria_ba2a[i, 4], " suboptimal")))
  fpm_plot_title <-
    "Agricultural\nLand\noptimality\nmembership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
  print(plot_fpm)
  
  
}

``` 
</div>

```{r i1_requirements_sef01, echo=FALSE, results='asis', eval=sef_crit}

cat("## Socio-economic requirements")

```


```{r i1_requirements_market_access01, echo=FALSE, results='asis', eval=mktaccess_crit}

cat("### Market Access requirements")

```

```{r i1_requirements_market_access02, results='asis', warning=FALSE, eval=mktaccess_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria

df_criteria_se2b <-
  subset(df_priorities, grepl("^se_2b", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cse2b <- nrow(df_criteria_se2b)
cat(paste(n_cse2b, "Market Access criteria: \n\n"))

# then determine and print the names of the rule bases in the Market Access theme

cat(paste(n_cse2b, "Market Access rule bases: \n\n"))
for (i in 1:n_cse2b) {
  cat(paste(df_criteria_se2b[i, 3], "\n", df_criteria_se2b[i, 4], "\n"))
}

```

<div class="fold o">   
```{r i1_requirements_market_access03, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=mktaccess_crit}

for (i in 1:n_cse2b) {
  new_col <-
    get(paste0("rast_", df_criteria_se2b[i, 11], "_rsmp")) %>% terra::extract(xy) # extract the raster values using xy points
        
  new_col <- new_col[[1]]
  
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_se2b[i, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm tibble, this needs to be dynamic so uses the !! and := operators
  
}

```
</div>

```{r i1_requirements_market_access04, echo=FALSE, results='asis', eval=mktaccess_crit}

cat("#### Market Access optimality

We used the requirements to construct fuzzy partitions and the rulebases.")

```

<div class="fold o">   
```{r i1_requirements_market_access05, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=mktaccess_crit}

for (i in 1:(nrow(df_criteria_se2b))) {
  if (!is.na(df_criteria_se2b[i, 18])) {
    # for those criteria with three proposition values
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_criteria_se2b[i, 16]),
        as.character(df_criteria_se2b[i, 17]),
        as.character(df_criteria_se2b[i, 18])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        as.character(df_criteria_se2b[i, 19]),
        as.character(df_criteria_se2b[i, 20]),
        as.character(df_criteria_se2b[i, 21])
      )
    # get  the 2 crossover points
    cross_points <-
      c(df_criteria_se2b[i, 6],
        df_criteria_se2b[i, 7])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_criteria_se2b[i, 8],
        df_criteria_se2b[i, 9])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_criteria_se2b[i, 6] - df_criteria_se2b[i, 8]),
        (df_criteria_se2b[i, 7] + df_criteria_se2b[i, 9]))
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    prop_levels <-
      c(as.character(df_criteria_se2b[i, 16]),
        as.character(df_criteria_se2b[i, 17]))
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(as.character(df_criteria_se2b[i, 19]),
        as.character(df_criteria_se2b[i, 20]))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_criteria_se2b[i, 6])
    
    # get  the 1 transition width
    trans_width <-
      c(df_criteria_se2b[i, 8])
    
    # get  the 1 xlim for the plot
    plot_xlim <-
      c((df_criteria_se2b[i, 6] - df_criteria_se2b[i, 8]),
        (df_criteria_se2b[i, 6] + df_criteria_se2b[i, 8]))
    
  }
  assign(
    paste0("fp_", df_criteria_se2b[i, 3]),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  plot_fp <-
    plot(
      get(paste0("fp_", df_criteria_se2b[i, 3])),
      xlim = plot_xlim,
      xlab = as.character(df_criteria_se2b[i, 4]),
      title = "fuzzy partition"
    )
  print(plot_fp)
  
  # construct the rule bases
  
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_se2b[i, 3]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_criteria_se2b[i, 3]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                df_criteria_se2b[i, 3]),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0("rb_",
                   df_criteria_se2b[i, 3])))
  
  # apply the fuzzy partitions to the data
  
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    df_criteria_se2b[i, 3],
    ", newdata = df_irm,",
    df_criteria_se2b[i, 3],
    "=",
    "fp_",
    df_criteria_se2b[i, 3],
    ")"
  )
  
  # evaluate the rule base and create the fpm
  
  assign(paste0("fpm_",
                df_criteria_se2b[i, 3]), eval(parse(text = x)))
  
  # get the membership values from the fpm
  
  g_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se2b[i, 3]))$good)
  p_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se2b[i, 3]))$poor)
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_se2b[i, 3], "_g")) := g_col, .keep = c("all"))
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_se2b[i, 3], "_p")) := p_col, .keep = c("all"))
  
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se2b[i, 3], "_g")), as.character(paste0(df_criteria_se2b[i, 3], "_p")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se2b[i, 4], " good")), as.character(paste0(df_criteria_se2b[i, 4], " poor")))
  fpm_plot_title <-
    "Market Access\noptimality\nmembership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
  print(plot_fpm)
  
  
}

``` 
</div>

```{r i1_requirements_inputs_access01, echo=FALSE, results='asis', eval=inpaccess_crit}

cat("### Inputs Access requirements")

```

```{r i1_requirements_inputs_access02, results='asis', warning=FALSE, eval=inpaccess_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria

df_criteria_se3b <-
  subset(df_priorities, grepl("^se_3b", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cse3b <- nrow(df_criteria_se3b)
cat(paste(n_cse3b, "Inputs Access criteria: \n\n"))

# then determine and print the names of the rule bases in the Inputs Access theme
# here in contrast to the previous themes we need to account for criteria which have no data but instead use rule base stacks - these are removed now from the criteria data frame and evaluated later

data_rulebase <- !is.na(df_criteria_se3b$data_file_prefix)
df_criteria_se3b <- df_criteria_se3b[data_rulebase,]

n_cse3b <- nrow(df_criteria_se3b)

cat(paste(n_cse3b, "Inputs Access data rule bases:\n\n"))
for (i in 1:n_cse3b) {
  cat(paste(df_criteria_se3b[i, 3], "\n", df_criteria_se3b[i, 4], "\n"))
}

```

<div class="fold o">   
```{r i1_requirements_inputs_access03, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=inpaccess_crit}

for (i in 1:n_cse3b) {
  new_col <-
    get(paste0("rast_", df_criteria_se3b[i, 11], "_rsmp")) %>% terra::extract(xy) # extract the raster values using xy points
        
  new_col <- new_col[[1]] 
  
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_se3b[i, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm tibble, this needs to be dynamic so uses the !! and := operators
  
}

```
</div>

```{r i1_requirements_inputs_access04, echo=FALSE, results='asis', eval=inpaccess_crit}

cat("#### Inputs Access optimality

We used the requirements to construct fuzzy partitions and the data rule bases.")

```

<div class="fold o">   
```{r i1_requirements_inputs_access05, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=inpaccess_crit}

for (i in 1:(nrow(df_criteria_se3b))) {
  if (!is.na(df_criteria_se3b[i, 18])) {
    # for those criteria with three proposition values
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_criteria_se3b[i, 16]),
        as.character(df_criteria_se3b[i, 17]),
        as.character(df_criteria_se3b[i, 18])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        as.character(df_criteria_se3b[i, 19]),
        as.character(df_criteria_se3b[i, 20]),
        as.character(df_criteria_se3b[i, 21])
      )
    # get  the 2 crossover points
    cross_points <-
      c(df_criteria_se3b[i, 6],
        df_criteria_se3b[i, 7])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_criteria_se3b[i, 8],
        df_criteria_se3b[i, 9])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_criteria_se3b[i, 6] - df_criteria_se3b[i, 8]),
        (df_criteria_se3b[i, 7] + df_criteria_se3b[i, 9]))
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    prop_levels <-
      c(as.character(df_criteria_se3b[i, 16]),
        as.character(df_criteria_se3b[i, 17]))
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(as.character(df_criteria_se3b[i, 19]),
        as.character(df_criteria_se3b[i, 20]))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_criteria_se3b[i, 6])
    
    # get  the 1 transition width
    trans_width <-
      c(df_criteria_se3b[i, 8])
    
    # get  the 1 xlim for the plot
    plot_xlim <-
      c((df_criteria_se3b[i, 6] - df_criteria_se3b[i, 8]),
        (df_criteria_se3b[i, 6] + df_criteria_se3b[i, 8]))
    
  }
  assign(
    paste0("fp_", df_criteria_se3b[i, 3]),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  plot_fp <-
    plot(
      get(paste0("fp_", df_criteria_se3b[i, 3])),
      xlim = plot_xlim,
      xlab = as.character(df_criteria_se3b[i, 4]),
      title = "fuzzy partition"
    )
  print(plot_fp)
  
  # construct the rule bases
  
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_se3b[i, 3]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_criteria_se3b[i, 3]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                df_criteria_se3b[i, 3]),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0("rb_",
                   df_criteria_se3b[i, 3])))
  
  # apply the fuzzy partitions to the data
  
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    df_criteria_se3b[i, 3],
    ", newdata = df_irm,",
    df_criteria_se3b[i, 3],
    "=",
    "fp_",
    df_criteria_se3b[i, 3],
    ")"
  )
  
  # evaluate the rule base and create the fpm
  
  assign(paste0("fpm_",
                df_criteria_se3b[i, 3]), eval(parse(text = x)))
  
  # get the membership values from the fpm
  
  g_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se3b[i, 3]))$good)
  p_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se3b[i, 3]))$poor)
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_se3b[i, 3], "_g")) := g_col, .keep = c("all"))
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_se3b[i, 3], "_p")) := p_col, .keep = c("all"))
  
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se3b[i, 3], "_g")), as.character(paste0(df_criteria_se3b[i, 3], "_p")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se3b[i, 4], " good")), as.character(paste0(df_criteria_se3b[i, 4], " poor")))
  fpm_plot_title <-
    "Inputs Access\noptimality\nmembership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
  print(plot_fpm)
  
  
}

``` 
</div>

```{r i1_requirements_extension_access01, echo=FALSE, results='asis', eval=extaccess_crit}

cat("### Extension Access requirements")

```


```{r i1_requirements_extension_access02, results='asis', warning=FALSE, eval=extaccess_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria

df_criteria_se4a <-
  subset(df_priorities, grepl("^se_4a", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cse4a <- nrow(df_criteria_se4a)
cat(paste(n_cse4a, "Extension Access criteria: \n\n"))

# then determine and print the names of the rule bases in the Extension Access theme
# here in contrast to the previous themes we need to account for criteria which have no data but instead use rule base stacks - these are removed now from the criteria data frame and evaluated later

data_rulebase <- !is.na(df_criteria_se4a$data_file_prefix)
df_criteria_se4a <- df_criteria_se4a[data_rulebase,]

n_cse4a <- nrow(df_criteria_se4a)

cat(paste(n_cse4a, "Extension Access data rule bases:\n\n"))
for (i in 1:n_cse4a) {
  cat(paste(df_criteria_se4a[i, 3], "\n", df_criteria_se4a[i, 4],"\n"))
}

```

<div class="fold o">   
```{r i1_requirements_extension_access03, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=extaccess_crit}

for (i in 1:n_cse4a) {
  new_col <-
    get(paste0("rast_", df_criteria_se4a[i, 11], "_rsmp")) %>% terra::extract(xy) # extract the raster values using xy points
  
  new_col <- new_col[[1]]
  
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_se4a[i, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm tibble, this needs to be dynamic so uses the !! and := operators
  
}

```
</div>

```{r i1_requirements_extension_access04, echo=FALSE, results='asis', eval=extaccess_crit}

cat("#### Extension Access optimality

We used the requirements to construct fuzzy partitions and the data rule bases.")

```

<div class="fold o">   
```{r i1_requirements_extension_access05, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=extaccess_crit}

for (i in 1:(nrow(df_criteria_se4a))) {
  if (!is.na(df_criteria_se4a[i, 18])) {
    # for those criteria with three proposition values
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_criteria_se4a[i, 16]),
        as.character(df_criteria_se4a[i, 17]),
        as.character(df_criteria_se4a[i, 18])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        as.character(df_criteria_se4a[i, 19]),
        as.character(df_criteria_se4a[i, 20]),
        as.character(df_criteria_se4a[i, 21])
      )
    # get  the 2 crossover points
    cross_points <-
      c(df_criteria_se4a[i, 6],
        df_criteria_se4a[i, 7])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_criteria_se4a[i, 8],
        df_criteria_se4a[i, 9])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_criteria_se4a[i, 6] - df_criteria_se4a[i, 8]),
        (df_criteria_se4a[i, 7] + df_criteria_se4a[i, 9]))
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    prop_levels <-
      c(as.character(df_criteria_se4a[i, 16]),
        as.character(df_criteria_se4a[i, 17]))
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(as.character(df_criteria_se4a[i, 19]),
        as.character(df_criteria_se4a[i, 20]))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_criteria_se4a[i, 6])
    
    # get  the 1 transition width
    trans_width <-
      c(df_criteria_se4a[i, 8])
    
    # get  the 1 xlim for the plot
    plot_xlim <-
      c((df_criteria_se4a[i, 6] - df_criteria_se4a[i, 8]),
        (df_criteria_se4a[i, 6] + df_criteria_se4a[i, 8]))
    
  }
  assign(
    paste0("fp_", df_criteria_se4a[i, 3]),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  plot_fp <-
    plot(
      get(paste0("fp_", df_criteria_se4a[i, 3])),
      xlim = plot_xlim,
      xlab = as.character(df_criteria_se4a[i, 4]),
      title = "fuzzy partition"
    )
  print(plot_fp)
  
  # construct the rule bases
  
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_se4a[i, 3]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_criteria_se4a[i, 3]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                df_criteria_se4a[i, 3]),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0("rb_",
                   df_criteria_se4a[i, 3])))
  
  # apply the fuzzy partitions to the data
  
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    df_criteria_se4a[i, 3],
    ", newdata = df_irm,",
    df_criteria_se4a[i, 3],
    "=",
    "fp_",
    df_criteria_se4a[i, 3],
    ")"
  )
  
  # evaluate the rule base and create the fpm
  
  assign(paste0("fpm_",
                df_criteria_se4a[i, 3]), eval(parse(text = x)))
  
  # get the membership values from the fpm
  
  g_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se4a[i, 3]))$good)
  p_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se4a[i, 3]))$poor)
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_se4a[i, 3], "_g")) := g_col, .keep = c("all"))
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_se4a[i, 3], "_p")) := p_col, .keep = c("all"))
  
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se4a[i, 3], "_g")), as.character(paste0(df_criteria_se4a[i, 3], "_p")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se4a[i, 4], " good")), as.character(paste0(df_criteria_se4a[i, 4], " poor")))
  fpm_plot_title <-
    "Extension\nAccess\noptimality\nmembership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
  print(plot_fpm)
  
  
}

``` 
</div>

```{r i1_requirements_labour_access01, echo=FALSE, results='asis', eval=lab_crit}

cat("### Labour requirements")

```

```{r i1_requirements_labour_access02, results='asis', warning=FALSE, eval=lab_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria


df_criteria_se4b <-
  subset(df_priorities, grepl("^se_4b", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cse4b <- nrow(df_criteria_se4b)
cat(paste(n_cse4b, "Labour criteria: \n\n"))

# then determine and print the names of the rule bases in the Labour theme
# here in contrast to the previous themes we need to account for criteria which have no data but instead use rule base stacks - these are removed now from the criteria data frame and evaluated later

data_rulebase <- !is.na(df_criteria_se4b$data_file_prefix)
df_criteria_se4b <- df_criteria_se4b[data_rulebase,]

n_cse4b <- nrow(df_criteria_se4b)

cat(paste(n_cse4b, "Labour data rule bases:\n\n"))
for (i in 1:n_cse4b) {
  cat(paste(df_criteria_se4b[i, 3], "\n", df_criteria_se4b[i, 4],"\n"))
}

```

<div class="fold o">   
```{r i1_requirements_labour_access03, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=lab_crit}

for (i in 1:n_cse4b) {
  new_col <-
    get(paste0("rast_", df_criteria_se4b[i, 11], "_rsmp")) %>% terra::extract(xy) # extract the raster values using xy points
  
  new_col <- new_col[[1]]
  
  
  
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_se4b[i, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm tibble, this needs to be dynamic so uses the !! and := operators
  
}

```
</div>

```{r i1_requirements_labour_access04, echo=FALSE, results='asis', eval=lab_crit}

cat("#### Labour optimality

We used the requirements to construct fuzzy partitions and the data rule bases.")

```


<div class="fold o">   
```{r i1_requirements_labour_access05, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=lab_crit}

for (i in 1:(nrow(df_criteria_se4b))) {
  if (!is.na(df_criteria_se4b[i, 18])) {
    # for those criteria with three proposition values
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_criteria_se4b[i, 16]),
        as.character(df_criteria_se4b[i, 17]),
        as.character(df_criteria_se4b[i, 18])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        as.character(df_criteria_se4b[i, 19]),
        as.character(df_criteria_se4b[i, 20]),
        as.character(df_criteria_se4b[i, 21])
      )
    # get  the 2 crossover points
    cross_points <-
      c(df_criteria_se4b[i, 6],
        df_criteria_se4b[i, 7])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_criteria_se4b[i, 8],
        df_criteria_se4b[i, 9])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_criteria_se4b[i, 6] - df_criteria_se4b[i, 8]),
        (df_criteria_se4b[i, 7] + df_criteria_se4b[i, 9]))
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    prop_levels <-
      c(as.character(df_criteria_se4b[i, 16]),
        as.character(df_criteria_se4b[i, 17]))
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(as.character(df_criteria_se4b[i, 19]),
        as.character(df_criteria_se4b[i, 20]))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_criteria_se4b[i, 6])
    
    # get  the 1 transition width
    trans_width <-
      c(df_criteria_se4b[i, 8])
    
    # get  the 1 xlim for the plot
    plot_xlim <-
      c((df_criteria_se4b[i, 6] - df_criteria_se4b[i, 8]),
        (df_criteria_se4b[i, 6] + df_criteria_se4b[i, 8]))
    
  }
  assign(
    paste0("fp_", df_criteria_se4b[i, 3]),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  plot_fp <-
    plot(
      get(paste0("fp_", df_criteria_se4b[i, 3])),
      xlim = plot_xlim,
      xlab = as.character(df_criteria_se4b[i, 4]),
      title = "fuzzy partition"
    )
  print(plot_fp)
  
  # construct the rule bases
  
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_se4b[i, 3]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_criteria_se4b[i, 3]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                df_criteria_se4b[i, 3]),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0("rb_",
                   df_criteria_se4b[i, 3])))
  
  # apply the fuzzy partitions to the data
  
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    df_criteria_se4b[i, 3],
    ", newdata = df_irm,",
    df_criteria_se4b[i, 3],
    "=",
    "fp_",
    df_criteria_se4b[i, 3],
    ")"
  )
  
  # evaluate the rule base and create the fpm
  
  assign(paste0("fpm_",
                df_criteria_se4b[i, 3]), eval(parse(text = x)))
  
  # get the membership values from the fpm
  
  g_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se4b[i, 3]))$good)
  p_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se4b[i, 3]))$poor)
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_se4b[i, 3], "_g")) := g_col, .keep = c("all"))
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_se4b[i, 3], "_p")) := p_col, .keep = c("all"))
  
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se4b[i, 3], "_g")), as.character(paste0(df_criteria_se4b[i, 3], "_p")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se4b[i, 4], " good")), as.character(paste0(df_criteria_se4b[i, 4], " poor")))
  fpm_plot_title <-
    "Labour\noptimality\nmembership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
  print(plot_fpm)
  
  
}

``` 
</div>

```{r i1_requirements_fp_access01, echo=FALSE, results='asis', eval=fp_crit}

cat("### Fertilisers and Pesticides requirements")

```


```{r i1_requirements_fp_access02, results='asis', warning=FALSE, eval=fp_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria

df_criteria_se4c <-
  subset(df_priorities, grepl("^se_4c", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cse4c <- nrow(df_criteria_se4c)
cat(paste(n_cse4c, "Fertilisers and Pesticides criteria: \n\n"))

# then determine and print the names of the rule bases in the Fertilisers and Pesticides theme
# here in contrast to the previous themes we need to account for criteria which have no data but instead use rule base stacks - these are removed now from the criteria data frame and evaluated later

data_rulebase <- !is.na(df_criteria_se4c$data_file_prefix)
df_criteria_se4c <- df_criteria_se4c[data_rulebase,]

n_cse4c <- nrow(df_criteria_se4c)

cat(paste(n_cse4c, "Fertilisers and Pesticides data rule bases:\n\n"))
for (i in 1:n_cse4c) {
  cat(paste(df_criteria_se4c[i, 3], "\n", df_criteria_se4c[i, 4],"\n"))
}

```

<div class="fold o">   
```{r i1_requirements_fp_access03, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=fp_crit}

for (i in 1:n_cse4c) {
  new_col <-
    get(paste0("rast_", df_criteria_se4c[i, 11], "_rsmp")) %>% terra::extract(xy) # extract the raster values using xy points
  
  new_col <- new_col[[1]]
  
  
  
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_se4c[i, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm tibble, this needs to be dynamic so uses the !! and := operators
  
}

```
</div>

```{r i1_requirements_fp_access04, echo=FALSE, results='asis', eval=fp_crit}

cat("#### Fertilisers and Pesticides optimality

We used the requirements to construct fuzzy partitions and the data rule bases.")

```


<div class="fold o">   
```{r i1_requirements_fp_access05, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=fp_crit}

for (i in 1:(nrow(df_criteria_se4c))) {
  if (!is.na(df_criteria_se4c[i, 18])) {
    # for those criteria with three proposition values
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_criteria_se4c[i, 16]),
        as.character(df_criteria_se4c[i, 17]),
        as.character(df_criteria_se4c[i, 18])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        as.character(df_criteria_se4c[i, 19]),
        as.character(df_criteria_se4c[i, 20]),
        as.character(df_criteria_se4c[i, 21])
      )
    # get  the 2 crossover points
    cross_points <-
      c(df_criteria_se4c[i, 6],
        df_criteria_se4c[i, 7])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_criteria_se4c[i, 8],
        df_criteria_se4c[i, 9])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_criteria_se4c[i, 6] - df_criteria_se4c[i, 8]),
        (df_criteria_se4c[i, 7] + df_criteria_se4c[i, 9]))
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    prop_levels <-
      c(as.character(df_criteria_se4c[i, 16]),
        as.character(df_criteria_se4c[i, 17]))
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(as.character(df_criteria_se4c[i, 19]),
        as.character(df_criteria_se4c[i, 20]))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_criteria_se4c[i, 6])
    
    # get  the 1 transition width
    trans_width <-
      c(df_criteria_se4c[i, 8])
    
    # get  the 1 xlim for the plot
    plot_xlim <-
      c((df_criteria_se4c[i, 6] - df_criteria_se4c[i, 8]),
        (df_criteria_se4c[i, 6] + df_criteria_se4c[i, 8]))
    
  }
  assign(
    paste0("fp_", df_criteria_se4c[i, 3]),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  plot_fp <-
    plot(
      get(paste0("fp_", df_criteria_se4c[i, 3])),
      xlim = plot_xlim,
      xlab = as.character(df_criteria_se4c[i, 4]),
      title = "fuzzy partition"
    )
  print(plot_fp)
  
  # construct the rule bases
  
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_se4c[i, 3]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_criteria_se4c[i, 3]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                df_criteria_se4c[i, 3]),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0("rb_",
                   df_criteria_se4c[i, 3])))
  
  # apply the fuzzy partitions to the data
  
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    df_criteria_se4c[i, 3],
    ", newdata = df_irm,",
    df_criteria_se4c[i, 3],
    "=",
    "fp_",
    df_criteria_se4c[i, 3],
    ")"
  )
  
  # evaluate the rule base and create the fpm
  
  assign(paste0("fpm_",
                df_criteria_se4c[i, 3]), eval(parse(text = x)))
  
  # get the membership values from the fpm
  
  g_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se4c[i, 3]))$good)
  p_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se4c[i, 3]))$poor)
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_se4c[i, 3], "_g")) := g_col, .keep = c("all"))
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_se4c[i, 3], "_p")) := p_col, .keep = c("all"))
  
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se4c[i, 3], "_g")), as.character(paste0(df_criteria_se4c[i, 3], "_p")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se4c[i, 4], " good")), as.character(paste0(df_criteria_se4c[i, 4], " poor")))
  fpm_plot_title <-
    "Fertilisers\nand Pesticides\noptimality\nmembership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
  print(plot_fpm)
  
  
}

``` 
</div>

# Rule Base Creation and Evaluation

We will not construct one big rule base but follow a hierarchical approach consisting of many small interrelated rule bases for the following reasons:

- one big rule base is hard, if not impossible, to understand
- a set of smaller hierarchically organised rule bases gives more information about the limiting factors
- a hierarchically structured rule base is much faster and less memory demanding.
- a hierarchically structured rule base gives exactly the same results as one big rule base.

If we have both bio-physical and socio-economic criteria then these have separate rule bases, and are combined to give the Likelihood for Adoption.

```{r i1_rulebases_ba01, echo=FALSE, results='asis', eval=ba_crit}
cat("## Bio-physical rule bases

There are no weights attached to the biophysical rule bases and it would be possible to create a single rule base with each criterion as propositions. However, this would be difficult to visualise and to interpret.

By constructing and evaluating smaller thematic rule bases it is possible to identify criteria that limit the biophysical aptitude.
")
```

```{r i1_rulebases_land01, echo=FALSE, results='asis', eval=land_crit}

cat("### Land rule bases

")
```

<div class="fold o"> 
```{r i1_rulebases_land02, cache = TRUE, warning=FALSE, eval=land_crit}

  df_criteria_ba1_2a <-
    subset(df_priorities, grepl("^ba_2a", df_priorities$rulebase_number)) # use regular expressions to find criteria
  n_cba1_2a <- nrow(df_criteria_ba1_2a)
  
  # put the rulebase in a list for use later in the overall biophysical aptitude
  
  assign(paste0("rbs_", df_criteria_ba1_2a[1, 3], "_list"),
         paste0("rb_", df_criteria_ba1_2a[1, 3])) # initialise the rule base list
  
  # get a list of the fuzzy partitions
  assign(
    paste0("fp_", df_criteria_ba1_2a[1, 3], "_list"),
    paste0( df_criteria_ba1_2a[1, 3]," = fp_",
    df_criteria_ba1_2a[1, 3] ))


```
</div>

```{r i1_rulebases_clim01, echo=FALSE, results='asis', eval=clim_crit}

cat("### Climatic rule bases")
```

```{r i1_rulebases_prec01, echo=FALSE, results='asis', eval=prec_crit}

cat("#### Precipitation rule bases

")
```


<div class="fold o"> 
```{r i1_rulebases_prec02, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, warning=FALSE, eval=prec_crit}

df_criteria_ba2b_3a <-
  subset(df_priorities, grepl("^ba_3a", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cba2b_3a <- nrow(df_criteria_ba2b_3a)

# df_criteria_ba3a includes all of the precipitation criteria
# for each criterion we know that the new proposition is the same as the conclusion from the previous rule base

assign(paste0("rbs_", df_criteria_ba2b_3a[1, 3], "_list"), c()) # initialise the rule base list
assign(paste0("fp_", df_criteria_ba2b_3a[1, 3], "_list"), c()) # initialise the fuzzy partition list
rm(df_prop) # remove previous instances of df_prop
rm(df_conc) # remove previous instances of df_prop
rm(prop)
rm(conc)
for (i in 1:(nrow(df_criteria_ba3a))) {
  if (!is.na(df_criteria_ba3a[i, 18])) {
    # set the proposition name
    Prop_name <-
      paste0(as.character(df_criteria_ba3a[i, 3]), "_o")
    
    # for those criteria with three conclusion values
    # get  the 3 conclusion levels and get the unique values
    prop_levels <-
      c(
        as.character(df_criteria_ba3a[i, 19]),
        as.character(df_criteria_ba3a[i, 20]),
        as.character(df_criteria_ba3a[i, 21])
      )  %>% unique()
    
    
    
    # set the proposition values
    if (!exists("df_prop")) {
      df_prop <- tibble(!!Prop_name := c(prop_levels))
    } else {
      #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
      df_prop <-
        bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
    }
    
    # get a list of the previous rule bases
    assign(paste0("rbs_", df_criteria_ba2b_3a[1, 3], "_list"),
           append(get(
             paste0("rbs_", df_criteria_ba2b_3a[1, 3], "_list")
           ), paste0("rb_", df_criteria_ba3a[i, 3])))
    
    # get a list of the fuzzy partitions
    assign(paste0("fp_", df_criteria_ba2b_3a[1, 3], "_list"),
           append(
             get(paste0("fp_", df_criteria_ba2b_3a[1, 3], "_list")),
             paste0(df_criteria_ba3a[i, 3], " = fp_", df_criteria_ba3a[i, 3])
           ))
  } else {
    # set the proposition name
    Prop_name <-
      paste0(as.character(df_criteria_ba3a[i, 3]), "_o")
    
    # for those criteria with two conclusion values
    # get  the 2 conclusion levels and get the unique values
    prop_levels <-
      c(as.character(df_criteria_ba3a[i, 19]),
        as.character(df_criteria_ba3a[i, 20]))  %>% unique()
    
    
    # set the proposition values
    if (!exists("df_prop")) {
      df_prop <- tibble(!!Prop_name := c(prop_levels))
    } else {
      #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
      df_prop <-
        bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
    }
    
    # get a list of the previous rule bases
    assign(paste0("rbs_", df_criteria_ba2b_3a[1, 3], "_list"),
           append(get(
             paste0("rbs_", df_criteria_ba2b_3a[1, 3], "_list")
           ), paste0("rb_", df_criteria_ba3a[i, 3])))
    
    # get a list of the fuzzy partitions
    assign(paste0("fp_", df_criteria_ba2b_3a[1, 3], "_list"),
           append(
             get(paste0("fp_", df_criteria_ba2b_3a[1, 3], "_list")),
             paste0(df_criteria_ba3a[i, 3], " = fp_", df_criteria_ba3a[i, 3])
           ))
    
  }
}

# new proposition object is made here
prop <- new("Proposition", table = df_prop %>% cross_df)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here
# needs to moe or less replicate the original ifelse construction:

#  df_conc <-
#    mutate(tbl_prop_cross, P = ifelse(((tbl_prop_cross[1] == "optimal") &
#                                     (tbl_prop_cross[2] == "optimal") &
#                                     (tbl_prop_cross[3] == "optimal") &
#                                     (tbl_prop_cross[4] == "optimal")
#    ), "optimal", "suboptimal")) %>% dplyr::select(P) # this works


#z <- paste0("ifelse (1 == 1, 1, 2)")
#y <- eval(parse(text = "ifelse(1==1, 1,2)"))
#y <- NULL
#y <- eval(parse(text = z)) # this works

#z <- paste0("ifelse (1 == 1, \"optimal\", \"suboptimal\")")
#y <- NULL
#y <- eval(parse(text = z)) # this works

#z <- paste0(
#  "ifelse (((tbl_prop_cross[1] == \"optimal\") &
#                                   (tbl_prop_cross[2] == \"optimal\") &
#                                   (tbl_prop_cross[3] == \"optimal\") &
#                                   (tbl_prop_cross[4] == \"optimal\")
#  ), \"optimal\", \"suboptimal\")"
#)
#y <- NULL
#y <- eval(parse(text = z)) # this works


# build the ifelse expression based on number of propositions

x <- 1
z <- NULL
while (x <= n_prop)  {
  z <- paste0(z, "(tbl_prop_cross[", x, "] == \"optimal\") &")
  x <- x + 1
}

z <-
  paste0("ifelse ((", z, " 1 == 1), \"optimal\", \"suboptimal\")")
df_conc <- NULL

# evaluate the ifelse expression to produce a conclusion table and class
df_conc <- eval(parse(text = z)) %>% as_tibble()
names(df_conc) <- df_criteria_ba2b_3a[1, 3] # this works
conc <- new("Conclusion", table = df_conc)

# create a rule base
assign(paste0("rb_", df_criteria_ba2b_3a[1, 3]), RuleBase(prop, conc)) %>% print()

#           RuleBase <- RuleBase(prop, conc) %>% print()


# add to the list of previous rule bases

assign(paste0("rbs_", df_criteria_ba2b_3a[1, 3], "_list"),
       append(get(
         paste0("rbs_", df_criteria_ba2b_3a[1, 3], "_list")
       ), paste0("rb_", df_criteria_ba2b_3a[1, 3])))

# create the rule base stack from the list

# original rbs_prec_aptitude <- stack(rb_prec_g_4a, rb_prec_v_4b, rb_prec_f_4c, rb_prec_r_4d, rb_P_3a)

#assign(
#  paste0("rbs_", df_criteria_ba3a[1, 3]),
#  stack(rb_ba_4a, rb_ba_4b, rb_ba_4c, rb_ba_4d, rb_ba_3a)
#) # this works

#x <- rbs_ba_4a_list
#print(x)

#x <- paste0(rbs_ba_4a_list, sep = ",")
#print(x)

#x <- paste0(rbs_ba_4a_list, sep = ",", collapse = "")
#print(x)

#x <- gsub(",$", "", paste0(rbs_ba_4a_list, sep = ",", collapse = ""))
#print(x)

#x <-
#  paste("stack(", gsub(",$", "", paste0(
#    rbs_ba_4a_list, sep = ",", collapse = ""
#  )), ")")
#print(x)

x <-
  paste("stack(", gsub(",$", "", paste0(
    get(paste0("rbs_", df_criteria_ba2b_3a[1, 3], "_list")), sep = ",", collapse = ""
  )), ")")

rbs_prec <-
  assign(paste0("rbs_", df_criteria_ba2b_3a[1, 3]), eval(parse(text = x)))

# evaluate the rule base stack
# this is the original

#fpm_prec <-
# predict(
#      rbs_prec_aptitude,
#      newdata = df_irm,
#      P_g = fp_prec_g,
#      P_v = fp_prec_v,
#      P_f = fp_prec_f,
#     P_r = fp_prec_r
#  )

# add to the list of previous rule bases



w <-
  paste("predict(",
        "rbs_prec, newdata = df_irm,",
        gsub(",$", "", paste0(
          get(paste0("fp_", df_criteria_ba2b_3a[1, 3], "_list")), sep = ",", collapse = ""
        )),
        ")")

assign(paste0("fpm_", df_criteria_ba2b_3a[1, 3]), eval(parse(text = w)))


o_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba2b_3a[1, 3]))$optimal)
s_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba2b_3a[1, 3]))$suboptimal)
df_irm <-
  mutate(df_irm, !!as.character(paste0(df_criteria_ba2b_3a[1, 3], "_o")) := o_col, .keep = c("all"))
df_irm <-
  mutate(df_irm, !!as.character(paste0(df_criteria_ba2b_3a[1, 3], "_s")) := s_col, .keep = c("all"))

n = 2
fpm_conc_var <-
  c(as.character(paste0(df_criteria_ba2b_3a[1, 3], "_o")), as.character(paste0(df_criteria_ba2b_3a[1, 3], "_s")), "x" , "y")
fpm_conc_name <-
  c(as.character(paste0(df_criteria_ba2b_3a[1, 4], " optimal")), as.character(paste0(df_criteria_ba2b_3a[1, 4], " suboptimal")))
fpm_plot_title <-
  "Precipitation optimality membership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
print(plot_fpm)

```
</div>

```{r i1_rulebases_tmp01, echo=FALSE, results='asis', eval=tmp_crit}

cat("#### Temperature rule bases

")
```

<div class="fold o"> 
```{r i1_rulebases_tmp02, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, warning=FALSE, eval=tmp_crit}

df_criteria_ba2b_3b <-
  subset(df_priorities, grepl("^ba_3b", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cba2b_3b <- nrow(df_criteria_ba2b_3b)

# df_criteria_ba3b includes all of the temperature criteria
# for each criterion we know that the new proposition is the same as the conclusion from the previous rule base

assign(paste0("rbs_", df_criteria_ba2b_3b[1, 3], "_list"), c()) # initialise the rule base list
assign(paste0("fp_", df_criteria_ba2b_3b[1, 3], "_list"), c()) # initialise the fuzzy partition list
rm(df_prop) # remove previous instances of df_prop
rm(df_conc) # remove previous instances of df_prop
rm(prop)
rm(conc)
for (i in 1:(nrow(df_criteria_ba3b))) {
  if (!is.na(df_criteria_ba3b[i, 18])) {
    # set the proposition name
    Prop_name <-
      paste0(as.character(df_criteria_ba3b[i, 3]), "_o")
    
    # for those criteria with three conclusion values
    # get  the 3 conclusion levels and get the unique values
    prop_levels <-
      c(
        as.character(df_criteria_ba3b[i, 19]),
        as.character(df_criteria_ba3b[i, 20]),
        as.character(df_criteria_ba3b[i, 21])
      )  %>% unique()
    
    
    
    # set the proposition values
    if (!exists("df_prop")) {
      df_prop <- tibble(!!Prop_name := c(prop_levels))
    } else {
      #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
      df_prop <-
        bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
    }
    
    # get a list of the previous rule bases
    assign(paste0("rbs_", df_criteria_ba2b_3b[1, 3], "_list"),
           append(get(
             paste0("rbs_", df_criteria_ba2b_3b[1, 3], "_list")
           ), paste0("rb_", df_criteria_ba3b[i, 3])))
    
    # get a list of the fuzzy partitions
    assign(paste0("fp_", df_criteria_ba2b_3b[1, 3], "_list"),
           append(
             get(paste0("fp_", df_criteria_ba2b_3b[1, 3], "_list")),
             paste0(df_criteria_ba3b[i, 3], " = fp_", df_criteria_ba3b[i, 3])
           ))
  }
}

# new proposition object is made here
prop <- new("Proposition", table = df_prop %>% cross_df)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here
# needs to more or less replicate the original ifelse construction:

# build the ifelse expression based on number of propositions

x <- 1
z <- NULL
while (x <= n_prop)  {
  z <- paste0(z, "(tbl_prop_cross[", x, "] == \"optimal\") &")
  x <- x + 1
}

z <-
  paste0("ifelse ((", z, " 1 == 1), \"optimal\", \"suboptimal\")")
df_conc <- NULL

# evaluate the ifelse expression to produce a conclusion table and class
df_conc <- eval(parse(text = z)) %>% as_tibble()
names(df_conc) <- df_criteria_ba2b_3b[1, 3] # this works
conc <- new("Conclusion", table = df_conc)

# create a rule base
assign(paste0("rb_", df_criteria_ba2b_3b[1, 3]), RuleBase(prop, conc)) %>% print()


# add to the list of previous rule bases

assign(paste0("rbs_", df_criteria_ba2b_3b[1, 3], "_list"),
       append(get(
         paste0("rbs_", df_criteria_ba2b_3b[1, 3], "_list")
       ), paste0("rb_", df_criteria_ba2b_3b[1, 3])))

# create the rule base stack from the list

# original rbs_tmp_aptitude <- stack(rb_tmp_g_4a, rb_tmp_v_4b, rb_tmp_f_4c, rb_tmp_r_4d, rb_P_3a)

x <-
  paste("stack(", gsub(",$", "", paste0(
    get(paste0("rbs_", df_criteria_ba2b_3b[1, 3], "_list")), sep = ",", collapse = ""
  )), ")")

rbs_tmp <-
  assign(paste0("rbs_", df_criteria_ba2b_3b[1, 3]), eval(parse(text = x)))

# evaluate the rule base stack

w <-
  paste("predict(",
        "rbs_tmp, newdata = df_irm,",
        gsub(",$", "", paste0(
          get(paste0("fp_", df_criteria_ba2b_3b[1, 3], "_list")), sep = ",", collapse = ""
        )),
        ")")

assign(paste0("fpm_", df_criteria_ba2b_3b[1, 3]), eval(parse(text = w)))


o_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba2b_3b[1, 3]))$optimal)
s_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba2b_3b[1, 3]))$suboptimal)
df_irm <-
  mutate(df_irm, !!as.character(paste0(df_criteria_ba2b_3b[1, 3], "_o")) := o_col, .keep = c("all"))
df_irm <-
  mutate(df_irm, !!as.character(paste0(df_criteria_ba2b_3b[1, 3], "_s")) := s_col, .keep = c("all"))

n = 2
fpm_conc_var <-
  c(as.character(paste0(df_criteria_ba2b_3b[1, 3], "_o")), as.character(paste0(df_criteria_ba2b_3b[1, 3], "_s")), "x" , "y")
fpm_conc_name <-
  c(as.character(paste0(df_criteria_ba2b_3b[1, 4], " optimal")), as.character(paste0(df_criteria_ba2b_3b[1, 4], " suboptimal")))
fpm_plot_title <-
  "Temperature\noptimality\nmembership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
print(plot_fpm)


```
</div>

```{r i1_rulebases_clim02, echo=FALSE, results='asis', eval=clim_crit}

cat("#### Combined Climatic Aptitude rule bases

")

```

<div class="fold o"> 
```{r i1_rulebases_clim03, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, warning=FALSE, eval=prec_crit, eval=tmp_crit}

# need to join the rule base stacks for precipitation and temperature

df_criteria_ba1_2b <-
  subset(df_priorities, grepl("^ba_2b", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cba1_2b <- nrow(df_criteria_ba1_2b)

df_criteria_ba2b <-
  subset(df_priorities, grepl("^ba_2b", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cba2b <- nrow(df_criteria_ba2b)

assign(paste0("rbs_", df_criteria_ba2b[1, 2], "_list"), c()) # initialise the rule base list
assign(paste0("fp_", df_criteria_ba2b[1, 2], "_list"), c()) # initialise the fuzzy partition list

# need to construct a new rule base for climatic aptitude and add this to the combined rule base stacks and fill the rb and fp lists


rm(df_prop) # remove previous instances of df_prop
rm(df_conc) # remove previous instances of df_prop
rm(prop)
rm(conc)

for (i in 1:n_cba2b) {
  assign(paste0("rbs_", df_criteria_ba2b[1, 2], "_list"),
         append(get(
           paste0("rbs_", df_criteria_ba2b[1, 2], "_list")
         ), get(
           paste0("rbs_", df_criteria_ba2b[i, 3], "_list")
         )))
  
  assign(paste0("fp_", df_criteria_ba2b[1, 2], "_list"),
         append(get(paste0(
           "fp_", df_criteria_ba2b[1, 2], "_list"
         )), get(paste0(
           "fp_", df_criteria_ba2b[i, 3], "_list"
         ))))
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_ba2b[i, 3]))
  
  # get  the 2 conclusion levels and get the unique values
  prop_levels <-
    c(as.character(df_criteria_ba2b[i, 19]),
      as.character(df_criteria_ba2b[i, 20]))  %>% unique()
  
  
  # set the proposition values
  if (!exists("df_prop")) {
    df_prop <- tibble(!!Prop_name := c(prop_levels))
  } else {
    #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
    df_prop <-
      bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
  }
}


# new proposition object is made here
prop <- new("Proposition", table = df_prop %>% cross_df)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here
# needs to more or less replicate the original ifelse construction:

# build the ifelse expression based on number of propositions

x <- 1
z <- NULL
while (x <= n_prop)  {
  z <- paste0(z, "(tbl_prop_cross[", x, "] == \"optimal\") &")
  x <- x + 1
}

z <-
  paste0("ifelse ((", z, " 1 == 1), \"optimal\", \"suboptimal\")")
df_conc <- NULL

# evaluate the ifelse expression to produce a conclusion table and class
df_conc <- eval(parse(text = z)) %>% as_tibble()
names(df_conc) <- df_criteria_ba2b[1, 2] # this works
conc <- new("Conclusion", table = df_conc)

# create a rule base
assign(paste0("rb_", df_criteria_ba2b[1, 2]), RuleBase(prop, conc)) %>% print()

# add to the list of previous rule bases

assign(paste0("rbs_", df_criteria_ba2b[1, 2], "_list"),
       append(get(paste0(
         "rbs_", df_criteria_ba2b[1, 2], "_list"
       )), paste0("rb_", df_criteria_ba2b[1, 2])))



# create the rule base stack from the list

# original rbs_tmp_aptitude <- stack(rb_tmp_g_4a, rb_tmp_v_4b, rb_tmp_f_4c, rb_tmp_r_4d, rb_P_3a)

x <-
  paste("stack(", gsub(",$", "", paste0(
    get(paste0("rbs_", df_criteria_ba2b[1, 2], "_list")), sep = ",", collapse = ""
  )), ")")

rbs_tmp <-
  assign(paste0("rbs_", df_criteria_ba2b[1, 2]), eval(parse(text = x)))

# evaluate the rule base stack

w <-
  paste("predict(",
        "rbs_tmp, newdata = df_irm,",
        gsub(",$", "", paste0(
          get(paste0("fp_", df_criteria_ba2b[1, 2], "_list")), sep = ",", collapse = ""
        )),
        ")")

assign(paste0("fpm_", df_criteria_ba2b[1, 2]), eval(parse(text = w)))


o_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba2b[1, 2]))$optimal)
s_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba2b[1, 2]))$suboptimal)
df_irm <-
  mutate(df_irm, !!as.character(paste0(df_criteria_ba2b[1, 2], "_o")) := o_col, .keep = c("all"))
df_irm <-
  mutate(df_irm, !!as.character(paste0(df_criteria_ba2b[1, 2], "_s")) := s_col, .keep = c("all"))

n = 2
fpm_conc_var <-
  c(as.character(paste0(df_criteria_ba2b[1, 2], "_o")), as.character(paste0(df_criteria_ba2b[1, 2], "_s")), "x" , "y")
fpm_conc_name <-
  c(as.character(paste0(df_criteria_ba1_2b[1, 4], " optimal")), as.character(paste0(df_criteria_ba1_2b[1, 4], " suboptimal")))
fpm_plot_title <-
  "Climatic Aptitude membership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
print(plot_fpm)


```
</div>


```{r i1_rulebases_soilp01, echo=FALSE, results='asis', eval=soil_p_crit}

cat("### Soil physical properties rule bases

")

```

<div class="fold o"> 
```{r i1_rulebases_soilp02, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, warning=FALSE, eval=soil_p_crit}

df_criteria_ba1_2c <-
  subset(df_priorities, grepl("^ba_2c", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cba1_2c <- nrow(df_criteria_ba1_2c)

# df_criteria_ba2c includes all of the soil physical properties criteria
# for each criterion we know that the new proposition is the same as the conclusion from the previous rule base

assign(paste0("rbs_", df_criteria_ba1_2c[1, 3], "_list"), c()) # initialise the rule base list
assign(paste0("fp_", df_criteria_ba1_2c[1, 3], "_list"), c()) # initialise the fuzzy partition list
rm(df_prop) # remove previous instances of df_prop
rm(df_conc) # remove previous instances of df_prop
rm(prop)
rm(conc)
for (i in 1:(nrow(df_criteria_ba2c))) {
  if (!is.na(df_criteria_ba2c[i, 18])) {
    # set the proposition name
    Prop_name <-
      paste0(as.character(df_criteria_ba2c[i, 3]), "_o")
    
    # for those criteria with three conclusion values
    # get  the 3 conclusion levels and get the unique values
    prop_levels <-
      c(
        as.character(df_criteria_ba2c[i, 19]),
        as.character(df_criteria_ba2c[i, 20]),
        as.character(df_criteria_ba2c[i, 21])
      )  %>% unique()
    
    
    
    # set the proposition values
    if (!exists("df_prop")) {
      df_prop <- tibble(!!Prop_name := c(prop_levels))
    } else {
      #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
      df_prop <-
        bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
    }
    
    # get a list of the previous rule bases
    assign(paste0("rbs_", df_criteria_ba1_2c[1, 3], "_list"),
           append(get(
             paste0("rbs_", df_criteria_ba1_2c[1, 3], "_list")
           ), paste0("rb_", df_criteria_ba2c[i, 3])))
    
    # get a list of the fuzzy partitions
    assign(paste0("fp_", df_criteria_ba1_2c[1, 3], "_list"),
           append(
             get(paste0("fp_", df_criteria_ba1_2c[1, 3], "_list")),
             paste0(df_criteria_ba2c[i, 3], " = fp_", df_criteria_ba2c[i, 3])
           ))
  } else {
    # set the proposition name
    Prop_name <-
      paste0(as.character(df_criteria_ba2c[i, 3]), "_o")
    
    # for those criteria with two conclusion values
    # get  the 2 conclusion levels and get the unique values
    prop_levels <-
      c(as.character(df_criteria_ba2c[i, 19]),
        as.character(df_criteria_ba2c[i, 20]))  %>% unique()
    
    
    # set the proposition values
    if (!exists("df_prop")) {
      df_prop <- tibble(!!Prop_name := c(prop_levels))
    } else {
      #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
      df_prop <-
        bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
    }
    
    # get a list of the previous rule bases
    assign(paste0("rbs_", df_criteria_ba1_2c[1, 3], "_list"),
           append(get(
             paste0("rbs_", df_criteria_ba1_2c[1, 3], "_list")
           ), paste0("rb_", df_criteria_ba2c[i, 3])))
    
    # get a list of the fuzzy partitions
    assign(paste0("fp_", df_criteria_ba1_2c[1, 3], "_list"),
           append(
             get(paste0("fp_", df_criteria_ba1_2c[1, 3], "_list")),
             paste0(df_criteria_ba2c[i, 3], " = fp_", df_criteria_ba2c[i, 3])
           ))
    
  }
}

# new proposition object is made here
prop <- new("Proposition", table = df_prop %>% cross_df)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here
# needs to more or less replicate the original ifelse construction:

# build the ifelse expression based on number of propositions

x <- 1
z <- NULL
while (x <= n_prop)  {
  z <- paste0(z, "(tbl_prop_cross[", x, "] == \"optimal\") &")
  x <- x + 1
}

z <-
  paste0("ifelse ((", z, " 1 == 1), \"optimal\", \"suboptimal\")")
df_conc <- NULL

# evaluate the ifelse expression to produce a conclusion table and class
df_conc <- eval(parse(text = z)) %>% as_tibble()
names(df_conc) <- df_criteria_ba1_2c[1, 3] # this works
conc <- new("Conclusion", table = df_conc)

# create a rule base
assign(paste0("rb_", df_criteria_ba1_2c[1, 3]), RuleBase(prop, conc)) %>% print()


# add to the list of previous rule bases

assign(paste0("rbs_", df_criteria_ba1_2c[1, 3], "_list"),
       append(get(
         paste0("rbs_", df_criteria_ba1_2c[1, 3], "_list")
       ), paste0("rb_", df_criteria_ba1_2c[1, 3])))

# create the rule base stack from the list

x <-
  paste("stack(", gsub(",$", "", paste0(
    get(paste0("rbs_", df_criteria_ba1_2c[1, 3], "_list")), sep = ",", collapse = ""
  )), ")")

rbs_tmp <-
  assign(paste0("rbs_", df_criteria_ba1_2c[1, 3]), eval(parse(text = x)))

# evaluate the rule base stack

w <-
  paste("predict(",
        "rbs_tmp, newdata = df_irm,",
        gsub(",$", "", paste0(
          get(paste0("fp_", df_criteria_ba1_2c[1, 3], "_list")), sep = ",", collapse = ""
        )),
        ")")

assign(paste0("fpm_", df_criteria_ba1_2c[1, 3]), eval(parse(text = w)))


o_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba1_2c[1, 3]))$optimal)
s_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba1_2c[1, 3]))$suboptimal)
df_irm <-
  mutate(df_irm, !!as.character(paste0(df_criteria_ba1_2c[1, 3], "_o")) := o_col, .keep = c("all"))
df_irm <-
  mutate(df_irm, !!as.character(paste0(df_criteria_ba1_2c[1, 3], "_s")) := s_col, .keep = c("all"))

n = 2
fpm_conc_var <-
  c(as.character(paste0(df_criteria_ba1_2c[1, 3], "_o")), as.character(paste0(df_criteria_ba1_2c[1, 3], "_s")), "x" , "y")
fpm_conc_name <-
  c(as.character(paste0(df_criteria_ba1_2c[1, 4], " optimal")), as.character(paste0(df_criteria_ba1_2c[1, 4], " suboptimal")))
fpm_plot_title <-
  "Soil Physical Properties optimality membership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
print(plot_fpm)


```
</div>

```{r i1_rulebases_soilf01, echo=FALSE, results='asis', eval=soil_f_crit}

cat("### Soil fertility rule bases

")

```

<div class="fold o"> 
```{r i1_rulebases_soilf02, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, warning=FALSE, eval=soil_f_crit}

df_criteria_ba1_2d <-
  subset(df_priorities, grepl("^ba_2d", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cba1_2d <- nrow(df_criteria_ba1_2d)

# df_criteria_ba2d includes all of the soil fertility criteria
# for each criterion we know that the new proposition is the same as the conclusion from the previous rule base

assign(paste0("rbs_", df_criteria_ba1_2d[1, 3], "_list"), c()) # initialise the rule base list
assign(paste0("fp_", df_criteria_ba1_2d[1, 3], "_list"), c()) # initialise the fuzzy partition list
rm(df_prop) # remove previous instances of df_prop
rm(df_conc) # remove previous instances of df_prop
rm(prop)
rm(conc)
for (i in 1:(nrow(df_criteria_ba2d))) {
  if (!is.na(df_criteria_ba2d[i, 18])) {
    # set the proposition name
    Prop_name <-
      paste0(as.character(df_criteria_ba2d[i, 3]), "_o")
    
    # for those criteria with three conclusion values
    # get  the 3 conclusion levels and get the unique values
    prop_levels <-
      c(
        as.character(df_criteria_ba2d[i, 19]),
        as.character(df_criteria_ba2d[i, 20]),
        as.character(df_criteria_ba2d[i, 21])
      )  %>% unique()
    
    
    
    # set the proposition values
    if (!exists("df_prop")) {
      df_prop <- tibble(!!Prop_name := c(prop_levels))
    } else {
      #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
      df_prop <-
        bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
    }
    
    # get a list of the previous rule bases
    assign(paste0("rbs_", df_criteria_ba1_2d[1, 3], "_list"),
           append(get(
             paste0("rbs_", df_criteria_ba1_2d[1, 3], "_list")
           ), paste0("rb_", df_criteria_ba2d[i, 3])))
    
    # get a list of the fuzzy partitions
    assign(paste0("fp_", df_criteria_ba1_2d[1, 3], "_list"),
           append(
             get(paste0("fp_", df_criteria_ba1_2d[1, 3], "_list")),
             paste0(df_criteria_ba2d[i, 3], " = fp_", df_criteria_ba2d[i, 3])
           ))
  } else {
    # set the proposition name
    Prop_name <-
      paste0(as.character(df_criteria_ba2d[i, 3]), "_o")
    
    # for those criteria with two conclusion values
    # get  the 2 conclusion levels and get the unique values
    prop_levels <-
      c(as.character(df_criteria_ba2d[i, 19]),
        as.character(df_criteria_ba2d[i, 20]))  %>% unique()
    
    
    # set the proposition values
    if (!exists("df_prop")) {
      df_prop <- tibble(!!Prop_name := c(prop_levels))
    } else {
      #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
      df_prop <-
        bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
    }
    
    # get a list of the previous rule bases
    assign(paste0("rbs_", df_criteria_ba1_2d[1, 3], "_list"),
           append(get(
             paste0("rbs_", df_criteria_ba1_2d[1, 3], "_list")
           ), paste0("rb_", df_criteria_ba2d[i, 3])))
    
    # get a list of the fuzzy partitions
    assign(paste0("fp_", df_criteria_ba1_2d[1, 3], "_list"),
           append(
             get(paste0("fp_", df_criteria_ba1_2d[1, 3], "_list")),
             paste0(df_criteria_ba2d[i, 3], " = fp_", df_criteria_ba2d[i, 3])
           ))
    
  }
}

# new proposition object is made here
prop <- new("Proposition", table = df_prop %>% cross_df)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here
# needs to more or less replicate the original ifelse construction:

# build the ifelse expression based on number of propositions

x <- 1
z <- NULL
while (x <= n_prop)  {
  z <- paste0(z, "(tbl_prop_cross[", x, "] == \"optimal\") &")
  x <- x + 1
}

z <-
  paste0("ifelse ((", z, " 1 == 1), \"optimal\", \"suboptimal\")")
df_conc <- NULL

# evaluate the ifelse expression to produce a conclusion table and class
df_conc <- eval(parse(text = z)) %>% as_tibble()
names(df_conc) <- df_criteria_ba1_2d[1, 3] # this works
conc <- new("Conclusion", table = df_conc)

# create a rule base
assign(paste0("rb_", df_criteria_ba1_2d[1, 3]), RuleBase(prop, conc)) %>% print()


# add to the list of previous rule bases

assign(paste0("rbs_", df_criteria_ba1_2d[1, 3], "_list"),
       append(get(
         paste0("rbs_", df_criteria_ba1_2d[1, 3], "_list")
       ), paste0("rb_", df_criteria_ba1_2d[1, 3])))

# create the rule base stack from the list

x <-
  paste("stack(", gsub(",$", "", paste0(
    get(paste0("rbs_", df_criteria_ba1_2d[1, 3], "_list")), sep = ",", collapse = ""
  )), ")")

rbs_tmp <-
  assign(paste0("rbs_", df_criteria_ba1_2d[1, 3]), eval(parse(text = x)))

# evaluate the rule base stack

w <-
  paste("predict(",
        "rbs_tmp, newdata = df_irm,",
        gsub(",$", "", paste0(
          get(paste0("fp_", df_criteria_ba1_2d[1, 3], "_list")), sep = ",", collapse = ""
        )),
        ")")

assign(paste0("fpm_", df_criteria_ba1_2d[1, 3]), eval(parse(text = w)))


o_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba1_2d[1, 3]))$optimal)
s_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba1_2d[1, 3]))$suboptimal)
df_irm <-
  mutate(df_irm, !!as.character(paste0(df_criteria_ba1_2d[1, 3], "_o")) := o_col, .keep = c("all"))
df_irm <-
  mutate(df_irm, !!as.character(paste0(df_criteria_ba1_2d[1, 3], "_s")) := s_col, .keep = c("all"))

n = 2
fpm_conc_var <-
  c(as.character(paste0(df_criteria_ba1_2d[1, 3], "_o")), as.character(paste0(df_criteria_ba1_2d[1, 3], "_s")), "x" , "y")
fpm_conc_name <-
  c(as.character(paste0(df_criteria_ba1_2d[1, 4], " optimal")), as.character(paste0(df_criteria_ba1_2d[1, 4], " suboptimal")))
fpm_plot_title <-
  "Soil Fertility optimality membership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
print(plot_fpm)


```
</div>

```{r i1_rulebases_lscape01, echo=FALSE, results='asis', eval=lscape_crit}

cat("### Landscape rule bases

")

```

<div class="fold o"> 
```{r i1_rulebases_lscape02, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, warning=FALSE, eval=lscape_crit}

df_criteria_ba1_2e <-
  subset(df_priorities, grepl("^ba_2e", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cba1_2e <- nrow(df_criteria_ba1_2e)

# df_criteria_ba2e includes all of the landscape criteria
# for each criterion we know that the new proposition is the same as the conclusion from the previous rule base

assign(paste0("rbs_", df_criteria_ba1_2e[1, 3], "_list"), c()) # initialise the rule base list
assign(paste0("fp_", df_criteria_ba1_2e[1, 3], "_list"), c()) # initialise the fuzzy partition list
rm(df_prop) # remove previous instances of df_prop
rm(df_conc) # remove previous instances of df_prop
rm(prop)
rm(conc)
for (i in 1:(nrow(df_criteria_ba2e))) {
  if (!is.na(df_criteria_ba2e[i, 18])) {
    # set the proposition name
    Prop_name <-
      paste0(as.character(df_criteria_ba2e[i, 3]), "_o")
    
    # for those criteria with three conclusion values
    # get  the 3 conclusion levels and get the unique values
    prop_levels <-
      c(
        as.character(df_criteria_ba2e[i, 19]),
        as.character(df_criteria_ba2e[i, 20]),
        as.character(df_criteria_ba2e[i, 21])
      )  %>% unique()
    
    
    
    # set the proposition values
    if (!exists("df_prop")) {
      df_prop <- tibble(!!Prop_name := c(prop_levels))
    } else {
      #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
      df_prop <-
        bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
    }
    
    # get a list of the previous rule bases
    assign(paste0("rbs_", df_criteria_ba1_2e[1, 3], "_list"),
           append(get(
             paste0("rbs_", df_criteria_ba1_2e[1, 3], "_list")
           ), paste0("rb_", df_criteria_ba2e[i, 3])))
    
    # get a list of the fuzzy partitions
    assign(paste0("fp_", df_criteria_ba1_2e[1, 3], "_list"),
           append(
             get(paste0("fp_", df_criteria_ba1_2e[1, 3], "_list")),
             paste0(df_criteria_ba2e[i, 3], " = fp_", df_criteria_ba2e[i, 3])
           ))
  } else {
    # set the proposition name
    Prop_name <-
      paste0(as.character(df_criteria_ba2e[i, 3]), "_o")
    
    # for those criteria with two conclusion values
    # get  the 2 conclusion levels and get the unique values
    prop_levels <-
      c(as.character(df_criteria_ba2e[i, 19]),
        as.character(df_criteria_ba2e[i, 20]))  %>% unique()
    
    
    # set the proposition values
    if (!exists("df_prop")) {
      df_prop <- tibble(!!Prop_name := c(prop_levels))
    } else {
      #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
      df_prop <-
        bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
    }
    
    # get a list of the previous rule bases
    assign(paste0("rbs_", df_criteria_ba1_2e[1, 3], "_list"),
           append(get(
             paste0("rbs_", df_criteria_ba1_2e[1, 3], "_list")
           ), paste0("rb_", df_criteria_ba2e[i, 3])))
    
    # get a list of the fuzzy partitions
    assign(paste0("fp_", df_criteria_ba1_2e[1, 3], "_list"),
           append(
             get(paste0("fp_", df_criteria_ba1_2e[1, 3], "_list")),
             paste0(df_criteria_ba2e[i, 3], " = fp_", df_criteria_ba2e[i, 3])
           ))
    
  }
}

# new proposition object is made here
prop <- new("Proposition", table = df_prop %>% cross_df)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here
# needs to more or less replicate the original ifelse construction:

# build the ifelse expression based on number of propositions

x <- 1
z <- NULL
while (x <= n_prop)  {
  z <- paste0(z, "(tbl_prop_cross[", x, "] == \"optimal\") &")
  x <- x + 1
}

z <-
  paste0("ifelse ((", z, " 1 == 1), \"optimal\", \"suboptimal\")")
df_conc <- NULL

# evaluate the ifelse expression to produce a conclusion table and class
df_conc <- eval(parse(text = z)) %>% as_tibble()
names(df_conc) <- df_criteria_ba1_2e[1, 3] # this works
conc <- new("Conclusion", table = df_conc)

# create a rule base
assign(paste0("rb_", df_criteria_ba1_2e[1, 3]), RuleBase(prop, conc)) %>% print()


# add to the list of previous rule bases

assign(paste0("rbs_", df_criteria_ba1_2e[1, 3], "_list"),
       append(get(
         paste0("rbs_", df_criteria_ba1_2e[1, 3], "_list")
       ), paste0("rb_", df_criteria_ba1_2e[1, 3])))

# create the rule base stack from the list

x <-
  paste("stack(", gsub(",$", "", paste0(
    get(paste0("rbs_", df_criteria_ba1_2e[1, 3], "_list")), sep = ",", collapse = ""
  )), ")")

rbs_tmp <-
  assign(paste0("rbs_", df_criteria_ba1_2e[1, 3]), eval(parse(text = x)))

# evaluate the rule base stack

w <-
  paste("predict(",
        "rbs_tmp, newdata = df_irm,",
        gsub(",$", "", paste0(
          get(paste0("fp_", df_criteria_ba1_2e[1, 3], "_list")), sep = ",", collapse = ""
        )),
        ")")

assign(paste0("fpm_", df_criteria_ba1_2e[1, 3]), eval(parse(text = w)))


o_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba1_2e[1, 3]))$optimal)
s_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba1_2e[1, 3]))$suboptimal)
df_irm <-
  mutate(df_irm, !!as.character(paste0(df_criteria_ba1_2e[1, 3], "_o")) := o_col, .keep = c("all"))
df_irm <-
  mutate(df_irm, !!as.character(paste0(df_criteria_ba1_2e[1, 3], "_s")) := s_col, .keep = c("all"))

n = 2
fpm_conc_var <-
  c(as.character(paste0(df_criteria_ba1_2e[1, 3], "_o")), as.character(paste0(df_criteria_ba1_2e[1, 3], "_s")), "x" , "y")
fpm_conc_name <-
  c(as.character(paste0(df_criteria_ba1_2e[1, 4], " optimal")), as.character(paste0(df_criteria_ba1_2e[1, 4], " suboptimal")))
fpm_plot_title <-
  "Landscape optimality membership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
print(plot_fpm)


```
</div>

```{r i1_rulebases_ba02, echo=FALSE, results='asis', eval=ba_crit}

cat("### Combined Biophysical Aptitude - two class rule bases

")

```

<div class="fold o"> 
```{r i1_rulebases_ba03, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, warning=FALSE, eval=ba_crit}

# need to join the rule base stacks for all biophysical criteria themes 

  df_criteria_suit <-
    subset(df_priorities, grepl("^ba_1", df_priorities$rulebase_number)) # use regular expressions to find criteria
  n_csuit <- nrow(df_criteria_suit)
  
  df_criteria_ba1 <-
    subset(df_priorities, grepl("^ba_1", df_priorities$rulebase_stack)) # use regular expressions to find criteria
  n_cba1 <- nrow(df_criteria_ba1)
  
  assign(paste0("rbs_", df_criteria_ba1[1, 2], "_list"), c()) # initialise the rule base list
  assign(paste0("fp_", df_criteria_ba1[1, 2], "_list"), c()) # initialise the fuzzy partition list    
 
  # need to construct a new rule base for climatic aptitude and add this to the combined rule base stacks and fill the rb and fp lists
  
  
  rm(df_prop) # remove previous instances of df_prop
  rm(df_conc) # remove previous instances of df_prop
  rm(prop)
  rm(conc)
  
  for (i in 1:n_cba1) {
    assign(paste0("rbs_", df_criteria_ba1[1, 2], "_list"),
           append(get(
             paste0("rbs_", df_criteria_ba1[1, 2], "_list")
           ), get(
             paste0("rbs_", df_criteria_ba1[i, 3], "_list")
           )))
    
    assign(paste0("fp_", df_criteria_ba1[1, 2], "_list"),
           append(get(paste0(
             "fp_", df_criteria_ba1[1, 2], "_list"
           )), get(paste0(
             "fp_", df_criteria_ba1[i, 3], "_list"
           ))))
    
    # set the proposition name
    # normally this is just the rule base number, but for ag land this number should be suffixed with "_o"
    if (paste0(as.character(df_criteria_ba1[i, 3])) == "ba_2a") {
      Prop_name <-
        paste0(as.character(df_criteria_ba1[i, 3]), "_o")
    }
    else{
      Prop_name <-
        paste0(as.character(df_criteria_ba1[i, 3]))
    }
    
    # get  the 2 conclusion levels and get the unique values
    prop_levels <-
      c(as.character(df_criteria_ba1[i, 19]),
        as.character(df_criteria_ba1[i, 20]))  %>% unique()
    
    
    # set the proposition values
    if (!exists("df_prop")) {
      df_prop <- tibble(!!Prop_name := c(prop_levels))
    } else {
      #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
      df_prop <-
        bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
    }
  }

 
  # new proposition object is made here
  prop <- new("Proposition", table = df_prop %>% cross_df)
  tbl_prop_cross <- prop@table
  n_prop <- ncol(tbl_prop_cross)
  
  
  # new conclusion object is made here
  # needs to more or less replicate the original ifelse construction:
  
  # build the ifelse expression based on number of propositions
  
  x <- 1
  z <- NULL
  while (x <= n_prop)  {
    z <- paste0(z, "(tbl_prop_cross[", x, "] == \"optimal\") &")
    x <- x + 1
  }
  
  z <-
    paste0("ifelse ((", z, " 1 == 1), \"optimal\", \"suboptimal\")")
  df_conc <- NULL
  
  # evaluate the ifelse expression to produce a conclusion table and class
  df_conc <- eval(parse(text = z)) %>% as_tibble()
  names(df_conc) <- df_criteria_ba1[1, 2] # this works
  conc <- new("Conclusion", table = df_conc)
  
  # create a rule base
assign(paste0("rb_", df_criteria_ba1[1, 2]), RuleBase(prop, conc)) %>% print()
  
  # add to the list of previous rule bases
  
  assign(paste0("rbs_", df_criteria_ba1[1, 2], "_list"),
         append(get(
           paste0("rbs_", df_criteria_ba1[1, 2], "_list")
         ), paste0("rb_", df_criteria_ba1[1, 2])))


  
  # create the rule base stack from the list
  
  # original rbs_tmp_aptitude <- stack(rb_tmp_g_4a, rb_tmp_v_4b, rb_tmp_f_4c, rb_tmp_r_4d, rb_P_3a)
  
  x <-
    paste("stack(", gsub(",$", "", paste0(
      get(paste0("rbs_", df_criteria_ba1[1, 2], "_list")), sep = ",", collapse = ""
    )), ")")
 
  rbs_tmp <-  assign(paste0("rbs_", df_criteria_ba1[1, 2]), eval(parse(text = x)))

   # evaluate the rule base stack

    w <-
      paste("predict(", "rbs_tmp, newdata = df_irm,", gsub(",$", "", paste0(
        get(paste0("fp_", df_criteria_ba1[1, 2], "_list")), sep = ",", collapse = ""
      )), ")")
    
    assign(paste0("fpm_", df_criteria_ba1[1, 2]), eval(parse(text = w)))
  
 
    o_col <- getMembership(get(paste0("fpm_",
                                      df_criteria_ba1[1, 2]))$optimal)
    s_col <- getMembership(get(paste0("fpm_",
                                      df_criteria_ba1[1, 2]))$suboptimal)
    df_irm <-
      mutate(df_irm,!!as.character(paste0(df_criteria_ba1[1, 2], "_o")) := o_col, .keep = c("all"))
    df_irm <-
      mutate(df_irm,!!as.character(paste0(df_criteria_ba1[1, 2], "_s")) := s_col, .keep = c("all"))
    
    n = 2
    fpm_conc_var <-
      c(as.character(paste0(df_criteria_ba1[1, 2], "_o")), as.character(paste0(df_criteria_ba1[1, 2], "_s")), "x" , "y")
    fpm_conc_name <-
      c(as.character(paste0(df_criteria_suit[1, 4], " optimal")), as.character(paste0(df_criteria_suit[1, 4], " suboptimal")))
    fpm_plot_title <-
      "Biophysical Aptitude membership"
    
    plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
    print(plot_fpm)
     

```
</div>


```{r i1_rulebases_ba_export01, echo=FALSE, results='asis', eval=ba_crit}

cat("## Export aptitude results

")
```

<div class="fold o">
```{r i1_rulebases_ba_export02, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, warning=FALSE, eval=ba_crit}

vect_apt <- vect(df_irm, geom = c("x", "y"), crs = wkt_lam)
output_vect(vect_apt, paste0("apt_", params$INN1))

``` 
</div>

```{r i1_rulebases_sef01, echo=FALSE, results='asis', eval=sef_crit}

cat("## Socio-economic rule bases

")
```

```{r i1_rulebases_extension_access01, echo=FALSE, results='asis', eval=extaccess_crit}

cat("### Promotional Activities / Extension Access rule bases

This rule base combines two propositions:")
```

```{r i1_rulebases_extension_access02, echo=FALSE, results='asis', eval=extaccess_crit}

cat("

[1] '(1) se_5a is good' or '(1) se_5a is poor'
[1] '(2) se_5b is good' or '(2) se_5b is poor'

")
```


```{r i1_rulebases_extension_access03, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=extaccess_crit}

for (i in 1:(nrow(df_criteria_se4a))) {
  print(paste0(
    df_criteria_se4a[i, 3],
    " (",
    df_criteria_se4a[i, 4],
    "): Weight = ",
    as.character(df_criteria_se4a[i, 5])
  ))
}

``` 

```{r i1_rulebases_extension_access04, echo=FALSE, results='asis', eval=extaccess_crit}

cat("This rule base has four possible rules and three possible outcomes: good, moderate and poor access:

Rule 1: If se_5a is good and se_5b is good then se_4a is good
Rule 2: If se_5a is poor and se_5b is good then se_4a is poor, moderate or good
Rule 3: If se_5a is good and se_5b is poor then se_4a is poor, moderate or good
Rule 4: If se_5a is poor and se_5b is poor then se_4a is poor

Using the weights assigned by AHP the outcomes are the following:")
```

```{r i1_rulebases_extension_access05, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=extaccess_crit}

df_criteria_se5a <-
  subset(df_priorities, grepl("^se_5a", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse5a <- nrow(df_criteria_se5a)

df_criteria_se5b <-
  subset(df_priorities, grepl("^se_5b", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse5b <- nrow(df_criteria_se5b)


#Rule 2: If kebele ext access is good and woreda ext access is poor
rule2 <-   df_criteria_se5a$weight[1] - df_criteria_se5b$weight[1]

#Rule 3: If kebele ext access is poor and woreda ext access is good
rule3 <-   -df_criteria_se5a$weight[1] + df_criteria_se5b$weight[1]


rm(df_conc) # remove previous instances of df_conc

#Rule 1: then ext access is always good
ext_conclusion1 = "good"
cat(paste("rule 1 = ", ext_conclusion1))
cat("\n")
# create table of conclusions
df_conc <- tibble(se_4a = ext_conclusion1)

#Rule 2: then ext access is poor, moderate or good
if (rule2 >= 0.33)  {
  ext_conclusion2 = "good"
}     else if (rule2 > -0.33) {
  ext_conclusion2 = "moderate"
} else {
  ext_conclusion2 = "poor"
}
cat(paste("rule 2 = ", ext_conclusion2))
cat("\n")
df_conc <- add_row(df_conc, se_4a = ext_conclusion2)

#Rule 3: then ext access is poor, moderate or good
if (rule3 >= 0.33)  {
  ext_conclusion3 = "good"
}     else if (rule3 > -0.33) {
  ext_conclusion3 = "moderate"
} else {
  ext_conclusion3 = "poor"
}
cat(paste("rule 3 = ", ext_conclusion3))
cat("\n")
df_conc <- add_row(df_conc, se_4a = ext_conclusion3)

#Rule 8: then ext access is always poor
ext_conclusion4 = "poor"
cat(paste("rule 4 = ", ext_conclusion4))
df_conc <- add_row(df_conc, se_4a = ext_conclusion4)

```

```{r i1_rulebases_extension_access06, echo=FALSE, results='asis', eval=extaccess_crit}

cat("This gives the rule base:")

```

<div class="fold o"> 
```{r i1_rulebases_extension_access07, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=extaccess_crit}

df_criteria_se3a_4a <-
  subset(df_priorities, grepl("^se_4a", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse3a_4a <- nrow(df_criteria_se3a_4a)

# df_criteria_se2b includes all of the ext access criteria
# for each criterion we know that the new proposition is the same as the conclusion from the previous rule base

assign(paste0("rbs_", df_criteria_se3a_4a[1, 3], "_list"), c()) # initialise the rule base list
assign(paste0("fp_", df_criteria_se3a_4a[1, 3], "_list"), c()) # initialise the fuzzy partition list
rm(df_prop) # remove previous instances of df_prop

rm(prop)
rm(conc)
for (i in 1:(nrow(df_criteria_se4a))) {
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_se4a[i, 3]), "_o")
  
  # for those criteria with three conclusion values
  # get  the 3 conclusion levels and get the unique values
  prop_levels <-
    c(as.character(df_criteria_se4a[i, 19]),
      as.character(df_criteria_se4a[i, 20]))  %>% unique()
  
  
  
  # set the proposition values
  if (!exists("df_prop")) {
    df_prop <- tibble(!!Prop_name := c(prop_levels))
  } else {
    #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
    df_prop <-
      bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
  }
  
  # get a list of the previous rule bases
  assign(paste0("rbs_", df_criteria_se3a_4a[1, 3], "_list"),
         append(get(
           paste0("rbs_", df_criteria_se3a_4a[1, 3], "_list")
         ), paste0("rb_", df_criteria_se4a[i, 3])))
  
  # get a list of the fuzzy partitions
  assign(paste0("fp_", df_criteria_se3a_4a[1, 3], "_list"),
         append(
           get(paste0("fp_", df_criteria_se3a_4a[1, 3], "_list")),
           paste0(df_criteria_se4a[i, 3], " = fp_", df_criteria_se4a[i, 3])
         ))
}

# new proposition object is made here
prop <- new("Proposition", table = df_prop %>% cross_df)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here

conc <- new("Conclusion", table = df_conc)

# create a rule base
assign(paste0("rb_", df_criteria_se3a_4a[1, 3]), RuleBase(prop, conc)) %>% print()


# add to the list of previous rule bases

assign(paste0("rbs_", df_criteria_se3a_4a[1, 3], "_list"),
       append(get(
         paste0("rbs_", df_criteria_se3a_4a[1, 3], "_list")
       ), paste0("rb_", df_criteria_se3a_4a[1, 3])))

# create the rule base stack from the list

x <-
  paste("stack(", gsub(",$", "", paste0(
    get(paste0("rbs_", df_criteria_se3a_4a[1, 3], "_list")), sep = ",", collapse = ""
  )), ")")

rbs_tmp <-
  assign(paste0("rbs_", df_criteria_se3a_4a[1, 3]), eval(parse(text = x)))

# evaluate the rule base stack

w <-
  paste("predict(",
        "rbs_tmp, newdata = df_irm,",
        gsub(",$", "", paste0(
          get(paste0("fp_", df_criteria_se3a_4a[1, 3], "_list")), sep = ",", collapse = ""
        )),
        ")")

assign(paste0("fpm_", df_criteria_se3a_4a[1, 3]), eval(parse(text = w)))




g_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se3a_4a[1, 3]))$good)
df_irm <-
  mutate(df_irm,!!as.character(paste0(df_criteria_se3a_4a[1, 3], "_g")) := g_col, .keep = c("all"))

if (ext_conclusion2 == "moderate" |
    ext_conclusion3 == "moderate") {
  m_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se3a_4a[1, 3]))$moderate)
  df_irm <-
    mutate(df_irm,!!as.character(paste0(df_criteria_se3a_4a[1, 3], "_m")) := m_col, .keep = c("all"))
  
  ext_rb <- "gmp"
} else
  ext_rb <- "gp"

p_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se3a_4a[1, 3]))$poor)
df_irm <-
  mutate(df_irm,!!as.character(paste0(df_criteria_se3a_4a[1, 3], "_p")) := p_col, .keep = c("all"))


if (ext_rb == "gmp") {
  n = 3
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se3a_4a[1, 3], "_g")),
      as.character(paste0(df_criteria_se3a_4a[1, 3], "_m")),
      as.character(paste0(df_criteria_se3a_4a[1, 3], "_p")),
      "x" ,
      "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se3a_4a[1, 4], " good")),
      as.character(paste0(df_criteria_se3a_4a[1, 4], " moderate")),
      as.character(paste0(df_criteria_se3a_4a[1, 4], " poor")))
} else {
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se3a_4a[1, 3], "_g")),  as.character(paste0(df_criteria_se3a_4a[1, 3], "_p")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se3a_4a[1, 4], " good")),  as.character(paste0(df_criteria_se3a_4a[1, 4], " poor")))
  
}
fpm_plot_title <-
  "Extension\nAccess\noptimality\nmembership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
print(plot_fpm)

``` 
</div>

```{r i1_rulebases_labour_access01, echo=FALSE, results='asis', eval=lab_crit}

cat("### Labour Availability rule bases

This rule base combines two propositions:")

```

```{r i1_rulebases_labour_access02, echo=FALSE, results='asis', eval=lab_crit}

cat("[1] '(1) se_5c is good' or '(1) se_5c is poor'
[1] '(2) se_5d is good ' or '(2) se_5d is poor)' ")

```

```{r i1_rulebases_labour_access03, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=lab_crit}

for (i in 1:(nrow(df_criteria_se4b))) {
  print(paste0(
    df_criteria_se4b[i, 3],
    " (",
    df_criteria_se4b[i, 4],
    "): Weight = ",
    as.character(df_criteria_se4b[i, 5])
  ))
}

``` 

```{r i1_rulebases_labour_access04, echo=FALSE, results='asis', eval=lab_crit}

cat("This rule base has four possible rules and three possible outcomes: good, moderate and poor access:

Rule 1: If se_5c is poor and se_5d is poor then se_4b is poor
Rule 2: If se_5c is poor and se_5d is good then se_4b is poor, moderate or good
Rule 3: If se_5c is good and se_5d is poor then se_4b is poor, moderate or good
Rule 4: If se_5c is good and se_5d is good then se_4b is good

Using the weights assigned by AHP the outcomes are the following:")

```

```{r i1_rulebases_labour_access05, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=lab_crit}

df_criteria_se5c <-
  subset(df_priorities, grepl("^se_5c", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse5c <- nrow(df_criteria_se5c)

df_criteria_se5d <-
  subset(df_priorities, grepl("^se_5d", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse5d <- nrow(df_criteria_se5d)


#Rule 2: If kebele pop dens is good and kebele hh size is poor
rule2 <-   df_criteria_se5c$weight[1] - df_criteria_se5d$weight[1]

#Rule 3: If kebele pop dens is poor and kebele hh size is good
rule3 <-   -df_criteria_se5c$weight[1] + df_criteria_se5d$weight[1]


rm(df_conc) # remove previous instances of df_conc

#Rule 1: then lab access is always good
lab_conclusion1 = "poor"
cat(paste("rule 1 = ", lab_conclusion1))
cat("\n")
# create table of conclusions
df_conc <- tibble(se_4b = lab_conclusion1)

#Rule 2: then lab access is poor, moderate or good
if (rule2 >= 0.33)  {
  lab_conclusion2 = "good"
}     else if (rule2 > -0.33) {
  lab_conclusion2 = "moderate"
} else {
  lab_conclusion2 = "poor"
}
cat(paste("rule 2 = ", lab_conclusion2))
cat("\n")
df_conc <- add_row(df_conc, se_4b = lab_conclusion2)

#Rule 3: then lab access is poor, moderate or good
if (rule3 >= 0.33)  {
  lab_conclusion3 = "good"
}     else if (rule3 > -0.33) {
  lab_conclusion3 = "moderate"
} else {
  lab_conclusion3 = "poor"
}
cat(paste("rule 3 = ", lab_conclusion3))
cat("\n")
df_conc <- add_row(df_conc, se_4b = lab_conclusion3)

#Rule 8: then lab access is always poor
lab_conclusion4 = "good"
cat(paste("rule 4 = ", lab_conclusion4))
df_conc <- add_row(df_conc, se_4b = lab_conclusion4)

```

```{r i1_rulebases_labour_access06, echo=FALSE, results='asis', eval=lab_crit}

cat("This gives the rule base:")

```

<div class="fold o"> 
```{r i1_rulebases_labour_access07, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=lab_crit}

df_criteria_se3a_4b <-
  subset(df_priorities, grepl("^se_4b", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse3a_4b <- nrow(df_criteria_se3a_4b)

# df_criteria_se2b includes all of the lab access criteria
# for each criterion we know that the new proposition is the same as the conclusion from the previous rule base

assign(paste0("rbs_", df_criteria_se3a_4b[1, 3], "_list"), c()) # initialise the rule base list
assign(paste0("fp_", df_criteria_se3a_4b[1, 3], "_list"), c()) # initialise the fuzzy partition list
rm(df_prop) # remove previous instances of df_prop

rm(prop)
rm(conc)
for (i in 1:(nrow(df_criteria_se4b))) {
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_se4b[i, 3]), "_o")
  
  # for those criteria with three conclusion values
  # get  the 3 conclusion levels and get the unique values
  prop_levels <-
    c(as.character(df_criteria_se4b[i, 19]),
      as.character(df_criteria_se4b[i, 20]))  %>% unique()
  
  
  
  # set the proposition values
  if (!exists("df_prop")) {
    df_prop <- tibble(!!Prop_name := c(prop_levels))
  } else {
    #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
    df_prop <-
      bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
  }
  
  # get a list of the previous rule bases
  assign(paste0("rbs_", df_criteria_se3a_4b[1, 3], "_list"),
         append(get(
           paste0("rbs_", df_criteria_se3a_4b[1, 3], "_list")
         ), paste0("rb_", df_criteria_se4b[i, 3])))
  
  # get a list of the fuzzy partitions
  assign(paste0("fp_", df_criteria_se3a_4b[1, 3], "_list"),
         append(
           get(paste0("fp_", df_criteria_se3a_4b[1, 3], "_list")),
           paste0(df_criteria_se4b[i, 3], " = fp_", df_criteria_se4b[i, 3])
         ))
}

# new proposition object is made here
prop <- new("Proposition", table = df_prop %>% cross_df)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here

conc <- new("Conclusion", table = df_conc)

# create a rule base
assign(paste0("rb_", df_criteria_se3a_4b[1, 3]), RuleBase(prop, conc)) %>% print()


# add to the list of previous rule bases

assign(paste0("rbs_", df_criteria_se3a_4b[1, 3], "_list"),
       append(get(
         paste0("rbs_", df_criteria_se3a_4b[1, 3], "_list")
       ), paste0("rb_", df_criteria_se3a_4b[1, 3])))

# create the rule base stack from the list

x <-
  paste("stack(", gsub(",$", "", paste0(
    get(paste0("rbs_", df_criteria_se3a_4b[1, 3], "_list")), sep = ",", collapse = ""
  )), ")")

rbs_tmp <-
  assign(paste0("rbs_", df_criteria_se3a_4b[1, 3]), eval(parse(text = x)))

# evaluate the rule base stack

w <-
  paste("predict(",
        "rbs_tmp, newdata = df_irm,",
        gsub(",$", "", paste0(
          get(paste0("fp_", df_criteria_se3a_4b[1, 3], "_list")), sep = ",", collapse = ""
        )),
        ")")

assign(paste0("fpm_", df_criteria_se3a_4b[1, 3]), eval(parse(text = w)))




g_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se3a_4b[1, 3]))$good)
df_irm <-
  mutate(df_irm,!!as.character(paste0(df_criteria_se3a_4b[1, 3], "_g")) := g_col, .keep = c("all"))

if (lab_conclusion2 == "moderate" |
    lab_conclusion3 == "moderate") {
  m_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se3a_4b[1, 3]))$moderate)
  df_irm <-
    mutate(df_irm,!!as.character(paste0(df_criteria_se3a_4b[1, 3], "_m")) := m_col, .keep = c("all"))
  
  lab_rb <- "gmp"
} else
  lab_rb <- "gp"

p_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se3a_4b[1, 3]))$poor)
df_irm <-
  mutate(df_irm,!!as.character(paste0(df_criteria_se3a_4b[1, 3], "_p")) := p_col, .keep = c("all"))


if (lab_rb == "gmp") {
  n = 3
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se3a_4b[1, 3], "_g")),
      as.character(paste0(df_criteria_se3a_4b[1, 3], "_m")),
      as.character(paste0(df_criteria_se3a_4b[1, 3], "_p")),
      "x" ,
      "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se3a_4b[1, 4], " good")),
      as.character(paste0(df_criteria_se3a_4b[1, 4], " moderate")),
      as.character(paste0(df_criteria_se3a_4b[1, 4], " poor")))
} else {
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se3a_4b[1, 3], "_g")),  as.character(paste0(df_criteria_se3a_4b[1, 3], "_p")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se3a_4b[1, 4], " good")),  as.character(paste0(df_criteria_se3a_4b[1, 4], " poor")))
  
}
fpm_plot_title <-
  "Labour\nAvailability\noptimality\nmembership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
print(plot_fpm)


``` 
</div>

```{r i1_rulebases_fp_access01, echo=FALSE, results='asis', eval=fp_crit}

cat("### Fertiliser and Pesticide Access rule bases

This rule base combines two propositions:")

```

```{r i1_rulebases_fp_access02, echo=FALSE, results='asis', eval=fp_crit}

cat("[1] '(1) se_5e is good' or '(1) se_5e is poor'
[1] '(2) se_5f is good ' or '(2) se_5f is poor)' ")

```

```{r i1_rulebases_fp_access03, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=fp_crit}

for (i in 1:(nrow(df_criteria_se4c))) {
  print(paste0(
    df_criteria_se4c[i, 3],
    " (",
    df_criteria_se4c[i, 4],
    "): Weight = ",
    as.character(df_criteria_se4c[i, 5])
  ))
}

``` 

```{r i1_rulebases_fp_access04, echo=FALSE, results='asis', eval=fp_crit}

cat("This rule base has four possible rules and three possible outcomes: good, moderate and poor access:

Rule 1: If se_5e is poor and se_5f is poor then se_4c is poor
Rule 2: If se_5e is poor and se_5f is good then se_4c is poor, moderate or good
Rule 3: If se_5e is good and se_5f is poor then se_4c is poor, moderate or good
Rule 4: If se_5e is good and se_5f is good then se_4c is good

Using the weights assigned by AHP the outcomes are the following:")

```

```{r i1_rulebases_fp_access05, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=fp_crit}


df_criteria_se5e <-
  subset(df_priorities, grepl("^se_5e", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse5e <- nrow(df_criteria_se5e)

df_criteria_se5f <-
  subset(df_priorities, grepl("^se_5f", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse5f <- nrow(df_criteria_se5f)


#Rule 2: If  F/P Access at Local Farmer Group is good and F/P Access at woreda is poor
rule2 <-   df_criteria_se5e$weight[1] - df_criteria_se5f$weight[1]

#Rule 3: If F/P Access at Local Farmer Group is poor and F/P Access at woreda is good
rule3 <-   -df_criteria_se5e$weight[1] + df_criteria_se5f$weight[1]


rm(df_conc) # remove previous instances of df_conc

#Rule 1: then fp access is always good
fp_conclusion1 = "good"
cat(paste("rule 1 = ", fp_conclusion1))
cat("\n")
# create table of conclusions
df_conc <- tibble(se_4c = fp_conclusion1)

#Rule 2: then fp access is poor, moderate or good
if (rule2 >= 0.33)  {
  fp_conclusion2 = "good"
}     else if (rule2 > -0.33) {
  fp_conclusion2 = "moderate"
} else {
  fp_conclusion2 = "poor"
}
cat(paste("rule 2 = ", fp_conclusion2))
cat("\n")
df_conc <- add_row(df_conc, se_4c = fp_conclusion2)

#Rule 3: then fp access is poor, moderate or good
if (rule3 >= 0.33)  {
  fp_conclusion3 = "good"
}     else if (rule3 > -0.33) {
  fp_conclusion3 = "moderate"
} else {
  fp_conclusion3 = "poor"
}
cat(paste("rule 3 = ", fp_conclusion3))
cat("\n")
df_conc <- add_row(df_conc, se_4c = fp_conclusion3)

#Rule 8: then fp access is always poor
fp_conclusion4 = "poor"
cat(paste("rule 4 = ", fp_conclusion4))
df_conc <- add_row(df_conc, se_4c = fp_conclusion4)
  
```

```{r i1_rulebases_fp_access06, echo=FALSE, results='asis', eval=fp_crit}

cat("This gives the rule base:")

```

<div class="fold o"> 
```{r i1_rulebases_fp_access07, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=fp_crit}

if (fp_crit == 1) {
  df_criteria_se3b_4c <-
    subset(df_priorities, grepl("^se_4c", df_priorities$rulebase_number)) # use regular expressions to find criteria
  n_cse3b_4c <- nrow(df_criteria_se3b_4c)
  
  # df_criteria_se2b includes all of the fp access criteria
  # for each criterion we know that the new proposition is the same as the conclusion from the previous rule base
  
  assign(paste0("rbs_", df_criteria_se3b_4c[1, 3], "_list"), c()) # initialise the rule base list
  assign(paste0("fp_", df_criteria_se3b_4c[1, 3], "_list"), c()) # initialise the fuzzy partition list
  rm(df_prop) # remove previous instances of df_prop
  
  rm(prop)
  rm(conc)
  for (i in 1:(nrow(df_criteria_se4c))) {
    # set the proposition name
    Prop_name <-
      paste0(as.character(df_criteria_se4c[i, 3]), "_o")
    
    # for those criteria with three conclusion values
    # get  the 3 conclusion levels and get the unique values
    prop_levels <-
      c(as.character(df_criteria_se4c[i, 19]),
        as.character(df_criteria_se4c[i, 20]))  %>% unique()
    
    
    
    # set the proposition values
    if (!exists("df_prop")) {
      df_prop <- tibble(!!Prop_name := c(prop_levels))
    } else {
      #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
      df_prop <-
        bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
    }
    
    # get a list of the previous rule bases
    assign(paste0("rbs_", df_criteria_se3b_4c[1, 3], "_list"),
           append(get(
             paste0("rbs_", df_criteria_se3b_4c[1, 3], "_list")
           ), paste0("rb_", df_criteria_se4c[i, 3])))
    
    # get a list of the fuzzy partitions
    assign(paste0("fp_", df_criteria_se3b_4c[1, 3], "_list"),
           append(
             get(paste0("fp_", df_criteria_se3b_4c[1, 3], "_list")),
             paste0(df_criteria_se4c[i, 3], " = fp_", df_criteria_se4c[i, 3])
           ))
  }
  
  # new proposition object is made here
  prop <- new("Proposition", table = df_prop %>% cross_df)
  tbl_prop_cross <- prop@table
  n_prop <- ncol(tbl_prop_cross)
  
  
  # new conclusion object is made here
  
  conc <- new("Conclusion", table = df_conc)
  
  # create a rule base
  assign(paste0("rb_", df_criteria_se3b_4c[1, 3]), RuleBase(prop, conc)) %>% print()
  
  
  # add to the list of previous rule bases
  
  assign(paste0("rbs_", df_criteria_se3b_4c[1, 3], "_list"),
         append(get(
           paste0("rbs_", df_criteria_se3b_4c[1, 3], "_list")
         ), paste0("rb_", df_criteria_se3b_4c[1, 3])))
  
  # create the rule base stack from the list
  
  x <-
    paste("stack(", gsub(",$", "", paste0(
      get(paste0("rbs_", df_criteria_se3b_4c[1, 3], "_list")), sep = ",", collapse = ""
    )), ")")
  
  rbs_tmp <-
    assign(paste0("rbs_", df_criteria_se3b_4c[1, 3]), eval(parse(text = x)))
  
  # evaluate the rule base stack
  
  w <-
    paste("predict(",
          "rbs_tmp, newdata = df_irm,",
          gsub(",$", "", paste0(
            get(paste0("fp_", df_criteria_se3b_4c[1, 3], "_list")), sep = ",", collapse = ""
          )),
          ")")
  
  assign(paste0("fpm_", df_criteria_se3b_4c[1, 3]), eval(parse(text = w)))
  
  
  
  
  g_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se3b_4c[1, 3]))$good)
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_se3b_4c[1, 3], "_g")) := g_col, .keep = c("all"))
  
  if (fp_conclusion2 == "moderate" |
      fp_conclusion3 == "moderate") {
    m_col <- getMembership(get(paste0("fpm_",
                                      df_criteria_se3b_4c[1, 3]))$moderate)
    df_irm <-
      mutate(df_irm, !!as.character(paste0(df_criteria_se3b_4c[1, 3], "_m")) := m_col, .keep = c("all"))
    
    fp_rb <- "gmp"
  } else
    fp_rb <- "gp"
  
  p_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se3b_4c[1, 3]))$poor)
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_se3b_4c[1, 3], "_p")) := p_col, .keep = c("all"))
  
  
  if (fp_rb == "gmp") {
    n = 3
    fpm_conc_var <-
      c(as.character(paste0(df_criteria_se3b_4c[1, 3], "_g")),
        as.character(paste0(df_criteria_se3b_4c[1, 3], "_m")),
        as.character(paste0(df_criteria_se3b_4c[1, 3], "_p")),
        "x" ,
        "y")
    fpm_conc_name <-
      c(as.character(paste0(df_criteria_se3b_4c[1, 4], " good")),
        as.character(paste0(df_criteria_se3b_4c[1, 4], " moderate")),
        as.character(paste0(df_criteria_se3b_4c[1, 4], " poor")))
  } else {
    n = 2
    fpm_conc_var <-
      c(as.character(paste0(df_criteria_se3b_4c[1, 3], "_g")),  as.character(paste0(df_criteria_se3b_4c[1, 3], "_p")), "x" , "y")
    fpm_conc_name <-
      c(as.character(paste0(df_criteria_se3b_4c[1, 4], " good")),  as.character(paste0(df_criteria_se3b_4c[1, 4], " poor")))
    
  }
  fpm_plot_title <-
    "Fertiliser\n& Pesticide\nAccess\noptimality\nmembership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
  print(plot_fpm)
  
}

``` 
</div>

```{r i1_rulebases_farm_inputs01, echo=FALSE, results='asis', eval=inpaccess_crit}

cat("### Access to Farm Inputs rule bases

The inputs access rule base (se_3b) combines propositions for access to fertilisers and pesticides (rule base se_4c), access to seeds (rule base se_4d) and access to land (rule base se_4e).

Rule base se_3b has the following propositions:")

```

```{r i1_rulebases_farm_inputs02 , cache = TRUE, cache.whatever=params$Agg, results='asis', eval=inpaccess_crit}

fp_conc_list <- c(fp_conclusion1, fp_conclusion2, fp_conclusion3, fp_conclusion4)

cat(paste("(1) se_4c is", unique(fp_conc_list)))

``` 

```{r i1_rulebases_farm_inputs03, echo=FALSE, results='asis', eval=inpaccess_crit}

cat("[1] '(2) se_4d is good'  '(2) se_4d is poor'
[1] '(3) se_4e is good'  '(3) se_4e is poor'")

```


```{r i1_rulebases_farm_inputs04, cache = TRUE, cache.whatever=params$Agg, results='asis', eval=inpaccess_crit}

df_criteria_se3b <-
  subset(df_priorities, grepl("^se_3b", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cse3b <- nrow(df_criteria_se3b)
print(paste(n_cse3b, "Inputs Access criteria: "))

for (i in 1:(nrow(df_criteria_se3b))) {
  print(paste0(
    df_criteria_se3b[i, 3],
    " (",
    df_criteria_se3b[i, 4],
    "): Weight = ",
    as.character(df_criteria_se3b[i, 5])
  ))
}

``` 

```{r i1_rulebases_farm_inputs05, echo=FALSE, results='asis', eval=inpaccess_crit}

cat("This rule base has twelve possible rules and three possible outcomes: good, moderate and poor access:

Rule 1: If se_4c is good and se_4d is good and se_4e is good then se3b is good
Rule 2: If se_4c is moderate and se_4d is good and se_4e is good then se3b is moderate or good
Rule 3: If se_4c is poor and se_4d is good and se_4e is good then se3b is poor, moderate or good
Rule 4: If se_4c is good and se_4d is poor and se_4e is good then se3b is poor, moderate or good
Rule 5: If se_4c is moderate and se_4d is poor and se_4e is good then se3b is poor, moderate or good
Rule 6: If se_4c is poor and se_4d is poor and se_4e is good then se3b is poor, moderate or good
Rule 7: If se_4c is good and se_4d is good and se_4e is poor then se3b is poor, moderate or good
Rule 8: If se_4c is moderate and se_4d is good and se_4e is poor then se3b is poor, moderate or good
Rule 9: If se_4c is poor and se_4d is good and se_4e is poor then se3b is poor, moderate or good
Rule 10: If se_4c is good  and se_4d is poor and se_4e is poor then se3b is poor, moderate or good
Rule 11: If se_4c is moderate and se_4d is poor and se_4e is poor then se3b is poor or moderate
Rule 12: If se_4c is poor and se_4d is poor and se_4e is poor then se3b is poor


Using the propositions and weights assigned by AHP the outcomes are the following:")

```

```{r i1_rulebases_farm_inputs06, cache = TRUE, cache.whatever=params$Agg, results='asis', eval=inpaccess_crit}

df_criteria_se4c <-
  subset(df_priorities, grepl("^se_4c", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse4c <- nrow(df_criteria_se4c)

df_criteria_se4d <-
  subset(df_priorities, grepl("^se_4d", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse4d <- nrow(df_criteria_se4d)

df_criteria_se4e <-
  subset(df_priorities, grepl("^se_4e", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse4e <- nrow(df_criteria_se4e)


#Rule 2: If f/p access is moderate and seed access is good and land access is good
rule2 <-
  df_criteria_se4d$weight[1] + df_criteria_se4e$weight[1]

#Rule 3: If f/p access is poor and seed access is good and land access is good
rule3 <-
  -df_criteria_se4c$weight[1] + df_criteria_se4d$weight[1] + df_criteria_se4e$weight[1]

#Rule 4: If f/p access is good and seed access is poor and land access is good
rule4  <-
  df_criteria_se4c$weight[1] - df_criteria_se4d$weight[1] + df_criteria_se4e$weight[1]

#Rule 5: If f/p access is moderate and seed access is poor and land access is good
rule5  <-
  -df_criteria_se4d$weight[1] + df_criteria_se4e$weight[1]

#Rule 6: If f/p access is poor and seed access is poor and land access is good
rule6  <-
  -df_criteria_se4c$weight[1] - df_criteria_se4d$weight[1] + df_criteria_se4e$weight[1]

#Rule 7: If f/p access is good and seed access is good and land access is poor
rule7  <-
  df_criteria_se4c$weight[1] + df_criteria_se4d$weight[1] - df_criteria_se4e$weight[1]

#Rule 8: If f/p access is moderate and seed access is good and land access is poor
rule8  <-
  df_criteria_se4d$weight[1] - df_criteria_se4e$weight[1]

#Rule 9: If f/p access is poor and seed access is good and land access is poor
rule9  <-
  -df_criteria_se4c$weight[1] + df_criteria_se4d$weight[1] - df_criteria_se4e$weight[1]

#Rule 10: If f/p access is good and seed access is poor and land access is poor
rule10  <-
  df_criteria_se4c$weight[1] - df_criteria_se4d$weight[1] - df_criteria_se4e$weight[1]

#Rule 11: If f/p access is moderate and seed access is poor and land access is poor
rule11  <-
  -df_criteria_se4d$weight[1] - df_criteria_se4e$weight[1]


rm(df_conc) # remove previous instances of df_conc
rm(df_prop) # remove previous instances of df_prop

inp_conclusion1 = "good" # always poor
cat(paste("rule 1 = ", inp_conclusion1))
cat("\n")

# create table of conclusions
df_prop <-
  tibble(se_4c = "good",
         se_4d_o = "good",
         se_4e_o = "good")
df_conc <- tibble(se_3b = inp_conclusion1)


#Rule 2: then farm inputs access is poor, moderate or good
if (fp_rb == "gmp") {
  # rule 2 only activated when f/p is moderate
  
  if (rule2 >= 0.33)  {
    inp_conclusion2 = "good"
  }     else if (rule2 > -0.33) {
    inp_conclusion2 = "moderate"
  } else {
    inp_conclusion2 = "poor"
  }
  cat(paste("rule 2 = ", inp_conclusion2))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_3b = inp_conclusion2)
  df_prop <-
    add_row(df_prop,
            se_4c = "moderate",
            se_4d_o = "good",
            se_4e_o = "good")
} else
  cat(paste("No rule 2"))
cat("\n")

#Rule 3: then farm inputs access is poor, moderate or good

if (rule3 >= 0.33)  {
  inp_conclusion3 = "good"
}     else if (rule3 > -0.33) {
  inp_conclusion3 = "moderate"
} else {
  inp_conclusion3 = "poor"
}

cat(paste("rule 3 = ", inp_conclusion3))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_3b = inp_conclusion3)
df_prop <-
  add_row(df_prop,
          se_4c = "poor",
          se_4d_o = "good",
          se_4e_o = "good")

#Rule 4: then farm inputs access is poor, moderate or good

if (rule4 >= 0.33)  {
  inp_conclusion4 = "good"
}     else if (rule4 > -0.33) {
  inp_conclusion4 = "moderate"
} else {
  inp_conclusion4 = "poor"
}

cat(paste("rule 4 = ", inp_conclusion4))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_3b = inp_conclusion4)
df_prop <-
  add_row(df_prop,
          se_4c = "good",
          se_4d_o = "poor",
          se_4e_o = "good")



#Rule 5: then farm inputs access is poor, moderate or good

if (fp_rb == "gmp") {
  # rule 5 only activated when f/p is moderate
  if (rule5 >= 0.33)  {
    inp_conclusion5 = "good"
  }     else if (rule5 > -0.33) {
    inp_conclusion5 = "moderate"
  } else {
    inp_conclusion5 = "poor"
  }
  cat(paste("rule 5 = ", inp_conclusion5))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_3b = inp_conclusion5)
  df_prop <-
    add_row(df_prop,
            se_4c = "moderate",
            se_4d_o = "poor",
            se_4e_o = "good")
  
} else
  cat(paste("No rule 5"))
cat("\n")


#Rule 6: then farm inputs access is poor, moderate or good
if (rule6 >= 0.33)  {
  inp_conclusion6 = "good"
}     else if (rule6 > -0.33) {
  inp_conclusion6 = "moderate"
} else {
  inp_conclusion6 = "poor"
}
cat(paste("rule 6 = ", inp_conclusion6))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_3b = inp_conclusion6)
df_prop <-
  add_row(df_prop,
          se_4c = "poor",
          se_4d_o = "poor",
          se_4e_o = "good")

#Rule 7: then farm inputs access is poor, moderate or good
if (rule7 >= 0.33)  {
  inp_conclusion7 = "good"
}     else if (rule7 > -0.33) {
  inp_conclusion7 = "moderate"
} else {
  inp_conclusion7 = "poor"
}
cat(paste("rule 7 = ", inp_conclusion7))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_3b = inp_conclusion7)
df_prop <-
  add_row(df_prop,
          se_4c = "good",
          se_4d_o = "good",
          se_4e_o = "poor")

#Rule 8: then farm inputs access is poor, moderate or good
if (fp_rb == "gmp") {
  # rule 8 only activated when f/p is moderate
  if (rule8 >= 0.33)  {
    inp_conclusion8 = "good"
  }     else if (rule8 > -0.33) {
    inp_conclusion8 = "moderate"
  } else {
    inp_conclusion8 = "poor"
  }
  cat(paste("rule 8 = ", inp_conclusion8))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_3b = inp_conclusion8)
  df_prop <-
    add_row(df_prop,
            se_4c = "moderate",
            se_4d_o = "good",
            se_4e_o = "poor")
} else
  cat(paste("No rule 8"))
cat("\n")

#Rule 9: then farm inputs access is poor, moderate or good

if (rule9 >= 0.33)  {
  inp_conclusion9 = "good"
}     else if (rule9 > -0.33) {
  inp_conclusion9 = "moderate"
} else {
  inp_conclusion9 = "poor"
}

cat(paste("rule 9 = ", inp_conclusion9))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_3b = inp_conclusion9)
df_prop <- add_row(df_prop,
                 se_4c = "poor",
                 se_4d_o = "good",
                 se_4e_o = "poor")


#Rule 10: then farm inputs access is poor, moderate or good

if (rule10 >= 0.33)  {
  inp_conclusion10 = "good"
}     else if (rule10 > -0.33) {
  inp_conclusion10 = "moderate"
} else {
  inp_conclusion10 = "poor"
}

cat(paste("rule 10 = ", inp_conclusion10))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_3b = inp_conclusion10)
df_prop <- add_row(df_prop,
                 se_4c = "good",
                 se_4d_o = "poor",
                 se_4e_o = "poor")


#Rule 11: then farm inputs access is poor, moderate or good
if (fp_rb == "gmp") {
  # rule 10 only activated when f/p is moderate
  
  if (rule11 >= 0.33)  {
    inp_conclusion11 = "good"
  }     else if (rule11 > -0.33) {
    inp_conclusion11 = "moderate"
  } else {
    inp_conclusion11 = "poor"
  }
  cat(paste("rule 11 = ", inp_conclusion11))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_3b = inp_conclusion11)
  df_prop <- add_row(df_prop,
                   se_4c = "moderate",
                   se_4d_o = "poor",
                   se_4e_o = "poor")
} else
  cat(paste("No rule 11"))
cat("\n")


inp_conclusion12 = "poor"
cat(paste("rule 12 = ", inp_conclusion12))
# add to table of conclusions
df_conc <- add_row(df_conc, se_3b = inp_conclusion12)
df_prop <- add_row(df_prop,
                 se_4c = "poor",
                 se_4d_o = "poor",
                 se_4e_o = "poor")


``` 

```{r i1_rulebases_farm_inputs07, echo=FALSE, results='asis', eval=inpaccess_crit}

cat("This gives the rule base:")

```

<div class="fold o"> 
```{r i1_rulebases_farm_inputs08, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=inpaccess_crit}

if (inpaccess_crit == 1) {
  
  # new proposition object is made here
  prop <- new("Proposition", table = df_prop)
  tbl_prop_cross <- prop@table
  n_prop <- ncol(tbl_prop_cross)
  
  
  # new conclusion object is made here
  
  conc <- new("Conclusion", table = df_conc)
  
  # create a rule base
  rb_se_3b <- RuleBase(prop, conc) %>% print()

  
# in this section there are normally three criteria - f/p, seeds and land

# seeds and land are based on one criterion only and each have data, a simple rb (se_4d & se4e) and a fp (se_4d & se4e)

# access to f/p is based on two criteria and has a rb (se_4c) and a rbs (se_4c) which includes the two constituent parts of f/p and their two rb (se_5e & se5f)
# there are four fp in total (se_5e, se_5f, se_4e and se4d)

# in total there will be a new rbs (se_3b) which will contain:
# rb_se_4d
# rb_se_4e
# rb_se_5e in rbs_se_4c_list
# rb_se_5f in rbs_se_4c_list
# rb_se_4c in rbs_se_4c_list

rbs_se_3b <-
  stack(
    rb_se_4d,
    rb_se_4e,
    rb_se_5e,
    rb_se_5f,
    rb_se_4c,
    rb_se_3b
  )


fpm_se_3b <-
  
  predict(
    rbs_se_3b,
    newdata = df_irm,
    se_4d = fp_se_4d,
    se_4e = fp_se_4e,
    se_5e = fp_se_5e,
    se_5f = fp_se_5f
  )

 
  df_criteria_se2a_3b <-
    subset(df_priorities, grepl("^se_3b", df_priorities$rulebase_number)) # use regular expressions to find criteria
  n_cse2a_3b <- nrow(df_criteria_se2a_3b)
  
  g_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se2a_3b[1, 3]))$good)
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_se2a_3b[1, 3], "_g")) := g_col, .keep = c("all"))
  
   
  if (fp_rb == "gmp") {
      inp_rule_num <- 12
  if(inp_conclusion2 == "moderate" |
      inp_conclusion3 == "moderate" |
      inp_conclusion4 == "moderate" |
      inp_conclusion5 == "moderate" |
      inp_conclusion6 == "moderate" | 
      inp_conclusion7 == "moderate" |
      inp_conclusion8 == "moderate" |
      inp_conclusion9 == "moderate" | 
      inp_conclusion10 == "moderate" | 
      inp_conclusion11 == "moderate") {
    m_col <- getMembership(get(paste0("fpm_",
                                      df_criteria_se2a_3b[1, 3]))$moderate)
    df_irm <-
      mutate(df_irm, !!as.character(paste0(df_criteria_se2a_3b[1, 3], "_m")) := m_col, .keep = c("all"))
    
    inp_rb <- "gmp"

  } else
    inp_rb <- "gp"
  } else { 
  inp_rule_num <- 8
    if( inp_conclusion3 == "moderate" |
      inp_conclusion4 == "moderate" |
      inp_conclusion6 == "moderate" | 
      inp_conclusion7 == "moderate" |
      inp_conclusion9 == "moderate" | 
      inp_conclusion10 == "moderate") {
    m_col <- getMembership(get(paste0("fpm_",
                                      df_criteria_se2a_3b[1, 3]))$moderate)
    df_irm <-
      mutate(df_irm, !!as.character(paste0(df_criteria_se2a_3b[1, 3], "_m")) := m_col, .keep = c("all"))
    
    inp_rb <- "gmp"
    
  } else
    inp_rb <- "gp"    
 }   
    
    
  p_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se2a_3b[1, 3]))$poor)
  df_irm <-
    mutate(df_irm, !!as.character(paste0(df_criteria_se2a_3b[1, 3], "_p")) := p_col, .keep = c("all"))
  
    
if  (inp_rb == "gmp" ){   
        n = 3
    fpm_conc_var <-
      c(as.character(paste0(df_criteria_se2a_3b[1, 3], "_g")), as.character(paste0(df_criteria_se2a_3b[1, 3], "_m")), as.character(paste0(df_criteria_se2a_3b[1, 3], "_p")),"x" , "y")
    fpm_conc_name <-
      c(as.character(paste0(df_criteria_se2a_3b[1, 4], " good")), as.character(paste0(df_criteria_se2a_3b[1, 4], " moderate")), as.character(paste0(df_criteria_se2a_3b[1, 4], " poor")))
} else {
  
        n = 2
    fpm_conc_var <-
      c(as.character(paste0(df_criteria_se2a_3b[1, 3], "_g")),  as.character(paste0(df_criteria_se2a_3b[1, 3], "_p")),"x" , "y")
    fpm_conc_name <-
      c(as.character(paste0(df_criteria_se2a_3b[1, 4], " good")),  as.character(paste0(df_criteria_se2a_3b[1, 4], " poor")))  
  
}
        fpm_plot_title <-
      "Farm Inputs\nAccess\noptimality\nmembership"
     
    plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
    print(plot_fpm)
     
  
  
}
``` 
</div>

```{r i1_rulebases_management01, echo=FALSE, results='asis', eval=management_crit}

cat("### Crop and Farm Management rule bases")

```


```{r i1_rulebases_management02, results='asis', warning=FALSE, eval=management_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria

df_criteria_se3a <-
  subset(df_priorities, grepl("^se_3a", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cse3a <- nrow(df_criteria_se3a)

# then determine and print the names of the rule bases in the Crop and Farm Management theme

cat(paste(n_cse3a, "Crop and Farm Management rule bases:"))
for (i in 1:n_cse3a) {
  cat(
    paste0(
      "\n",
      df_criteria_se3a[i, 3],
      " (",
      df_criteria_se3a[i, 4],
      "):\n Weight = ",
      as.character(df_criteria_se3a[i, 5]),
      "\n"
    )
  )
}

```


```{r i1_rulebases_management03, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=management_crit}


ext_conc_list <-
  c(ext_conclusion1,
    ext_conclusion2,
    ext_conclusion3,
    ext_conclusion4)

cat(paste("\n Extension access is", sort(unique(ext_conc_list))))

cat(paste("\n\nRule base 4b has the following conclusions:"))

lab_conc_list <-
  c(lab_conclusion1,
    lab_conclusion2,
    lab_conclusion3,
    lab_conclusion4)

cat(paste("\n Extension access is", sort(unique(lab_conc_list))))

``` 

```{r i1_rulebases_management04, echo=FALSE, results='asis', eval=management_crit}

cat("This rule base has nine possible rules and three possible outcomes: good, moderate and poor access:

Rule 1: If se_4a is good and se_4b is good then se3a is good
Rule 2: If se_4a is moderate and se_4b is good then se3a is moderate or good
Rule 3: If se_4a is poor and se_4b is good then se3a is poor, moderate or good
Rule 4: If se_4a is good and se_4b is moderate then se3a is poor, moderate or good
Rule 5: If se_4a is moderate and se_4b is moderate then se3a is poor, moderate or good
Rule 6: If se_4a is poor and se_4b is moderate then se3a is poor, moderate or good
Rule 7: If se_4a is good and se_4b is poor then se3a is poor, moderate or good
Rule 8: If se_4a is moderate and se_4b is poor then se3a is poor or moderate
Rule 9: If se_4a is poor and se_4b is poor then se3a is poor


Using the propositions and weights assigned by AHP the outcomes are the following:")

```


```{r i1_rulebases_management05, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=management_crit}


df_criteria_se4a <-
  subset(df_priorities, grepl("^se_4a", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse4a <- nrow(df_criteria_se4a)

df_criteria_se4b <-
  subset(df_priorities, grepl("^se_4b", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse4b <- nrow(df_criteria_se4b)




#Rule 2: If ext access is moderate and labour access is good
rule2 <-
  df_criteria_se4b$weight[1]

#Rule 3: If ext access is poor and labour access is good
rule3 <-
  -df_criteria_se4a$weight[1] + df_criteria_se4b$weight[1]

#Rule 4: If ext access is good and labour access is moderate
rule4  <-
  df_criteria_se4a$weight[1]

#Rule 6: If ext access is poor and labour access is moderate
rule6  <-
  -df_criteria_se4a$weight[1]

#Rule 7: If ext access is good and labour access is poor
rule7  <-
  df_criteria_se4a$weight[1] - df_criteria_se4b$weight[1]

#Rule 8: If ext access is moderate and labour access is poor
rule8  <-
  -df_criteria_se4b$weight[1]




rm(df_conc) # remove previous instances of df_conc
rm(df_prop) # remove previous instances of df_prop

#Rule 1: then management is good

mgt_conclusion1 = "good" # always good
cat(paste("rule 1 = ", mgt_conclusion1))
cat("\n")

# create table of conclusions
df_prop <-
  tibble(se_4a = "good",
         se_4b = "good")
df_conc <- tibble(se_3a = mgt_conclusion1)


#Rule 2: then management is moderate or good
if (ext_rb == "gmp") {
  # rule 2 only activated when ext is moderate
  
  if (rule2 >= 0.33)  {
    mgt_conclusion2 = "good"
  }     else if (rule2 > -0.33) {
    mgt_conclusion2 = "moderate"
  } else {
    mgt_conclusion2 = "poor"
  }
  cat(paste("rule 2 = ", mgt_conclusion2))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_3a = mgt_conclusion2)
  df_prop <-
    add_row(df_prop,
            se_4a = "moderate",
            se_4b = "good")
} else{
  cat(paste("No rule 2"))
  cat("\n")
}

#Rule 3: then management is poor, moderate or good

if (rule3 >= 0.33)  {
  mgt_conclusion3 = "good"
}     else if (rule3 > -0.33) {
  mgt_conclusion3 = "moderate"
} else {
  mgt_conclusion3 = "poor"
}

cat(paste("rule 3 = ", mgt_conclusion3))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_3a = mgt_conclusion3)
df_prop <-
  add_row(df_prop,
          se_4a = "poor",
          se_4b = "good")

#Rule 4: then management is poor, moderate or good
if (lab_rb == "gmp") {
  # rule 4 only activated when lab is moderate
  
  if (rule4 >= 0.33)  {
    mgt_conclusion4 = "good"
  }     else if (rule4 > -0.33) {
    mgt_conclusion4 = "moderate"
  } else {
    mgt_conclusion4 = "poor"
  }
  
  cat(paste("rule 4 = ", mgt_conclusion4))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_3a = mgt_conclusion4)
  df_prop <-
    add_row(df_prop,
            se_4a = "good",
            se_4b = "moderate")
} else{
  cat(paste("No rule 4"))
  cat("\n")
}


#Rule 5: then management is moderate
if (ext_rb == "gmp" & lab_rb == "gmp") {
  mgt_conclusion5 = "moderate"
  cat(paste("rule 5 = ", mgt_conclusion5))
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_3a = mgt_conclusion5)
  df_prop <- add_row(df_prop,
                   se_4a = "moderate",
                   se_4b = "moderate")
} else
  cat(paste("No rule 5"))
cat("\n")

#Rule 6: then management is poor, moderate or good

if (lab_rb == "gmp") {
  # rule 6 only activated when ext and lab are moderate
  if (rule6 >= 0.33)  {
    mgt_conclusion6 = "good"
  }     else if (rule6 > -0.33) {
    mgt_conclusion6 = "moderate"
  } else {
    mgt_conclusion6 = "poor"
  }
  cat(paste("rule 6 = ", mgt_conclusion6))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_3a = mgt_conclusion6)
  df_prop <-
    add_row(df_prop,
            se_4a = "poor",
            se_4b = "moderate")
  
} else{
  cat(paste("No rule 6"))
  cat("\n")
}


#Rule 7: then management is poor, moderate or good

if (rule7 >= 0.33)  {
  mgt_conclusion7 = "good"
}     else if (rule7 > -0.33) {
  mgt_conclusion7 = "moderate"
} else {
  mgt_conclusion7 = "poor"
}
cat(paste("rule 7 = ", mgt_conclusion7))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_3a = mgt_conclusion7)
df_prop <-
  add_row(df_prop,
          se_4a = "good",
          se_4b = "poor")


#Rule 8: then farm inputs access is poor, moderate or good

if (ext_rb == "gmp") {
  # rule 8 only activated when f/p is moderate
  if (rule8 >= 0.33)  {
    mgt_conclusion8 = "good"
  }     else if (rule8 > -0.33) {
    mgt_conclusion8 = "moderate"
  } else {
    mgt_conclusion8 = "poor"
  }
  cat(paste("rule 8 = ", mgt_conclusion8))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_3a = mgt_conclusion8)
  df_prop <-
    add_row(df_prop,
            se_4a = "moderate",
            se_4b = "poor")
} else{
  cat(paste("No rule 8"))
  cat("\n")
}

#Rule 9: then management is poor

mgt_conclusion9 = "poor"
cat(paste("rule 9 = ", mgt_conclusion9))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_3a = mgt_conclusion9)
df_prop <- add_row(df_prop,
                 se_4a = "poor",
                 se_4b = "poor")

``` 

```{r i1_rulebases_management06, echo=FALSE, results='asis', eval=fp_crit}

cat("This gives the rule base:")

```

<div class="fold o"> 
```{r i1_rulebases_management07, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=management_crit}

# new proposition object is made here
prop <- new("Proposition", table = df_prop)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here

conc <- new("Conclusion", table = df_conc)

# create a rule base
rb_se_3a <- RuleBase(prop, conc) %>% print()


# in this section there are normally two criteria - ext and labour

# access to extension is based on two criteria and has a rb (se_4a) and a rbs (se_4a) which includes the two constituent parts of extension and their two rb (se_5a & se5b)

# access to labour is based on two criteria and has a rb (se_4b) and a rbs (se_4b) which includes the two constituent parts of labour and their two rb (se_5c & se5d)

# there are four fp in total (se_5a, se_5b, se_5c and se5d)

rbs_se_3a <-
  stack(rb_se_5a,
        rb_se_5b,
        rb_se_4a,
        rb_se_5c,
        rb_se_5d,
        rb_se_4b,
        rb_se_3a)


fpm_se_3a <-
  
  predict(
    rbs_se_3a,
    newdata = df_irm,
    se_5a = fp_se_5a,
    se_5b = fp_se_5b,
    se_5c = fp_se_5c,
    se_5d = fp_se_5d
  )


# write the membership values to df_irm and plot the maps of the conclusions

df_criteria_se2a_3a <-
  subset(df_priorities, grepl("^se_3a", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse2a_3a <- nrow(df_criteria_se2a_3a)

g_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se2a_3a[1, 3]))$good)
df_irm <-
  mutate(df_irm,!!as.character(paste0(df_criteria_se2a_3a[1, 3], "_g")) := g_col, .keep = c("all"))




if (ext_rb == "gmp") {
  # there is a moderate conclusion to extension giving up to nine rules and conclusions
  
  if (lab_rb == "gmp") {
    # there is a moderate conclusion to extension and labour giving  nine rules and conclusions
    mgt_rule_num <- 9
    
    if (mgt_conclusion2 == "moderate" |
        mgt_conclusion3 == "moderate" |
        mgt_conclusion4 == "moderate" |
        mgt_conclusion5 == "moderate" |
        mgt_conclusion6 == "moderate" |
        mgt_conclusion7 == "moderate" |
        mgt_conclusion8 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se2a_3a[1, 3]))$moderate)
      df_irm <-
        mutate(df_irm,!!as.character(paste0(df_criteria_se2a_3a[1, 3], "_m")) := m_col, .keep = c("all"))
      
      mgt_rb <- "gmp"
    } else { mgt_rb  <-  "gp"}
    
  } else {
    # there is a no moderate conclusion to labour giving  six rules and conclusions
    
    mgt_rule_num <- 6
    
    if (mgt_conclusion2 == "moderate" |
        mgt_conclusion3 == "moderate" |
        mgt_conclusion7 == "moderate" |
        mgt_conclusion8 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se2a_3a[1, 3]))$moderate)
      df_irm <-
        mutate(df_irm,!!as.character(paste0(df_criteria_se2a_3a[1, 3], "_m")) := m_col, .keep = c("all"))
      
      mgt_rb <- "gmp"
    } else { mgt_rb  <-  "gp"}
    
    
  }
} else {
  # there is a no moderate conclusion to extension giving  six rules and conclusions
  
  if (lab_rb == "gmp") {
    #there is a moderate conclusion to labour giving up to six rules and conclusions
    
    mgt_rule_num <- 6
    
    if (mgt_conclusion3 == "moderate" |
        mgt_conclusion4 == "moderate" |
        mgt_conclusion6 == "moderate" |
        mgt_conclusion7 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se2a_3a[1, 3]))$moderate)
      df_irm <-
        mutate(df_irm,!!as.character(paste0(df_criteria_se2a_3a[1, 3], "_m")) := m_col, .keep = c("all"))
      
      mgt_rb <- "gmp"
    } else { mgt_rb  <-  "gp"}
    
    
  }
  else {
    #there is no moderate conclusion to extension or labour giving four rules and conclusions
    
    mgt_rule_num <- 4
    
    if (mgt_conclusion3 == "moderate" |
        mgt_conclusion7 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se2a_3a[1, 3]))$moderate)
      df_irm <-
        mutate(df_irm,!!as.character(paste0(df_criteria_se2a_3a[1, 3], "_m")) := m_col, .keep = c("all"))
      
      mgt_rb <- "gmp"
    } else { mgt_rb  <-  "gp"}
  }
}

p_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se2a_3a[1, 3]))$poor)
df_irm <-
  mutate(df_irm,!!as.character(paste0(df_criteria_se2a_3a[1, 3], "_p")) := p_col, .keep = c("all"))


if (mgt_rb == "gmp") {
  n = 3
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se2a_3a[1, 3], "_g")),
      as.character(paste0(df_criteria_se2a_3a[1, 3], "_m")),
      as.character(paste0(df_criteria_se2a_3a[1, 3], "_p")),
      "x" ,
      "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se2a_3a[1, 4], " good")),
      as.character(paste0(df_criteria_se2a_3a[1, 4], " moderate")),
      as.character(paste0(df_criteria_se2a_3a[1, 4], " poor")))
} else {
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se2a_3a[1, 3], "_g")),  as.character(paste0(df_criteria_se2a_3a[1, 3], "_p")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se2a_3a[1, 4], " good")),  as.character(paste0(df_criteria_se2a_3a[1, 4], " poor")))
  
}
fpm_plot_title <-
  "Management\noptimality\nmembership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
print(plot_fpm)
     
``` 
</div>

```{r i1_rulebases_fpf01, echo=FALSE, results='asis', eval=fpf_crit}

cat("### Farm Production Feasibility

The farm production feasibility rule base (2a) combines propositions for management (rule base 3a), and access to farm inputs (rule base 3b).

Rule base 3a has the following conclusions:")

```


```{r i1_rulebases_fpf02, results='asis', warning=FALSE, eval=fpf_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria

df_criteria_se2a <-
  subset(df_priorities, grepl("^se_2a", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cse2a <- nrow(df_criteria_se2a)

# then determine and print the names of the rule bases in the Farm Production Feasibility theme

cat(paste("\n\n", n_cse2a, "Farm Production Feasibility rule bases:"))
for (i in 1:n_cse2a) {
  cat(
    paste0(
      "\n",
      df_criteria_se2a[i, 3],
      " (",
      df_criteria_se2a[i, 4],
      "):\n Weight = ",
      as.character(df_criteria_se2a[i, 5]),
      "\n"
    )
  )
}

```

```{r i1_rulebases_fpf03, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=fpf_crit}

if (mgt_rule_num == 9) {
  cat(paste("Rule base 3a has the following conclusions:"))
  
  mgt_conc_list <-
    c(
      mgt_conclusion1,
      mgt_conclusion2,
      mgt_conclusion3,
      mgt_conclusion4,
      mgt_conclusion5,
      mgt_conclusion6,
      mgt_conclusion7,
      mgt_conclusion8,
      mgt_conclusion9
    )
} else  if (mgt_rule_num == 6) {
  cat(paste("Rule base 3a has the following conclusions:"))
  
  if (ext_rb == "gmp") {
    mgt_conc_list <-
      c(
        mgt_conclusion1,
        mgt_conclusion2,
        mgt_conclusion3,
        mgt_conclusion7,
        mgt_conclusion8,
        mgt_conclusion9
      )
  } else  {
    mgt_conc_list <-
      c(
        mgt_conclusion1,
        mgt_conclusion3,
        mgt_conclusion4,
        mgt_conclusion6,
        mgt_conclusion7,
        mgt_conclusion9
      )
  }
} else  {
  cat(paste("Rule base 3a has the following conclusions:"))
  
  mgt_conc_list <-
    c(mgt_conclusion1,
      mgt_conclusion3,
      mgt_conclusion7,
      mgt_conclusion9)
}

cat(paste("\n Crop and Farm Management is", sort(unique(mgt_conc_list))))

```

```{r i1_rulebases_fpf04, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=fpf_crit}

if (inp_rb == "gmp" & inp_rule_num == 12) {
  cat(paste("Rule base 3b has the following conclusions:"))
  
  inp_conc_list <-
    c(
      inp_conclusion1,
      inp_conclusion2,
      inp_conclusion3,
      inp_conclusion4,
      inp_conclusion5,
      inp_conclusion6,
      inp_conclusion7,
      inp_conclusion8,
      inp_conclusion9,
      inp_conclusion10,
      inp_conclusion11,
      inp_conclusion12
    )
} else {
  cat(paste("Rule base 3b has the following conclusions:"))
  
  inp_conc_list <-
    c(
      inp_conclusion1,
      inp_conclusion3,
      inp_conclusion4,
      inp_conclusion6,
      inp_conclusion7,
      inp_conclusion9,
      inp_conclusion10,
      inp_conclusion12
    )
}

cat(paste("\n Farm Inputs is", sort(unique(inp_conc_list))))

```

```{r i1_rulebases_fpf05, echo=FALSE, results='asis', eval=fpf_crit}

cat("This rule base has nine possible rules and three possible outcomes: low, moderate and high feasibility:


Rule 1: If se_3a are good and se_3b is good then se_2a is high
Rule 2: If se_3a are moderate and se_3b is good then se_2a is moderate or high
Rule 3: If se_3a are poor and se_3b is good then se_2a is low, moderate or high
Rule 4: If se_3a are good and se_3b is moderate then se_2a is low, moderate or high
Rule 5: If se_3a are moderate and se_3b is moderate then se_2a is moderate
Rule 6: If se_3a are poor and se_3b is moderate then se_2a is low, moderate or high
Rule 7: If se_3a are good and se_3b is poor then se_2a is low, moderate or high
Rule 8: If se_3a are moderate and se_3b is poor then se_2a is low or moderate
Rule 9: If se_3a is poor and se_3b is poor then se_2a is low



Using the weights assigned by AHP the outcomes are the following:")

```


```{r i1_rulebases_fpf06, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=fpf_crit}


df_criteria_se3a <-
  subset(df_priorities, grepl("^se_3a", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse3a <- nrow(df_criteria_se3a)

df_criteria_se3b <-
  subset(df_priorities, grepl("^se_3b", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse3b <- nrow(df_criteria_se3b)



#Rule 2: If management access is moderate and farm inputs is good
rule2 <-
  df_criteria_se3b$weight[1]

#Rule 3: If management access is poor and farm inputs is good
rule3 <-
  -df_criteria_se3a$weight[1] + df_criteria_se3b$weight[1]

#Rule 4: If management access is good and farm inputs is moderate
rule4  <-
  df_criteria_se3a$weight[1]

#Rule 6: If management access is poor and farm inputs is moderate
rule6  <-
  -df_criteria_se3a$weight[1]

#Rule 7: If management access is good and farm inputs is poor
rule7  <-
  df_criteria_se3a$weight[1] - df_criteria_se3b$weight[1]

#Rule 8: If management access is moderate and farm inputs is poor
rule8  <-
  -df_criteria_se3b$weight[1]




rm(df_conc) # remove previous instances of df_conc
rm(df_prop) # remove previous instances of df_prop

#Rule 1: then farm production feasibility is high

fpf_conclusion1 = "high" # always good
cat(paste("rule 1 = ", fpf_conclusion1))
cat("\n")

# create table of conclusions
df_prop <-
  tibble(se_3a = "good",
         se_3b = "good")
df_conc <- tibble(se_2a = fpf_conclusion1)


#Rule 2: then farm production feasibility is moderate or good
if (mgt_rb == "gmp") {
  # rule 2 only activated when mgt is moderate
  
  if (rule2 >= 0.33)  {
    fpf_conclusion2 = "high"
  }     else if (rule2 > -0.33) {
    fpf_conclusion2 = "moderate"
  } else {
    fpf_conclusion2 = "poor"
  }
  cat(paste("rule 2 = ", fpf_conclusion2))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_2a = fpf_conclusion2)
  df_prop <-
    add_row(df_prop,
            se_3a = "moderate",
            se_3b = "good")
} else {
  cat(paste("No rule 2"))
  cat("\n")
}

#Rule 3: then farm production feasibility is low, moderate or high

if (rule3 >= 0.33)  {
  fpf_conclusion3 = "high"
}     else if (rule3 > -0.33) {
  fpf_conclusion3 = "moderate"
} else {
  fpf_conclusion3 = "low"
}

cat(paste("rule 3 = ", fpf_conclusion3))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_2a = fpf_conclusion3)
df_prop <-
  add_row(df_prop,
          se_3a = "poor",
          se_3b = "good")

#Rule 4: then farm production feasibility is low, moderate or high
if (inp_rb == "gmp") {
  # rule 4 only activated when inputs is moderate
  
  if (rule4 >= 0.33)  {
    fpf_conclusion4 = "high"
  }     else if (rule4 > -0.33) {
    fpf_conclusion4 = "moderate"
  } else {
    fpf_conclusion4 = "low"
  }
  
  cat(paste("rule 4 = ", fpf_conclusion4))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_2a = fpf_conclusion4)
  df_prop <-
    add_row(df_prop,
            se_3a = "good",
            se_3b = "moderate")
} else{
  cat(paste("No rule 4"))
  cat("\n")
}


#Rule 5: then farm production feasibility is moderate
if (mgt_rb == "gmp" & inp_rb == "gmp") {
  fpf_conclusion5 = "moderate"
  cat(paste("rule 5 = ", fpf_conclusion5))
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_2a = fpf_conclusion5)
  df_prop <- add_row(df_prop,
                   se_3a = "moderate",
                   se_3b = "moderate")
} else{
  cat(paste("No rule 5"))
  cat("\n")
}

#Rule 6: then farm production feasibility is low, moderate or high

if (inp_rb == "gmp") {
  # rule 6 only activated when mgt and lab are moderate
  if (rule6 >= 0.33)  {
    fpf_conclusion6 = "high"
  }     else if (rule6 > -0.33) {
    fpf_conclusion6 = "moderate"
  } else {
    fpf_conclusion6 = "low"
  }
  cat(paste("rule 6 = ", fpf_conclusion6))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_2a = fpf_conclusion6)
  df_prop <-
    add_row(df_prop,
            se_3a = "poor",
            se_3b = "moderate")
  
} else{
  cat(paste("No rule 6"))
  cat("\n")
}


#Rule 7: then farm production feasibility is low, moderate or high

if (rule7 >= 0.33)  {
  fpf_conclusion7 = "high"
}     else if (rule7 > -0.33) {
  fpf_conclusion7 = "moderate"
} else {
  fpf_conclusion7 = "low"
}
cat(paste("rule 7 = ", fpf_conclusion7))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_2a = fpf_conclusion7)
df_prop <-
  add_row(df_prop,
          se_3a = "good",
          se_3b = "poor")


#Rule 8: then farm production feasibility is low, moderate or high

if (mgt_rb == "gmp") {
  # rule 8 only activated when f/p is moderate
  if (rule8 >= 0.33)  {
    fpf_conclusion8 = "high"
  }     else if (rule8 > -0.33) {
    fpf_conclusion8 = "moderate"
  } else {
    fpf_conclusion8 = "low"
  }
  cat(paste("rule 8 = ", fpf_conclusion8))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_2a = fpf_conclusion8)
  df_prop <-
    add_row(df_prop,
            se_3a = "moderate",
            se_3b = "poor")
} else{
  cat(paste("No rule 8"))
  cat("\n")
}

#Rule 9: then farm production feasibility is low

fpf_conclusion9 = "low"
cat(paste("rule 9 = ", fpf_conclusion9))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_2a = fpf_conclusion9)
df_prop <- add_row(df_prop,
                 se_3a = "poor",
                 se_3b = "poor")

```

```{r i1_rulebases_fpf07, echo=FALSE, results='asis', eval=fpf_crit}

cat("This gives the rule base:")

```

<div class="fold o"> 
```{r i1_rulebases_fpf08, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=fpf_crit}

# new proposition object is made here
prop <- new("Proposition", table = df_prop)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here

conc <- new("Conclusion", table = df_conc)

# create a rule base
rb_se_2a <- RuleBase(prop, conc) %>% print()


# in this section there are normally two criteria - management and inputs

# management is based on two criteria and has a rb (se_3a) and includes extension and labour their two rb (se_4a & se4b).
# Extension includes two further criteria with rule bases (se_5a & se_5b) each with fuzzy partitions.
# Access to labour is based on two criteria and their two rb (se_5c & se5d) each with fuzzy partitions.

# farm inputs is based on three criteria and has a rb (se_3b) and includes access to seeds and land and their two rb (se_4d & se4e) each with fuzzy partitions.
# Access to fertilisers and pesticides has a rb (se_4c) and includes two criteria and their two rb (se_5e & se5f) each with fuzzy partitions.


# there are eight fp in total (se_4d, se_4e, se_5a, se_5b, se_5c, se5d, se_5e and se_5f)

rbs_se_2a <-
  stack(
    rb_se_5a,
    rb_se_5b,
    rb_se_4a,
    rb_se_5c,
    rb_se_5d,
    rb_se_4b,
    rb_se_3a,
    rb_se_5e,
    rb_se_5f,
    rb_se_4c,
    rb_se_4d,
    rb_se_4e,
    rb_se_3b,
    rb_se_2a
  )


fpm_se_2a <-
  
  predict(
    rbs_se_2a,
    newdata = df_irm,
    se_4d = fp_se_4d,
    se_4e = fp_se_4e,
    se_5a = fp_se_5a,
    se_5b = fp_se_5b,
    se_5c = fp_se_5c,
    se_5d = fp_se_5d,
    se_5e = fp_se_5e,
    se_5f = fp_se_5f
  )


# write the membership values to df_irm and plot the maps of the conclusions

df_criteria_se1_2a <-
  subset(df_priorities, grepl("^se_2a", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse1_2a <- nrow(df_criteria_se1_2a)

h_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se1_2a[1, 3]))$high)
df_irm <-
  mutate(df_irm,!!as.character(paste0(df_criteria_se1_2a[1, 3], "_h")) := h_col, .keep = c("all"))




if (mgt_rb == "gmp") {
  # there is a moderate conclusion to management giving up to nine rules and conclusions
  
  if (inp_rb == "gmp") {
    # there is a moderate conclusion to management and inputs giving nine rules and conclusions
    fpf_rule_num <- 9
    
    if (fpf_conclusion2 == "moderate" |
        fpf_conclusion3 == "moderate" |
        fpf_conclusion4 == "moderate" |
        fpf_conclusion5 == "moderate" |
        fpf_conclusion6 == "moderate" |
        fpf_conclusion7 == "moderate" |
        fpf_conclusion8 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se1_2a[1, 3]))$moderate)
      df_irm <-
        mutate(df_irm,!!as.character(paste0(df_criteria_se1_2a[1, 3], "_m")) := m_col, .keep = c("all"))
      
      fpf_rb <- "hml"
    }
    
  } else {
    # there is a no moderate conclusion to labour giving  six rules and conclusions
    
    fpf_rule_num <- 6
    
    if (fpf_conclusion2 == "moderate" |
        fpf_conclusion3 == "moderate" |
        fpf_conclusion7 == "moderate" |
        fpf_conclusion8 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se1_2a[1, 3]))$moderate)
      df_irm <-
        mutate(df_irm,!!as.character(paste0(df_criteria_se1_2a[1, 3], "_m")) := m_col, .keep = c("all"))
      
      fpf_rb <- "hml"
    }
  }
} else {
  # there is a no moderate conclusion to extension giving  six rules and conclusions
  
  if (inp_rb == "gmp") {
    #there is a moderate conclusion to labour giving up to six rules and conclusions
    
    fpf_rule_num <- 6
    
    if (fpf_conclusion3 == "moderate" |
        fpf_conclusion4 == "moderate" |
        fpf_conclusion6 == "moderate" |
        fpf_conclusion7 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se1_2a[1, 3]))$moderate)
      df_irm <-
        mutate(df_irm,!!as.character(paste0(df_criteria_se1_2a[1, 3], "_m")) := m_col, .keep = c("all"))
      
      fpf_rb <- "hml"
    }
  } else {
    #there is no moderate conclusion to extension or labour giving four rules and conclusions
    
    fpf_rule_num <- 4
    
    if (fpf_conclusion3 == "moderate" |
        fpf_conclusion7 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se1_2a[1, 3]))$moderate)
      df_irm <-
        mutate(df_irm,!!as.character(paste0(df_criteria_se1_2a[1, 3], "_m")) := m_col, .keep = c("all"))
      
      fpf_rb <- "hml"
    }
  }
}

l_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se1_2a[1, 3]))$low)
df_irm <-
  mutate(df_irm,!!as.character(paste0(df_criteria_se1_2a[1, 3], "_l")) := l_col, .keep = c("all"))


if (fpf_rb == "hml") {
  n = 3
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se1_2a[1, 3], "_h")),
      as.character(paste0(df_criteria_se1_2a[1, 3], "_m")),
      as.character(paste0(df_criteria_se1_2a[1, 3], "_l")),
      "x" ,
      "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se1_2a[1, 4], " high")),
      as.character(paste0(df_criteria_se1_2a[1, 4], " moderate")),
      as.character(paste0(df_criteria_se1_2a[1, 4], " low")))
} else {
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se1_2a[1, 3], "_h")),  as.character(paste0(df_criteria_se1_2a[1, 3], "_l")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se1_2a[1, 4], " high")),  as.character(paste0(df_criteria_se1_2a[1, 4], " low")))
  
}
fpm_plot_title <-
  "Farm Production\nFeasibility\noptimality\nmembership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
print(plot_fpm)
  
``` 
</div>

```{r i1_rulebases_market_access01, echo=FALSE, results='asis', eval=mktaccess_crit}

cat("### Market Access

The market access rule base (se_2b) combines propositions for time to kebele markets (rule base se_3c), time to woreda markets (rule base se_3d) and time to zonal centre (wholesalers) (rule base se_3d).

Rule base se_2b has the following propositions:

[1] '(1) se_3c is good'  '(1) se_3c is poor'
[1] '(2) se_3d is good'  '(2) se_3d is poor'
[1] '(3) se_3e is good'  '(3) se_3e is poor'")

```


```{r i1_rulebases_market_access02, cache = TRUE, cache.whatever=params$Agg, results='asis', eval=mktaccess_crit}

for (i in 1:(nrow(df_criteria_se2b))) {
  print(paste0(
    df_criteria_se2b[i, 3],
    " (",
    df_criteria_se2b[i, 4],
    "): Weight = ",
    as.character(df_criteria_se2b[i, 5])
  ))
}

``` 


```{r i1_rulebases_market_access03, echo=FALSE, results='asis', eval=mktaccess_crit}

cat("This rule base has eight rules and three possible outcomes: good, moderate and poor access:

Rule 1: If se_3c  is good and se_3d  is good and se_3e  is good then se_2b is good
Rule 2: If se_3c  is poor and se_3d  is good and se_3e  is good then se_2b is poor, moderate or good
Rule 3: If se_3c  is good and se_3d  is poor and se_3e  is good then se_2b is poor, moderate or good
Rule 4: If se_3c  is poor and se_3d  is poor and se_3e  is good then se_2b is poor, moderate or good
Rule 5: If se_3c  is good and se_3d  is good and se_3e  is poor then se_2b is poor, moderate or good
Rule 6: If se_3c  is poor and se_3d  is good and se_3e  is poor then se_2b is poor, moderate or good
Rule 7: If se_3c  is good and se_3d  is poor and se_3e  is poor then se_2b is poor, moderate or good
Rule 8: If se_3c  is poor and se_3d  is poor and se_3e  is poor then se_2b is poor

Using the weights assigned by AHP the outcomes are the following:")

```

 
```{r i1_rulebases_market_access04, cache = TRUE, cache.whatever=params$Agg, results='asis', eval=mktaccess_crit}

df_criteria_se3c <-
  subset(df_priorities, grepl("^se_3c", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse3c <- nrow(df_criteria_se3c)

df_criteria_se3d <-
  subset(df_priorities, grepl("^se_3d", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse3d <- nrow(df_criteria_se3d)

df_criteria_se3e <-
  subset(df_priorities, grepl("^se_3e", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse3e <- nrow(df_criteria_se3e)



#Rule 2: If kebele market access is poor and woreda market access is good and zonal market access is good
rule2 <-
  -df_criteria_se3c$weight[1] + df_criteria_se3d$weight[1] + df_criteria_se3e$weight[1]

#Rule 3: If kebele market access is good and woreda market access is poor and zonal market access is good
rule3 <-
  df_criteria_se3c$weight[1] - df_criteria_se3d$weight[1] + df_criteria_se3e$weight[1]

#Rule 4: If kebele market access is poor and woreda market access is poor and zonal market access is good
rule4 <-
  -df_criteria_se3c$weight[1] - df_criteria_se3d$weight[1] + df_criteria_se3e$weight[1]

#Rule 5: If kebele market access is good and woreda market access is good and zonal market access is poor
rule5 <-
  df_criteria_se3c$weight[1] + df_criteria_se3d$weight[1] - df_criteria_se3e$weight[1]

#Rule 6: If kebele market access is poor and woreda market access is good and zonal market access is poor
rule6 <-
  -df_criteria_se3c$weight[1] + df_criteria_se3d$weight[1] - df_criteria_se3e$weight[1]

#Rule 7: If kebele market access is good and woreda market access is poor and zonal market access is poor
rule7 <-
  df_criteria_se3c$weight[1] - df_criteria_se3d$weight[1] - df_criteria_se3e$weight[1]


rm(df_conc) # remove previous instances of df_conc

#Rule 1: then market access is always good
ma_conclusion1 = "good"
cat(paste("rule 1 = ", ma_conclusion1))
cat("\n")
# create table of conclusions
df_conc <- tibble(se_2b = ma_conclusion1)

#Rule 2: then market access is poor, moderate or good
if (rule2 >= 0.33)  {
  ma_conclusion2 = "good"
}     else if (rule2 > -0.33) {
  ma_conclusion2 = "moderate"
} else {
  ma_conclusion2 = "poor"
}
cat(paste("rule 2 = ", ma_conclusion2))
cat("\n")
df_conc <- add_row(df_conc, se_2b = ma_conclusion2)

#Rule 3: then market access is poor, moderate or good
if (rule3 >= 0.33)  {
  ma_conclusion3 = "good"
}     else if (rule3 > -0.33) {
  ma_conclusion3 = "moderate"
} else {
  ma_conclusion3 = "poor"
}
cat(paste("rule 3 = ", ma_conclusion3))
cat("\n")
df_conc <- add_row(df_conc, se_2b = ma_conclusion3)

#Rule 4: then market access is poor, moderate or good
if (rule4 >= 0.33)  {
  ma_conclusion4 = "good"
}     else if (rule4 > -0.33) {
  ma_conclusion4 = "moderate"
} else {
  ma_conclusion4 = "poor"
}
cat(paste("rule 4 = ", ma_conclusion4))
cat("\n")
df_conc <- add_row(df_conc, se_2b = ma_conclusion4)

#Rule 5: then market access is poor, moderate or good
if (rule5 >= 0.33)  {
  ma_conclusion5 = "good"
}     else if (rule5 > -0.33) {
  ma_conclusion5 = "moderate"
} else {
  ma_conclusion5 = "poor"
}
cat(paste("rule 5 = ", ma_conclusion5))
cat("\n")
df_conc <- add_row(df_conc, se_2b = ma_conclusion5)

#Rule 6: then market access is poor, moderate or good
if (rule6 >= 0.33)  {
  ma_conclusion6 = "good"
}     else if (rule6 > -0.33) {
  ma_conclusion6 = "moderate"
} else {
  ma_conclusion6 = "poor"
}
cat(paste("rule 6 = ", ma_conclusion6))
cat("\n")
df_conc <- add_row(df_conc, se_2b = ma_conclusion6)

#Rule 7: then market access is poor, moderate or good
if (rule7 >= 0.33)  {
  ma_conclusion7 = "good"
}     else if (rule7 > -0.33) {
  ma_conclusion7 = "moderate"
} else {
  ma_conclusion7 = "poor"
}
cat(paste("rule 7 = ", ma_conclusion7))
cat("\n")
df_conc <- add_row(df_conc, se_2b = ma_conclusion7)

#Rule 8: then market access is always poor
ma_conclusion8 = "poor"
cat(paste("rule 8 = ", ma_conclusion8))
df_conc <- add_row(df_conc, se_2b = ma_conclusion8)

``` 

```{r i1_rulebases_market_access05, echo=FALSE, results='asis', eval=mktaccess_crit}

cat("This gives the rule base:")

```

<div class="fold o"> 
```{r i1_rulebases_market_access06, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=mktaccess_crit}


df_criteria_se1_2b <-
  subset(df_priorities, grepl("^se_2b", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse1_2b <- nrow(df_criteria_se1_2b)

# df_criteria_se2b includes all of the market access criteria
# for each criterion we know that the new proposition is the same as the conclusion from the previous rule base

assign(paste0("rbs_", df_criteria_se1_2b[1, 3], "_list"), c()) # initialise the rule base list
assign(paste0("fp_", df_criteria_se1_2b[1, 3], "_list"), c()) # initialise the fuzzy partition list
rm(df_prop) # remove previous instances of df_prop

rm(prop)
rm(conc)
for (i in 1:(nrow(df_criteria_se2b))) {
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_se2b[i, 3]), "_o")
  
  # for those criteria with three conclusion values
  # get  the 3 conclusion levels and get the unique values
  prop_levels <-
    c(as.character(df_criteria_se2b[i, 19]),
      as.character(df_criteria_se2b[i, 20]))  %>% unique()
  
  
  
  # set the proposition values
  if (!exists("df_prop")) {
    df_prop <- tibble(!!Prop_name := c(prop_levels))
  } else {
    #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
    df_prop <-
      bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
  }
  
  # get a list of the previous rule bases
  assign(paste0("rbs_", df_criteria_se1_2b[1, 3], "_list"),
         append(get(
           paste0("rbs_", df_criteria_se1_2b[1, 3], "_list")
         ), paste0("rb_", df_criteria_se2b[i, 3])))
  
  # get a list of the fuzzy partitions
  assign(paste0("fp_", df_criteria_se1_2b[1, 3], "_list"),
         append(
           get(paste0("fp_", df_criteria_se1_2b[1, 3], "_list")),
           paste0(df_criteria_se2b[i, 3], " = fp_", df_criteria_se2b[i, 3])
         ))
}

# new proposition object is made here
prop <- new("Proposition", table = df_prop %>% cross_df)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here

conc <- new("Conclusion", table = df_conc)

# create a rule base
assign(paste0("rb_", df_criteria_se1_2b[1, 3]), RuleBase(prop, conc)) %>% print()


# add to the list of previous rule bases

assign(paste0("rbs_", df_criteria_se1_2b[1, 3], "_list"),
       append(get(
         paste0("rbs_", df_criteria_se1_2b[1, 3], "_list")
       ), paste0("rb_", df_criteria_se1_2b[1, 3])))

# create the rule base stack from the list

# original rbs_tmp_aptitude <- stack(rb_tmp_g_4a, rb_tmp_v_4b, rb_tmp_f_4c, rb_tmp_r_4d, rb_P_3a)

x <-
  paste("stack(", gsub(",$", "", paste0(
    get(paste0("rbs_", df_criteria_se1_2b[1, 3], "_list")), sep = ",", collapse = ""
  )), ")")

rbs_tmp <-
  assign(paste0("rbs_", df_criteria_se1_2b[1, 3]), eval(parse(text = x)))

# evaluate the rule base stack

w <-
  paste("predict(",
        "rbs_tmp, newdata = df_irm,",
        gsub(",$", "", paste0(
          get(paste0("fp_", df_criteria_se1_2b[1, 3], "_list")), sep = ",", collapse = ""
        )),
        ")")

assign(paste0("fpm_", df_criteria_se1_2b[1, 3]), eval(parse(text = w)))




g_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se1_2b[1, 3]))$good)
df_irm <-
  mutate(df_irm,!!as.character(paste0(df_criteria_se1_2b[1, 3], "_g")) := g_col, .keep = c("all"))

if (ma_conclusion2 == "moderate" |
    ma_conclusion3 == "moderate" |
    ma_conclusion4 == "moderate" |
    ma_conclusion5 == "moderate" |
    ma_conclusion6 == "moderate" | ma_conclusion7 == "moderate") {
  m_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se1_2b[1, 3]))$moderate)
  df_irm <-
    mutate(df_irm,!!as.character(paste0(df_criteria_se1_2b[1, 3], "_m")) := m_col, .keep = c("all"))
  
  ma_rb <- "gmp"
} else
  ma_rb <- "gp"

p_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se1_2b[1, 3]))$poor)
df_irm <-
  mutate(df_irm,!!as.character(paste0(df_criteria_se1_2b[1, 3], "_p")) := p_col, .keep = c("all"))


if (ma_rb == "gmp") {
  n = 3
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se1_2b[1, 3], "_g")),
      as.character(paste0(df_criteria_se1_2b[1, 3], "_m")),
      as.character(paste0(df_criteria_se1_2b[1, 3], "_p")),
      "x" ,
      "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se1_2b[1, 4], " good")),
      as.character(paste0(df_criteria_se1_2b[1, 4], " moderate")),
      as.character(paste0(df_criteria_se1_2b[1, 4], " poor")))
} else {
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se1_2b[1, 3], "_g")),  as.character(paste0(df_criteria_se1_2b[1, 3], "_p")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se1_2b[1, 4], " good")),  as.character(paste0(df_criteria_se1_2b[1, 4], " poor")))
  
}
fpm_plot_title <-
  "Market\nAccess\noptimality\nmembership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
print(plot_fpm)

``` 
</div>

```{r i1_rulebases_sef02, echo=FALSE, results='asis', eval=sef_crit}

cat("### Socio-Economic Feasibility

Socio-Economic feasibility rule base (1) combines propositions for farm production feasibility (rule base 2a), and Market Access (rule base 2b).

Rule base 2a has the following conclusions:")

```


```{r i1_rulebases_sef03, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=sef_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria


df_criteria_se1 <-
  subset(df_priorities, grepl("^se_1", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cse1 <- nrow(df_criteria_se1)

# then determine and print the names of the rule bases in the Socio-Economic Feasibility theme

cat(paste("\n\n", n_cse1, "Socio-Economic Feasibility rule bases:"))
for (i in 1:n_cse1) {
  cat(
    paste0(
      "\n",
      df_criteria_se1[i, 3],
      " (",
      df_criteria_se1[i, 4],
      "):\n Weight = ",
      as.character(df_criteria_se1[i, 5]),
      "\n"
    )
  )
}

```

```{r i1_rulebases_sef04, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=sef_crit}

if (fpf_rule_num == 9) {
  cat(paste("Rule base 2a has the following conclusions:"))
  
  fpf_conc_list <-
    c(
      fpf_conclusion1,
      fpf_conclusion2,
      fpf_conclusion3,
      fpf_conclusion4,
      fpf_conclusion5,
      fpf_conclusion6,
      fpf_conclusion7,
      fpf_conclusion8,
      fpf_conclusion9
    )
} else  if (fpf_rule_num == 6) {
  cat(paste("Rule base 2a has the following conclusions:"))
  
  if (mgt_rb == "gmp") {
    fpf_conc_list <-
      c(
        fpf_conclusion1,
        fpf_conclusion2,
        fpf_conclusion3,
        fpf_conclusion7,
        fpf_conclusion8,
        fpf_conclusion9
      )
  } else  {
    fpf_conc_list <-
      c(
        fpf_conclusion1,
        fpf_conclusion3,
        fpf_conclusion4,
        fpf_conclusion6,
        fpf_conclusion7,
        fpf_conclusion9
      )
  }
} else  {
  cat(paste("Rule base 2a has the following conclusions:"))
  
  fpf_conc_list <-
    c(fpf_conclusion1,
      fpf_conclusion3,
      fpf_conclusion7,
      fpf_conclusion9)
}

cat(paste("\n Farm Production Feasibility is", sort(unique(fpf_conc_list))))

```


```{r i1_rulebases_sef05, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=sef_crit}

ma_conc_list <-
  c(
    ma_conclusion1,
    ma_conclusion2,
    ma_conclusion3,
    ma_conclusion4,
    ma_conclusion5,
    ma_conclusion6,
    ma_conclusion7,
    ma_conclusion8
  )
cat(paste("\n Market Access is", sort(unique(ma_conc_list))))

```


```{r i1_rulebases_sef06, echo=FALSE, results='asis', eval=sef_crit}

cat("This rule base has nine possible rules and three possible outcomes: low, moderate and high feasibility:

Rule 1: If se_3a are high and se_3b is good then se_2a is high
Rule 2: If se_3a are moderate and se_3b is good then se_2a is moderate or high
Rule 3: If se_3a are low and se_3b is good then se_2a is low, moderate or high
Rule 4: If se_3a are high and se_3b is moderate then se_2a is low, moderate or high
Rule 5: If se_3a are moderate and se_3b is moderate then se_2a is moderate
Rule 6: If se_3a are low and se_3b is moderate then se_2a is low, moderate or high
Rule 7: If se_3a are high and se_3b is poor then se_2a is low, moderate or good
Rule 8: If se_3a are moderate and se_3b is poor then se_2a is low or moderate
Rule 9: If se_3a is low and se_3b is poor then se_2a is low

Using the weights assigned by AHP the outcomes are the following:")

```


```{r i1_rulebases_sef07, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=sef_crit}

df_criteria_se2a <-
  subset(df_priorities, grepl("^se_2a", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse2a <- nrow(df_criteria_se2a)

df_criteria_se2b <-
  subset(df_priorities, grepl("^se_2b", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse2b <- nrow(df_criteria_se2b)



#Rule 2: If fp feasibility is moderate and market access is good
rule2 <-
  df_criteria_se2b$weight[1]

#Rule 3: If fp feasibility is low and market access is good
rule3 <-
  -df_criteria_se2a$weight[1] + df_criteria_se2b$weight[1]

#Rule 4: If fp feasibility is high and market access is moderate
rule4  <-
  df_criteria_se2a$weight[1]

#Rule 6: If fp feasibility is low and market access is moderate
rule6  <-
  -df_criteria_se2a$weight[1]

#Rule 7: If fp feasibility is high and market access is poor
rule7  <-
  df_criteria_se2a$weight[1] - df_criteria_se2b$weight[1]

#Rule 8: If fp feasibility is moderate and market access is poor
rule8  <-
  -df_criteria_se2b$weight[1]




rm(df_conc) # remove previous instances of df_conc
rm(df_prop) # remove previous instances of df_prop

#Rule 1: then socio-economic feasibility is high

sef_conclusion1 = "high" # always high
cat(paste("rule 1 = ", sef_conclusion1))
cat("\n")

# create table of conclusions
df_prop <-
  tibble(se_2a = "high",
         se_2b = "good")
df_conc <- tibble(se_1 = sef_conclusion1)


#Rule 2: then socio-economic feasibility is moderate or high
if (fpf_rb == "hml") {
  # rule 2 only activated when fpf is moderate
  
  if (rule2 >= 0.33)  {
    sef_conclusion2 = "high"
  }     else if (rule2 > -0.33) {
    sef_conclusion2 = "moderate"
  } else {
    sef_conclusion2 = "low"
  }
  cat(paste("rule 2 = ", sef_conclusion2))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_1 = sef_conclusion2)
  df_prop <-
    add_row(df_prop,
            se_2a = "moderate",
            se_2b = "good")
} else {
  cat(paste("No rule 2"))
  cat("\n")
}

#Rule 3: then socio-economic feasibility is low, moderate or high

if (rule3 >= 0.33)  {
  sef_conclusion3 = "high"
}     else if (rule3 > -0.33) {
  sef_conclusion3 = "moderate"
} else {
  sef_conclusion3 = "low"
}

cat(paste("rule 3 = ", sef_conclusion3))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_1 = sef_conclusion3)
df_prop <-
  add_row(df_prop,
          se_2a = "low",
          se_2b = "good")

#Rule 4: then socio-economic feasibility is low, moderate or high
if (ma_rb == "gmp") {
  # rule 4 only activated when ma is moderate
  
  if (rule4 >= 0.33)  {
    sef_conclusion4 = "high"
  }     else if (rule4 > -0.33) {
    sef_conclusion4 = "moderate"
  } else {
    sef_conclusion4 = "low"
  }
  
  cat(paste("rule 4 = ", sef_conclusion4))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_1 = sef_conclusion4)
  df_prop <-
    add_row(df_prop,
            se_2a = "high",
            se_2b = "moderate")
} else{
  cat(paste("No rule 4"))
  cat("\n")
}


#Rule 5: then socio-economic feasibility is moderate
if (fpf_rb == "hml" & ma_rb == "gmp") {
  sef_conclusion5 = "moderate"
  cat(paste("rule 5 = ", sef_conclusion5))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_1 = sef_conclusion5)
  df_prop <- add_row(df_prop,
                   se_2a = "moderate",
                   se_2b = "moderate")
} else{
  cat(paste("No rule 5"))
  cat("\n")
}

#Rule 6: then socio-economic feasibility is low, moderate or high

if (ma_rb == "gmp") {
  # rule 6 only activated when fpf and ma are moderate
  if (rule6 >= 0.33)  {
    sef_conclusion6 = "high"
  }     else if (rule6 > -0.33) {
    sef_conclusion6 = "moderate"
  } else {
    sef_conclusion6 = "low"
  }
  cat(paste("rule 6 = ", sef_conclusion6))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_1 = sef_conclusion6)
  df_prop <-
    add_row(df_prop,
            se_2a = "low",
            se_2b = "moderate")
  
} else{
  cat(paste("No rule 6"))
  cat("\n")
}


#Rule 7: then socio-economic feasibility is low, moderate or high

if (rule7 >= 0.33)  {
  sef_conclusion7 = "high"
}     else if (rule7 > -0.33) {
  sef_conclusion7 = "moderate"
} else {
  sef_conclusion7 = "low"
}
cat(paste("rule 7 = ", sef_conclusion7))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_1 = sef_conclusion7)
df_prop <-
  add_row(df_prop,
          se_2a = "high",
          se_2b = "poor")


#Rule 8: then socio-economic feasibility is low, moderate or high

if (fpf_rb == "hml") {
  # rule 8 only activated when fpf is moderate
  if (rule8 >= 0.33)  {
    sef_conclusion8 = "high"
  }     else if (rule8 > -0.33) {
    sef_conclusion8 = "moderate"
  } else {
    sef_conclusion8 = "low"
  }
  cat(paste("rule 8 = ", sef_conclusion8))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_1 = sef_conclusion8)
  df_prop <-
    add_row(df_prop,
            se_2a = "moderate",
            se_2b = "poor")
} else{
  cat(paste("No rule 8"))
  cat("\n")
}

#Rule 9: then socio-economic feasibility is low

sef_conclusion9 = "low"
cat(paste("rule 9 = ", sef_conclusion9))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_1 = sef_conclusion9)
df_prop <- add_row(df_prop,
                 se_2a = "low",
                 se_2b = "poor")

```

```{r i1_rulebases_sef08, echo=FALSE, results='asis', eval=sef_crit}

cat("This gives the rule base:")

```

<div class="fold o"> 
```{r i1_rulebases_sef09, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=sef_crit}

# new proposition object is made here
prop <- new("Proposition", table = df_prop)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here

conc <- new("Conclusion", table = df_conc)

# create a rule base
rb_se_1 <- RuleBase(prop, conc) %>% print()


# in this section there are normally two criteria - fp feasibility and market access

# fp feasibility is based on two criteria and has a rb (se_2a) and includes management and inputs and their two rb (se_3a & se3b).
# management is based on two criteria: extension and labour their two rb (se_4a & se4b).
# Extension includes two further criteria with rule bases (se_5a & se_5b) each with fuzzy partitions.
# Access to labour is based on two criteria and their two rb (se_5c & se5d) each with fuzzy partitions.

# farm inputs is based on three criteria: access to seeds and land and their two rb (se_4d & se4e) each with fuzzy partitions.
# Access to fertilisers and pesticides has a rb (se_4c) and includes two criteria and their two rb (se_5e & se5f) each with fuzzy partitions.

# market access has a rb (se_2b) and includes three criteria and their three rb (se_3c, se_3d & se3e) each with fuzzy partitions.

# there are eleven fp in total (se_3c, se_3d, se3e, se_4d, se_4e, se_5a, se_5b, se_5c, se5d, se_5e and se_5f)

rbs_se_1 <-
  stack(
    rb_se_5a,
    rb_se_5b,
    rb_se_4a,
    rb_se_5c,
    rb_se_5d,
    rb_se_4b,
    rb_se_3a,
    rb_se_5e,
    rb_se_5f,
    rb_se_4c,
    rb_se_4d,
    rb_se_4e,
    rb_se_3b,
    rb_se_2a,
    rb_se_3c,
    rb_se_3d,
    rb_se_3e,
    rb_se_2b,
    rb_se_1
  )


fpm_se_1 <-
  
  predict(
    rbs_se_1,
    newdata = df_irm,
    se_3c = fp_se_3c,
    se_3d = fp_se_3d,
    se_3e = fp_se_3e,
    se_4d = fp_se_4d,
    se_4e = fp_se_4e,
    se_5a = fp_se_5a,
    se_5b = fp_se_5b,
    se_5c = fp_se_5c,
    se_5d = fp_se_5d,
    se_5e = fp_se_5e,
    se_5f = fp_se_5f
  )


# write the membership values to df_irm and plot the maps of the conclusions

df_criteria_se1 <-
  subset(df_priorities, grepl("^se_1", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse1 <- nrow(df_criteria_se1)

h_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se1[1, 3]))$high)
df_irm <-
  mutate(df_irm,!!as.character(paste0(df_criteria_se1[1, 3], "_h")) := h_col, .keep = c("all"))




if (fpf_rb == "hml") {
  # there is a moderate conclusion to fp feasibility giving up to nine rules and conclusions
  
  if (ma_rb == "gmp") {
    # there is a moderate conclusion to fp feasibility and market access giving nine rules and conclusions
    sef_rule_num <- 9
    
    if (sef_conclusion2 == "moderate" |
        sef_conclusion3 == "moderate" |
        sef_conclusion4 == "moderate" |
        sef_conclusion5 == "moderate" |
        sef_conclusion6 == "moderate" |
        sef_conclusion7 == "moderate" |
        sef_conclusion8 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se1[1, 3]))$moderate)
      df_irm <-
        mutate(df_irm,!!as.character(paste0(df_criteria_se1[1, 3], "_m")) := m_col, .keep = c("all"))
      
      sef_rb <- "hml"
    }
    
  } else {
    # there is a no moderate conclusion to market access giving  six rules and conclusions
    
    sef_rule_num <- 6
    
    if (sef_conclusion2 == "moderate" |
        sef_conclusion3 == "moderate" |
        sef_conclusion7 == "moderate" |
        sef_conclusion8 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se1[1, 3]))$moderate)
      df_irm <-
        mutate(df_irm,!!as.character(paste0(df_criteria_se1[1, 3], "_m")) := m_col, .keep = c("all"))
      
      sef_rb <- "hml"
    }
  }
} else {
  # there is a no moderate conclusion to fp feasibility giving  six rules and conclusions
  
  if (ma_rb == "gmp") {
    #there is a moderate conclusion to market access giving up to six rules and conclusions
    
    sef_rule_num <- 6
    
    if (sef_conclusion3 == "moderate" |
        sef_conclusion4 == "moderate" |
        sef_conclusion6 == "moderate" |
        sef_conclusion7 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se1[1, 3]))$moderate)
      df_irm <-
        mutate(df_irm,!!as.character(paste0(df_criteria_se1[1, 3], "_m")) := m_col, .keep = c("all"))
      
      sef_rb <- "hml"
    }
  }  else {
    #there is no moderate conclusion to fp feasibility or market access giving four rules and conclusions
    
    sef_rule_num <- 4
    
    if (sef_conclusion3 == "moderate" |
        sef_conclusion7 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se1[1, 3]))$moderate)
      df_irm <-
        mutate(df_irm,!!as.character(paste0(df_criteria_se1[1, 3], "_m")) := m_col, .keep = c("all"))
      
      sef_rb <- "hml"
    }
  }
}

l_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se1[1, 3]))$low)
df_irm <-
  mutate(df_irm,!!as.character(paste0(df_criteria_se1[1, 3], "_l")) := l_col, .keep = c("all"))


if (sef_rb == "hml") {
  n = 3
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se1[1, 3], "_h")),
      as.character(paste0(df_criteria_se1[1, 3], "_m")),
      as.character(paste0(df_criteria_se1[1, 3], "_l")),
      "x" ,
      "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se1[1, 4], " high")),
      as.character(paste0(df_criteria_se1[1, 4], " moderate")),
      as.character(paste0(df_criteria_se1[1, 4], " low")))
} else {
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se1[1, 3], "_h")),  as.character(paste0(df_criteria_se1[1, 3], "_l")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se1[1, 4], " high")),  as.character(paste0(df_criteria_se1[1, 4], " low")))
  
}
fpm_plot_title <-
  "Socio-Economic\nFeasibility\noptimality\nmembership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
print(plot_fpm)

``` 
</div>


```{r i1_rulebases_sef_score01, echo=FALSE, results='asis', eval=sef_crit, eval=adop_crit}

cat("To combine with the biophysical aptitude we will convert the Socio-Economic Feasibility values to optimal and suboptimal scores between 1 and 0.

*Optimal*
High feasibility has a value of 1.
Moderate feasibility has a value of 0.5.
Low feasibility has a value of 0.

*Sub-Optimal*
High feasibility has a value of 0.
Moderate feasibility has a value of 0.5.
Low feasibility has a value of 1.

For example the following feasibility values would give these scores:

High | Moderate | Low |  optimal | suboptimal
---|---|---|---|---|---
0.9 | 0.1 | 0 | 0.95 | 0.05
0.6| 0.2 | 0.2 |  0.7 | 0.3
0.3| 0.3 | 0.4|  0.45 | 0.55
0.2 | 0.3 | 0.5 | 0.35 | 0.65
")

```

<div class="fold o">
```{r i1_rulebases_sef_score02, echo=FALSE, results='asis', eval=sef_crit, eval=adop_crit}

if ("se_1_m" %in% colnames(df_irm)) {
  # calculate scores when moderate sef conclusion exists
  
  df_irm <-
    mutate(df_irm, se_1_o := (se_1_h + (se_1_m / 2)), .keep = c("all"))
  df_irm <-
    mutate(df_irm, se_1_s := (se_1_l + (se_1_m / 2)), .keep = c("all"))
}   else {
  # calculate scores when moderate sef conclusion does not exist
  df_irm <-
    mutate(df_irm, se_1_o := (se_1_h), .keep = c("all"))
  df_irm <-
    mutate(df_irm, se_1_s := (se_1_l), .keep = c("all"))
}

```
</div>



```{r i1_rulebases_se_export01, echo=FALSE, results='asis', eval=sef_crit}

cat("## Export feasibility results

")
```

<div class="fold o">
```{r i1_rulebases_se_export02, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, warning=FALSE, eval=sef_crit}

vect_se <- vect(df_irm, geom = c("x", "y"), crs = wkt_lam)
output_vect(vect_se, paste0("sf_", params$INN1))

``` 
</div>

```{r i1_rulebases_adoption01, echo=FALSE, results='asis', eval=adop_crit}

cat("### Likelihood for Adoption - three class

Likelihood for Adoption rule base (0) combines propositions for biophysical aptitude (rule base ba_1) and socio-economic feasibility (rule base se_1).

")

```

<div class="fold o"> 
```{r i1_rulebases_adoption02, results='asis', warning=FALSE, eval=adop_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria

df_criteria_0 <-
  subset(df_priorities, grepl("^adop_0", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_c0 <- nrow(df_criteria_0)

# then determine and print the names of the rule bases in the Likelihood of Adoption theme

cat(paste("\n\n", n_c0, "Likelihood of Adoption rule bases:"))
for (i in 1:n_c0) {
  cat(paste0(
    "\n",
    df_criteria_0[i, 3],
    " (",
    df_criteria_0[i, 4],
    "):\n Weight = ",
    as.character(df_criteria_0[i, 5]),
    "\n"
  ))
}

```
</div>

```{r i1_rulebases_adoption03, echo=FALSE, results='asis', eval=adop_crit}

cat("Rule base ba_1 has the following conclusions:")

```

```{r i1_rulebases_adoption04, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=adop_crit}

cat(paste("Rule base ba_1 has the following conclusions:"))

ba_conc_list <-
  c("optimal",
    "suboptimal")
cat(paste("\n Biophysical Aptitude is", sort(unique(ba_conc_list))))

```

```{r i1_rulebases_adoption05, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=adop_crit}

if (sef_rule_num == 9) {
  cat(paste("Rule base se_1 has the following conclusions:"))
  
  sef_conc_list <-
    c(
      sef_conclusion1,
      sef_conclusion2,
      sef_conclusion3,
      sef_conclusion4,
      sef_conclusion5,
      sef_conclusion6,
      sef_conclusion7,
      sef_conclusion8,
      sef_conclusion9
    )
} else  if (sef_rule_num == 6) {
  cat(paste("Rule base se_1 has the following conclusions:"))
  
  if (fpf_rb == "hml") {
    sef_conc_list <-
      c(
        sef_conclusion1,
        sef_conclusion2,
        sef_conclusion3,
        sef_conclusion7,
        sef_conclusion8,
        sef_conclusion9
      )
  } else  {
    sef_conc_list <-
      c(
        sef_conclusion1,
        sef_conclusion3,
        sef_conclusion4,
        sef_conclusion6,
        sef_conclusion7,
        sef_conclusion9
      )
  }
} else  {
  cat(paste("Rule base se_1 has the following conclusions:"))
  
  sef_conc_list <-
    c(sef_conclusion1,
      sef_conclusion3,
      sef_conclusion7,
      sef_conclusion9)
}

cat(paste("\n Socio-Economic Feasibility is", sort(unique(sef_conc_list))))

```

```{r i1_rulebases_adoption06, echo=FALSE, results='asis', eval=adop_crit}

cat("Likelihood for Adoption rule base has six possible rules and three possible outcomes: low, moderate and high likelihood for adoption

Rule 1: If Biophysical Aptitude is optimal and Socio-Economic Feasibility is high then Suitability is high
Rule 2: If Biophysical Aptitude is optimal and Socio-Economic Feasibility is moderate then Suitability is moderate or high
Rule 3: If Biophysical Aptitude is optimal and Socio-Economic Feasibility is low then Suitability is low, moderate or high
Rule 4: If Biophysical Aptitude is suboptimal and Socio-Economic Feasibility is high then Suitability is low, moderate or good
Rule 5: If Biophysical Aptitude is suboptimal and Socio-Economic Feasibility is moderate then Suitability is low or moderate
Rule 6: If Biophysical Aptitude is suboptimal and Socio-Economic Feasibility is low then Suitability is low


Using the weights assigned by AHP the outcomes are the following:")

```


```{r i1_rulebases_adoption07, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=adop_crit}



df_criteria_ba1 <-
  subset(df_priorities, grepl("^ba_1", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cba1 <- nrow(df_criteria_ba1)

df_criteria_se1 <-
  subset(df_priorities, grepl("^se_1", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse1 <- nrow(df_criteria_se1)


#Rule 2: If ba is suboptimal and se is high
rule2 <-
  -df_criteria_ba1$weight[1] + df_criteria_se1$weight[1]

#Rule 3: If ba is optimal and se is moderate
rule3  <-
  df_criteria_ba1$weight[1]

#Rule 4: If ba is suboptimal and se is moderate
rule4  <-
  -df_criteria_ba1$weight[1]

#Rule 5: If ba is optimal and se is low
rule5  <-
  df_criteria_ba1$weight[1] - df_criteria_se1$weight[1]


rm(df_conc) # remove previous instances of df_conc
rm(df_prop) # remove previous instances of df_prop

#Rule 1: then adoption likelihood is high

adop_conclusion1 = "high" # always high
cat(paste("rule 1 = ", adop_conclusion1))
cat("\n")

# create table of conclusions
df_prop <-
  tibble(ba_1 = "optimal",
         se_1 = "high")
df_conc <- tibble(adop_0 = adop_conclusion1)



#Rule 2: then adoption likelihood is low, moderate or high

if (rule2 >= 0.33)  {
  adop_conclusion2 = "high"
}     else if (rule2 > -0.33) {
  adop_conclusion2 = "moderate"
} else {
  adop_conclusion2 = "low"
}

cat(paste("rule 2 = ", adop_conclusion2))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, adop_0 = adop_conclusion2)
df_prop <-
  add_row(df_prop,
          ba_1 = "suboptimal",
          se_1 = "high")


#Rule 3: then adoption likelihood is moderate or high
if (sef_rb == "hml") {
  # rule 3 only activated when sef is moderate
  
  if (rule3 >= 0.33)  {
    adop_conclusion3 = "high"
  }     else if (rule3 > -0.33) {
    adop_conclusion3 = "moderate"
  } else {
    adop_conclusion3 = "low"
  }
  cat(paste("rule 3 = ", adop_conclusion3))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, adop_0 = adop_conclusion3)
  df_prop <-
    add_row(df_prop,
            ba_1 = "optimal",
            se_1 = "moderate")
} else {
  cat(paste("No rule 3"))
  cat("\n")
}



#Rule 4: then adoption likelihood is moderate or low
if (sef_rb == "hml") {
  # rule 4 only activated when sef is moderate
  
  if (rule4 >= 0.33)  {
    adop_conclusion4 = "high"
  }     else if (rule4 > -0.33) {
    adop_conclusion4 = "moderate"
  } else {
    adop_conclusion4 = "low"
  }
  cat(paste("rule 4 = ", adop_conclusion4))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, adop_0 = adop_conclusion4)
  df_prop <-
    add_row(df_prop,
            ba_1 = "suboptimal",
            se_1 = "moderate")
} else {
  cat(paste("No rule 4"))
  cat("\n")
}


#Rule 5: then adoption likelihood is low, moderate or high

if (rule5 >= 0.33)  {
  adop_conclusion5 = "high"
}     else if (rule5 > -0.33) {
  adop_conclusion5 = "moderate"
} else {
  adop_conclusion5 = "low"
}

cat(paste("rule 5 = ", adop_conclusion5))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, adop_0 = adop_conclusion5)
df_prop <-
  add_row(df_prop,
          ba_1 = "optimal",
          se_1 = "low")


#Rule 6: then adoption likelihood is low

adop_conclusion6 = "low" # always low
cat(paste("rule 6 = ", adop_conclusion6))
cat("\n")

# add to table of conclusions
df_conc <- add_row(df_conc, adop_0 = adop_conclusion6)
df_prop <-
  add_row(df_prop,
          ba_1 = "suboptimal",
          se_1 = "low")

```

```{r i1_rulebases_adoption08, echo=FALSE, results='asis', eval=adop_crit}

cat("This gives the rule base:")

```

<div class="fold o"> 
```{r i1_rulebases_adoption09, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=adop_crit}

# new proposition object is made here
prop <- new("Proposition", table = df_prop)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here

conc <- new("Conclusion", table = df_conc)

# create a rule base
rb_adop_0 <- RuleBase(prop, conc) %>% print()


# in this section there are normally two criteria - b aptitude and se feasibility

# biophysical aptitude is based on five criteria and has a rb (ba_1) and includes Land Use Aptitude, Climatic Aptitude, Soil Physical Properties Aptitude, Soil Fertility Aptitude, Landscape Aptitude (ba_2a, ba_2b, ba_2c, ba_2d, ba_2e)





# se feasibility is based on two criteria and has a rb (se_1) and includes fp feasibility and market access and their two rb (se_2a & se2b).

# fp feasibility is based on two criteria and has a rb (se_2a) and includes management and inputs and their two rb (se_3a & se3b).
# management is based on two criteria: extension and labour their two rb (se_4a & se4b).
# Extension includes two further criteria with rule bases (se_5a & se_5b) each with fuzzy partitions.
# Access to labour is based on two criteria and their two rb (se_5c & se5d) each with fuzzy partitions.

# farm inputs is based on three criteria: access to seeds and land and their two rb (se_4d & se4e) each with fuzzy partitions.
# Access to fertilisers and pesticides has a rb (se_4c) and includes two criteria and their two rb (se_5e & se5f) each with fuzzy partitions.

# market access has a rb (se_2b) and includes three criteria and their three rb (se_3c, se_3d & se3e) each with fuzzy partitions.

# there are eleven fp in total (se_3c, se_3d, se3e, se_4d, se_4e, se_5a, se_5b, se_5c, se5d, se_5e and se_5f)

x <-
  paste(
    "stack(",
    gsub(",$", "", paste0(
      get("rbs_ba_1_list"), sep = ",", collapse = ""
    )),
    ",rb_se_5a,rb_se_5b,rb_se_4a,rb_se_5c,rb_se_5d,rb_se_4b,rb_se_3a,rb_se_5e,rb_se_5f,rb_se_4c,rb_se_4d,rb_se_4e,rb_se_3b,rb_se_2a,rb_se_3c,rb_se_3d,rb_se_3e,rb_se_2b,rb_se_1,rb_adop_0)"
  )

fp_adop_0_list <-
  append(
    fp_ba_1_list,
    "se_3c = fp_se_3c,se_3d = fp_se_3d,se_3e = fp_se_3e,se_4d = fp_se_4d,se_4e = fp_se_4e,se_5a = fp_se_5a,se_5b = fp_se_5b,se_5c = fp_se_5c,se_5d = fp_se_5d,se_5e = fp_se_5e,se_5f = fp_se_5f"
  )


rbs_tmp <-  assign(paste0("rbs_adop_0"), eval(parse(text = x)))

# evaluate the rule base stack

w <-
  paste("predict(",
        "rbs_tmp, newdata = df_irm,",
        gsub(",$", "", paste0(
          get(paste0("fp_adop_0_list")), sep = ",", collapse = ""
        )),
        ")")

fpm_adop_0 <- eval(parse(text = w))


# write the membership values to df_irm and plot the maps of the conclusions

h_col <- getMembership(fpm_adop_0$high)

# add column only if column doesn't already exist in df_irm

if ("adop_0_h" %in% colnames(df_irm)) {
  df_irm <- df_irm  %>% dplyr::select(-(adop_0_h))
  df_irm <- mutate(df_irm, adop_0_h := h_col, .keep = c("all"))
}   else {
  df_irm <- mutate(df_irm, adop_0_h := h_col, .keep = c("all"))
}

if (sef_rb == "hml") {
  # there is a moderate conclusion to se feasibility giving up to six rules and conclusions
  adop_rule_num <- 6
  
  if (adop_conclusion2 == "moderate" |
      adop_conclusion3 == "moderate" |
      adop_conclusion4 == "moderate" |
      adop_conclusion5 == "moderate") {
    m_col <- getMembership(fpm_adop_0$moderate)
    
    # add column only if column doesn't already exist in df_irm
    
    if ("adop_0_m" %in% colnames(df_irm)) {
      df_irm <- df_irm  %>% dplyr::select(-(adop_0_m))
      df_irm <- mutate(df_irm, adop_0_m := m_col, .keep = c("all"))
    }   else {
      df_irm <- mutate(df_irm, adop_0_m := m_col, .keep = c("all"))
    }
    
    adop_rb <- "hml"
  }
  
} else {
  # there is a no moderate conclusion to se feasibility access giving four rules and conclusions
  
  adop_rule_num <- 4
  
  if (adop_conclusion2 == "moderate" |
      adop_conclusion3 == "moderate") {
    m_col <- getMembership(fpm_adop_0$moderate)
    
    # add column only if column doesn't already exist in df_irm
    
    if ("adop_0_m" %in% colnames(df_irm)) {
      df_irm <- df_irm  %>% dplyr::select(-(adop_0_m))
      df_irm <- mutate(df_irm, adop_0_m := m_col, .keep = c("all"))
    }   else {
      df_irm <- mutate(df_irm, adop_0_m := m_col, .keep = c("all"))
    }
    
    adop_rb <- "hml"
  }
}

l_col <- getMembership(fpm_adop_0$low)

# add column only if column doesn't already exist in df_irm

if ("adop_0_l" %in% colnames(df_irm)) {
  df_irm <- df_irm  %>% dplyr::select(-(adop_0_l))
  df_irm <- mutate(df_irm, adop_0_l := l_col, .keep = c("all"))
}   else {
  df_irm <- mutate(df_irm, adop_0_l := l_col, .keep = c("all"))
}

adop_rb <- "hml"


if (adop_rb == "hml") {
  n = 3
  fpm_conc_var <-
    c(
      as.character("adop_0_h"),
      as.character("adop_0_m"),
      as.character("adop_0_l"),
      "x" ,
      "y"
    )
  fpm_conc_name <-
    c(
      as.character("Adoption likelihood high"),
      as.character("Adoption likelihood moderate"),
      as.character("Adoption likelihood low")
    )
} else {
  n = 2
  fpm_conc_var <-
    c(as.character("adop_0_h"),
      as.character("adop_0_l"),
      "x" ,
      "y")
  fpm_conc_name <-
    c(as.character("Adoption likelihood high"),
      as.character("Adoption likelihood low"))
  
}
fpm_plot_title <-
  "Adoption\nLikelihood\n3-class\nmembership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm)
print(plot_fpm)

``` 
</div>



```{r i1_rulebases_adop_export01, echo=FALSE, results='asis', eval=adop_crit}

cat("## Export likelihood for adoption results

")
```

<div class="fold o">
```{r i1_rulebases_adop_export02, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, warning=FALSE, eval=adop_crit}

vect_adop <- vect(df_irm, geom = c("x", "y"), crs = wkt_lam)
output_vect(vect_adop, paste0("adop_", params$INN1))

``` 
</div>

# Classified Results and Validation

The maps below give the classified adoption map, _i.e._, for each raster cell only the class with the maximum membership value is given.



```{r i1_classified_adop_membership_maps01, echo=FALSE, results='asis', eval=adop_crit}

cat("## Classified Map of Likelihood for Adoption")

```

The first map is _without_, the second map  _with_ triangulation points. These points are either high or low, as indicated by the symbols + and - respectively. The colour of the circles behind these symbols refers to the type of adoption, _i.e._, biophysical (b) and/or socio-economic (s). These classes are constructed from the table below:

<div class="fold o"> 
```{r i1_classified_adop_membership_maps02 , cache = TRUE, cache.whatever=params$Agg, warning=FALSE, timeit = TRUE, eval=adop_crit}
# idem + overlay triangulation adoption points

vect_adop_tri <- vect_triangulation %>%
    mutate(
        adopclass = ifelse(grepl(pattern = "high", x = Adoption, ignore.case = TRUE), "high", ifelse(grepl(pattern = "moderate", x = Adoption, ignore.case = TRUE), "moderate", "low")),
        type = NA
    ) %>%
    dplyr::filter(!is.na(Adoption))


vect_adop_tri$type[grepl(pattern = " AE", x = vect_adop_tri$Adoption, ignore.case = TRUE)] <- "b"
vect_adop_tri$type[grepl(pattern = " EA", x = vect_adop_tri$Adoption, ignore.case = TRUE)] <- "b"
vect_adop_tri$type[grepl(pattern = "bio", x = vect_adop_tri$Adoption, ignore.case = TRUE)] <- "b"
vect_adop_tri$type[grepl(pattern = "SE", x = vect_adop_tri$Adoption, ignore.case = TRUE)] <- "s"
vect_adop_tri$type[grepl(pattern = "soil", x = vect_adop_tri$Adoption, ignore.case = TRUE)] <- "b"
vect_adop_tri$type[grepl(pattern = "lowland", x = vect_adop_tri$Adoption, ignore.case = TRUE)] <- "b"
vect_adop_tri$type[grepl(pattern = " temp", x = vect_adop_tri$Adoption, ignore.case = TRUE)] <- "b"
vect_adop_tri$type[grepl(pattern = " elevation", x = vect_adop_tri$Adoption, ignore.case = TRUE)] <- "b"
vect_adop_tri$type[grepl(pattern = "market", x = vect_adop_tri$Adoption, ignore.case = TRUE)] <- "s"
vect_adop_tri$type[grepl(pattern = "rain", x = vect_adop_tri$Adoption, ignore.case = TRUE)] <- "b"
vect_adop_tri$type[grepl(pattern = "SPAM presence", x = vect_adop_tri$Adoption, ignore.case = TRUE)] <- "b"


vect_adop_tri %>%
    dplyr::select(Adoption, adopclass, type) %>%
    (knitr::kable) %>% kable_styling("striped", full_width = F) %>% scroll_box(height = "300px")
``` 
</div>

```{r i1_classified_adop_membership_maps03, echo=FALSE, results='asis', eval=adop_crit}

cat("### Likelihood for Adoption - two or three classes")

```

<div class="fold o"> 
```{r i1_classified_adop_membership_maps04 , cache = TRUE, cache.whatever=params$Agg,  out.width="100%", message=FALSE, warning=FALSE, timeit = TRUE, eval=adop_crit}
# create classified adoption map 

if (params$RES1 != 2) {
  # new method because of df_irm dropped no data
  
  if (adop_rb == "hml") {
    vect_adop_3class <-
      df_irm %>% dplyr::select(adop_0_h, adop_0_m, adop_0_l, x , y) %>% na.omit %>% vect(geom = c("x", "y"))
    rast_adop_3class_h <- rasterize(vect_adop_3class, rast_mask_proj, field = "adop_0_h")
    rast_adop_3class_m <- rasterize(vect_adop_3class, rast_mask_proj, field = "adop_0_m")
    rast_adop_3class_l <- rasterize(vect_adop_3class, rast_mask_proj, field = "adop_0_l")
    rast_adop_3class <- rast(list(rast_adop_3class_h, rast_adop_3class_m, rast_adop_3class_l))
    names(rast_adop_3class) <- c('high', 'moderate', 'low')
    
    # get max value and export
    rast_adop_3class_max <- which.max(rast_adop_3class)
    rast_adop_3class_brick <- rast(list(rast_adop_3class_h, rast_adop_3class_m, rast_adop_3class_l, rast_adop_3class_max))
    names(rast_adop_3class_brick) <- c('high', 'moderate', 'low', 'class')
    output_geotiff(rast_adop_3class_brick, paste0("3class_adop0_", params$INN1))
    
  } else {
    vect_adop_3class <-
      df_irm %>% dplyr::select(adop_h, adop_l, x , y) %>% na.omit %>% vect(geom = c("x", "y"))
    rast_adop_3class_h <- rasterize(vect_adop_3class, rast_mask_proj, field = "adop_0_h")
    rast_adop_3class_l <- rasterize(vect_adop_3class, rast_mask_proj, field = "adop_0_l")
    rast_adop_3class <- rast(list(rast_adop_3class_h, rast_adop_3class_l))
    names(rast_adop_3class) <- c('high', 'low')
    
    # get max value and export
    rast_adop_3class_max <- which.max(rast_adop_3class)
    rast_adop_3class_brick <- rast(list(rast_adop_3class_h, rast_adop_3class_l, rast_adop_3class_max))
    names(rast_adop_3class_brick) <- c('high', 'low', 'class')
    output_geotiff(rast_adop_3class_brick, paste0("3class_adop0_", params$INN1))
    
  }

  df_adop_3class <- rast_adop_3class %>%
    as.data.frame(xy = TRUE) %>%
    na.omit
  m <- df_adop_3class %>% dplyr::select(-x,-y)
  
  df_adop_3class$class <- names(m)[apply(X = m, MARGIN = 1, FUN = which.max)]
  df_adop_3class$class <-
    factor(df_adop_3class$class,
           levels = c("low", "moderate", "high"),
           ordered = TRUE)
  
  g <- ggplot(data = df_adop_3class) +
    geom_raster(mapping = aes(x = x, y = y, fill = class)) +
#    scale_x_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
#    scale_y_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
    scale_fill_manual(
      name = paste0("Likelihood\nfor Adoption\n", params$INN1),
      values = c(
        high = rgb(0, 158, 115, maxColorValue = 255),
        low  = rgb(213,  94,   0, maxColorValue = 255),
        moderate = rgb(230, 159, 0, maxColorValue = 255)
      ),
      drop = FALSE
    ) +
    coord_sf()
  
g2 <- add_subdiv_proj_simple_plot(g)
g2  
} # end RES if statement 08/12/2019

``` 
</div>

<div class="fold o"> 
```{r i1_classified_adop_membership_maps05 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, message  = FALSE, timeit = TRUE, eval=adop_crit}
# create classified adoption map and validation
# 01/03/2019 A FARROW this chunk split because map not appearing

if (params$RES1 != 2) {
  
g2 + 
    geom_spatvector(
        data = vect_adop_tri, 
        mapping = aes(colour = ifelse(adopclass == "high" , "green", "red")), 
        size = 2
    ) +
    geom_spatvector_text(
        data = vect_adop_tri, 
        mapping = aes(label = ifelse(type == "b", "b", "b/s"))
    ) + 
  scale_colour_identity() 

} # end RES if statement 08/12/2019

``` 
</div>

```{r i1_classified_adop_membership_maps06, echo=FALSE, results='asis', eval=adop_crit}

cat("#### Likelihood for Adoption - three classes Leaflet")

```

<div class="fold o"> 
```{r i1_classified_adop_membership_maps07 , cache = TRUE, cache.whatever=params$Agg, warning=FALSE, timeit = TRUE, eval=adop_crit}


if (params$RES1 != 2) {

  # get the polygons showing the layer with the max value in rast_adop_3class_max

  vect_adop_3class_max1 <- as.polygons(rast_adop_3class_max, dissolve=FALSE)

  vect_adop_3class_max1$class <- df_adop_3class$class
  
  # join the polygons with the aptitude points
  vect_adop_3class_max1[["id"]] <- 1:nrow(vect_adop_3class_max1)
  vect_adop[["id"]] <- 1:nrow(vect_adop)
  pinp_m <- relate(vect_adop_3class_max1, vect_adop, "contains", pairs=TRUE)
  df_pinp <- dplyr::as_tibble(pinp_m)
  vect_adop_3class_max2 <- merge(x = vect_adop_3class_max1, y = df_pinp, by.x = "id", by.y = "id.x", all.x = TRUE)
  vect_adop_3class_max2 <- merge(x = vect_adop_3class_max2, y = vect_adop, by.x = "id.y", by.y = "id", all.x = TRUE)
  
   # project to geo for display in leaflet
  vect_adop_3class_max2_geo <- project(vect_adop_3class_max2, "epsg:4326")
  
  # convert to sf until leaflet properly accepts spatvector
  sf_adop_3class_max2_geo <- st_as_sf(vect_adop_3class_max2_geo)
  
  adop_palette <- (c(
    rgb(0, 158, 115, maxColorValue = 255),
    #high
    rgb(230, 159, 0, maxColorValue = 255),
    #low
    rgb(213,  94,   0, maxColorValue = 255)
  )) #moderate
  
  
  pal <-
    colorFactor(adop_palette, domain = c(1:3), na.color = "#808080")
  
  leaflet_widget <- leaflet(sf_adop_3class_max2_geo, width = "100%") %>%
    addProviderTiles(providers$OpenStreetMap.HOT, group = "OSM (HOT)") %>%
    addPolygons(
      label = ~ stringr::str_c('Adoption =', class),
      labelOptions = labelOptions(direction = 'auto'),
      color = "#03F",
      weight = 1,
      opacity = 0.5,
      fill = layer,
      fillColor = ~ pal(which.max),
      fillOpacity = 0.2,
      dashArray = NULL,
      smoothFactor = 1,
      noClip = FALSE,
      popup = paste(
        'Bio Apt optimal  =',
        sf_adop_3class_max2_geo$ba_1_o,
        '<br>',
        'Bio Apt suboptimal =',
        sf_adop_3class_max2_geo$ba_1_s,
        '<br>',
        '<br>',
        'Climate suboptimal  =',
        sf_adop_3class_max2_geo$ba_2b_s,
        '<br>',
        'Soil Fertility suboptimal  =',
        sf_adop_3class_max2_geo$ba_2d_s,
        '<br>',
        'Landscape suboptimal  =',
        sf_adop_3class_max2_geo$ba_2e_s,
        '<br>',
        'Soil Physical suboptimal  =',
        sf_adop_3class_max2_geo$ba_2c_s,
        '<br>',
        'Land Use suboptimal  =',
        sf_adop_3class_max2_geo$ba_2a_s,
        '<br>',
        '<br>',
        'SE Low  =',
        sf_adop_3class_max2_geo$se_1_l,
        '<br>',
        '<br>',
        'Markets Poor  =',
        sf_adop_3class_max2_geo$se_2a_l,
        '<br>',
        'Farm production Low  =',
        sf_adop_3class_max2_geo$se_2b_p,
        '<br>',
        'Management Poor  =',
        sf_adop_3class_max2_geo$se_3a_p,
        '<br>',
        'Farm Input access Poor =',
        sf_adop_3class_max2_geo$se_3b_p
      ),
      popupOptions = NULL,
      highlightOptions = NULL,
    )
  
  frameWidget(leaflet_widget, height = '500')
  
} # end RES if statement 08/12/2019


# reached here 14/09/2023
``` 
</div>

```{r i1_classified_adop_membership_maps_fao01, echo=FALSE, results='asis', eval=adop_crit}

cat("### Classified Map of Likelihood for Adoption - FAO five classes")

```

<div class="fold o"> 
```{r i1_classified_adop_membership_maps_fao02 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, timeit = TRUE, eval=adop_crit }

if (params$RES1 != 2) {

  df_criteria_0 <-
    subset(df_priorities, grepl("^adop_0", df_priorities$rulebase_stack)) # use regular expressions to find criteria
  n_c0 <- nrow(df_criteria_0)
  
  # then determine and print the names of the rule bases in the Likelihood of Adoption theme
  
  cat(paste("\n\n", n_c0, "Likelihood of Adoption rule bases:"))
  for (i in 1:n_c0) {
    cat(paste0(
      "\n",
      df_criteria_0[i, 3],
      " (",
      df_criteria_0[i, 4],
      "):\n Weight = ",
      as.character(df_criteria_0[i, 5]),
      "\n"
    ))
  }
  # new method because of df_irm dropped no data
  
  df_adop_fao <-
    df_irm %>% dplyr::select(paste0(df_criteria_0[1,3],"_o"), paste0(df_criteria_0[2,3],"_o"), x , y) %>% na.omit 
  
  # adoption equals the weighted mean value
  
  expr_adop_fao <- parse(text = paste0("(",df_criteria_0[1,3],"_o * ", df_criteria_0[1,5],") + (", df_criteria_0[2,3],"_o * ", df_criteria_0[2,5],")"))
  
  vect_adop_fao <-
    mutate(df_adop_fao, adop_0_o := eval(expr_adop_fao), .keep = c("all"))  %>% vect(geom = c("x", "y"))
  
  
  rast_adop_fao <- rasterize(vect_adop_fao, rast_mask_proj, field = "adop_0_o")
  names(rast_adop_fao) <- c('FAO')
  
  # classify values and export
  ## from-to-becomes
  # classify the optimal values into five groups
  # all values >= 0 and <= 0.25 become N2, etc.
  m_fao <- c(-Inf, 0.25, 5,
             0.25, 0.4, 4,
             0.4, 0.6, 3,
             0.6, 0.85, 2,
             0.85, Inf, 1)
  rclmat <- matrix(m_fao, ncol = 3, byrow = TRUE)
  rast_adop_fao_bin <- classify(rast_adop_fao, rclmat, include.lowest = TRUE)
  rast_adop_fao_cat <- rast_adop_fao_bin
  df_adop_faocode <- data.frame(id = 1:5, FAO = c("S1", "S2", "S3", "N1", "N2"))
  levels(rast_adop_fao_cat) <- df_adop_faocode
  rast_adop_fao_brick <- rast(list(rast_adop_fao, rast_adop_fao_bin, rast_adop_fao_cat))
  names(rast_adop_fao_brick) <- c('optimal', 'bin', 'FAO')
  output_geotiff(rast_adop_fao_brick, paste0("1faoclass_adop0_", params$INN1))
  
  # export class and optimal value as polygon
  vect_adop_fao_cat <- as.polygons(rast_adop_fao_cat, dissolve = T)
  
  vect_filename <-
    as.character(paste("spatial_data/output/1faoclass_adop0_", params$INN1, ".shp"))
  writeVector(vect_adop_fao_cat, here(vect_filename), overwrite = TRUE)
  
  g <- ggplot() +
    geom_spatraster(data = rast_adop_fao_cat, na.rm = TRUE, aes(fill = FAO)) +
    scale_fill_manual(
    name = paste0("FAO\nAdoption\n", params$INN1),  na.value = "transparent",
    values = c(
      S1 = rgb(51, 160, 44, maxColorValue = 255),
      S2 = rgb(178, 223, 138, maxColorValue = 255),
      S3 = rgb(255, 255, 153, maxColorValue = 255),      
      N1 = rgb(255, 127, 0, maxColorValue = 255),
      N2 = rgb(227, 26, 28, maxColorValue = 255)
    ))
 
  g2 <- add_subdiv_proj_simple_plot(g)
  g2
} # end RES if statement 08/12/2019

``` 
</div>

<div class="fold o"> 
```{r i1_classified_adop_membership_maps_fao03 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, message  = FALSE, timeit = TRUE, eval=adop_crit}
# create classified suitability map and validation
# 01/03/2019 A FARROW this chunk split because map not appearing

if (params$RES1 != 2) {
  
g2 + 
    geom_spatvector(
        data = vect_adop_tri, 
        mapping = aes(colour = ifelse(adopclass == "high" , "green", "red")), 
        size = 2
    ) +
  scale_colour_identity() 

} # end RES if statement 08/12/2019

``` 
</div>

```{r i1_classified_adop_membership_maps_fao04, echo=FALSE, results='asis', eval=adop_crit}

cat("#### Classified Map of Likelihood for Adoption - FAO five classes Leaflet")

```

<div class="fold o"> 
```{r i1_classified_adop_membership_maps_fao05 , cache = TRUE, cache.whatever=params$Agg, warning=FALSE, timeit = TRUE, eval=adop_crit}

if (params$RES1 != 2) {
  
  # convert the spatraster (showing the FAO suitability classes (bin number and class name), and the optimality value) to polygons - do not dissolve
  
  vect_adop_fao_cat2 <- as.polygons(rast_adop_fao_brick, dissolve=FALSE)

  
  # join the polygons (vect_adop_fao_cat2) with the likelihood points (vect_adop_fao)
  
  vect_adop_fao_cat2[["id"]] <- 1:nrow(vect_adop_fao_cat2) # need an id field for p-in-p matrix
  vect_adop[["id"]] <- 1:nrow(vect_adop) # need an id field for p-in-p matrix
  pinp_m <- relate(vect_adop_fao_cat2, vect_adop, "contains", pairs=TRUE) # point in polygon matrix
  df_pinp <- dplyr::as_tibble(pinp_m) # point in polygon tibble
  vect_adop_fao_cat3 <- merge(x = vect_adop_fao_cat2, y = df_pinp, by.x = "id", by.y = "id.x", all.x = TRUE)
  vect_adop_fao_cat4 <- merge(x = vect_adop_fao_cat3, y = vect_adop, by.x = "id.y", by.y = "id", all.x = TRUE)
  
     # project to geo for display in leaflet
  vect_adop_fao_cat4_geo <- project(vect_adop_fao_cat4, "epsg:4326")
  
  # convert to sf until leaflet properly accepts spatvector
  sf_adop_fao_cat4_geo <- st_as_sf(vect_adop_fao_cat4_geo)
  
  
  adop_fao_palette <- (c(
    rgb(51, 160, 44, maxColorValue = 255),#S1
    rgb(178, 223, 138, maxColorValue = 255), #S2
    rgb(255, 255, 153, maxColorValue = 255), #S3
    rgb(255, 127, 0, maxColorValue = 255), #N1
    rgb(227, 26, 28, maxColorValue = 255) #N2
      )) 
  
  pal <-
    colorFactor(adop_fao_palette, domain = c(1:5), na.color = "#808080")
  
  leaflet_widget <- leaflet(sf_adop_fao_cat4_geo, width = "100%") %>%
    addProviderTiles(providers$OpenStreetMap.HOT, group = "OSM (HOT)") %>%
    addPolygons(
      label = ~ stringr::str_c('Likelihood =', FAO),
      labelOptions = labelOptions(direction = 'auto'),
      color = "#03F",
      weight = 1,
      opacity = 0.5,
      fill = T,
      fillColor = ~ pal(bin),
      fillOpacity = 0.2,
      dashArray = NULL,
      smoothFactor = 1,
      noClip = FALSE,
      popup = paste(
        'Adoption FAO Class  =',
        sf_adop_fao_cat4_geo$FAO,
        '<br>',
        '<br>',
        'Adoption optimal  =',
        sf_adop_fao_cat4_geo$optimal,
        '<br>',
        '<br>',
        'Socio-Economic optimal  =',
        sf_adop_fao_cat4_geo$se_1_o,
        '<br>',
        '<br>',
        'Biophysical optimal  =',
        sf_adop_fao_cat4_geo$ba_1_o,
        '<br>',
        '<br>',
        'Climate optimal  =',
        sf_adop_fao_cat4_geo$ba_2b_o,
        '<br>',
        'Soil Fertility optimal  =',
        sf_adop_fao_cat4_geo$ba_2d_o,
        '<br>',
        'Landscape optimal  =',
        sf_adop_fao_cat4_geo$ba_2e_o,
        '<br>',
        'Soil Physical optimal  =',
        sf_adop_fao_cat4_geo$ba_2c_o,
        '<br>',
        'Land Use optimal  =',
        sf_adop_fao_cat4_geo$ba_2a_o
      ),
      popupOptions = NULL,
      highlightOptions = NULL,
    )
  
  frameWidget(leaflet_widget, height = '500')
  
} # end RES if statement 08/12/2019

``` 
</div>


```{r i1_classified_adop_membership_maps_faolimits01, echo=FALSE, results='asis', eval=adop_crit}

cat("### Classified Map of Likelihood for Adoption - FAO limitations classes")

```

<div class="fold o"> 
```{r i1_classified_adop_membership_maps_faolimits02 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, timeit = TRUE, eval=adop_crit }

if (params$RES1 != 2) {
  df_adop_fao <-
    mutate(df_adop_fao, adop_0_o := eval(expr_adop_fao), .keep = c("all"))
  
  df_adop_fao <-
      mutate(df_adop_fao,
             FAO = cut(
               adop_0_o,
               breaks = c(-Inf, 0.25, 0.4, 0.6, 0.8, Inf),
               labels = c("N2", "N1", "S3", "S2", "S1"),
               include.lowest = TRUE
             ))
    
  df_adop_limits <-
    df_irm %>% dplyr::select(ba_2b_s, ba_2c_s, ba_2d_s, ba_2e_s, se_1_s) %>% na.omit
  df_adop_limits$limit <-
    names(df_adop_limits)[][max.col(df_adop_limits[])]
  
  df_adop_faolimits <- cbind(df_adop_fao, df_adop_limits)
  
  df_adop_faolimits <- df_adop_faolimits %>%
    mutate(
      FAO_adop_limit = case_match(
        limit,
        "ba_2b_s" ~ "Cl",
        "ba_2c_s" ~ "SP",
        "ba_2d_s" ~ "SF",
        "ba_2e_s" ~ "Ls",
        "se_1_s" ~ "SE",
        .default = "missing"
      ),
      .keep = "all"
    )
  
  df_adop_faolimits <- df_adop_faolimits %>%
    mutate(FAO_adop_limit2 = case_when(FAO == "S1" ~ "S1", .default = paste0(FAO, "_", FAO_adop_limit)))
  
  df_adop_faolimits_values  <-  df_adop_faolimits %>% select(FAO_adop_limit2) %>% unique()
  df_adop_faolimits_values  <- df_adop_faolimits_values[order(df_adop_faolimits_values$FAO_adop_limit2), ] %>% data.frame
  names(df_adop_faolimits_values) <- c('FAO_adop_limit_code')
  
  df_adop_faolimits_values  <- mutate(df_adop_faolimits_values, ID = row_number()-1)
  df_adop_faolimits_values  <- df_adop_faolimits_values[, c(2,1)] # re-order for later use as raster categories
  
  df_adop_faolimits_code <-
    data.frame(
      "FAO_code_num" = c(1:21),
      "FAO_code_char" = c(
        'S1',
        'S2_SE',
        'S2_Cl',
        'S2_Ls',
        'S2_SF',
        'S2_SP',
        'S3_SE',
        'S3_Cl',
        'S3_Ls',
        'S3_SF',
        'S3_SP',
        'N1_SE',
        'N1_Cl',
        'N1_Ls',
        'N1_SF',
        'N1_SP',
        'N2_SE',
        'N2_Cl',
        'N2_Ls',
        'N2_SF',
        'N2_SP'
      )
    )
  
  vect_adop_faolimits  <- vect(df_adop_faolimits, geom = c("x", "y"))
    
  rast_adop_faolimits <- rasterize(vect_adop_faolimits, rast_mask_proj, field = "FAO_adop_limit2")
  names(rast_adop_faolimits) <- c('FAO_adop_limit_code')
  levels(rast_adop_faolimits) <- df_adop_faolimits_values
  
  vect_adop_faolimits <-    merge(
    x = vect_adop_faolimits,
    y = df_adop_faolimits_code,
    by.x = "FAO_adop_limit2",
    by.y = "FAO_code_char",
    all.x = TRUE
  )
  
  rast_adop_faolimits_bin <-
    rasterize(vect_adop_faolimits, rast_mask_proj, field = "FAO_code_num")
  
  rast_adop_0_o <-
    rasterize(vect_adop_faolimits, rast_mask_proj, field = "adop_0_o")
  
  rast_adop_faolimits_brick <- rast(list(rast_adop_0_o, rast_adop_faolimits,rast_adop_faolimits_bin))
  
  names(rast_adop_faolimits_brick) <- c('optimal', 'FAO_adop_limits', 'bin')
  output_geotiff(rast_adop_faolimits_brick, paste0("FAO_adop_limits_adop0_", params$INN1))
  
  # export class and optimal value as polygon
  vect_adop_faolimits_cat <- as.polygons(rast_adop_faolimits_brick, dissolve = T)
  
  vect_filename <-
    as.character(paste("spatial_data/output/FAO_adop_limits_adop0_", params$INN1, ".shp"))
  writeVector(vect_adop_faolimits_cat, here(vect_filename), overwrite = TRUE)
  
  g <- ggplot() +
    geom_spatraster(data = rast_adop_faolimits, na.rm = TRUE, aes(fill = FAO_adop_limit_code)) +
    scale_fill_manual(
    name = paste0("FAO\nlimitations\nAdoption\n", params$INN1),  na.value = "transparent",
        breaks = c('S1','S2_SE','S2_Cl','S2_Ls','S2_SF','S3_SE','S2_SP','S3_Cl','S3_Ls','S3_SF',
      'S3_SP','N1_SE','N1_Cl','N1_Ls','N1_SF','N1_SP','N2_SE','N2_Cl','N2_Ls','N2_SF','N2_SP'),
    values = c(
      S1 = rgb(0,102,0, maxColorValue = 255),
      S2_SE = rgb(150,255,127, maxColorValue = 255),
      S2_Cl = rgb(24,252,0, maxColorValue = 255),
      S2_Ls = rgb(60,179,113, maxColorValue = 255),
      S2_SF = rgb(50,205,50, maxColorValue = 255),
      S2_SP = rgb(34,139,34, maxColorValue = 255),
      S3_SE = rgb(255, 255, 0, maxColorValue = 255),
      S3_Cl = rgb(245, 206, 51, maxColorValue = 255),
      S3_Ls = rgb(247, 218, 102, maxColorValue = 255),
      S3_SF = rgb(250, 231, 153, maxColorValue = 255),
      S3_SP = rgb(252, 243, 204, maxColorValue = 255),
      N1_SE = rgb(255, 79, 0, maxColorValue = 255),
      N1_Cl = rgb(255, 127, 0, maxColorValue = 255),
      N1_Ls = rgb(255, 168, 54, maxColorValue = 255),
      N1_SF = rgb(255, 87, 40, maxColorValue = 255),
      N1_SP = rgb(255, 187, 60, maxColorValue = 255),
      N2_SE = rgb(124, 10, 2, maxColorValue = 255),
      N2_Cl = rgb(234, 60, 83, maxColorValue = 255),
      N2_Ls = rgb(180, 55, 87, maxColorValue = 255),
      N2_SF = rgb(66, 13, 9, maxColorValue = 255),
      N2_SP = rgb(240, 128, 128, maxColorValue = 255)
    ))
 
  g2 <- add_subdiv_proj_simple_plot(g)
  g2
} # end RES if statement 08/12/2019

``` 
</div>

<div class="fold o"> 
```{r i1_classified_adop_membership_maps_faolimits03 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, message  = FALSE, timeit = TRUE, eval=adop_crit}
# create classified suitability map and validation
# 01/03/2019 A FARROW this chunk split because map not appearing

if (params$RES1 != 2) {
  
g2 + 
    geom_spatvector(
        data = vect_adop_tri, 
        mapping = aes(colour = ifelse(adopclass == "high" , "green", "red")), 
        size = 2
    ) +
  scale_colour_identity() 

} # end RES if statement 08/12/2019

``` 
</div>

```{r i1_classified_adop_membership_maps_faolimits04, echo=FALSE, results='asis', eval=adop_crit}

cat("#### Classified Map of Likelihood for Adoption - FAO limitations classes Leaflet")

```

<div class="fold o"> 
```{r i1_classified_adop_membership_maps_faolimits05 , cache = TRUE, cache.whatever=params$Agg, warning=FALSE, timeit = TRUE, eval=adop_crit}

if (params$RES1 != 2) {
  
  # convert the spatraster (showing the FAO suitability classes (bin number and class name), and the optimality value) to polygons - do not dissolve
  
  vect_adop_faolimits_cat2 <- as.polygons(rast_adop_faolimits_brick, dissolve=FALSE)

  
  # join the polygons (vect_adop_faolimits_cat2) with the likelihood points (vect_adop_faolimits)
  
  vect_adop_faolimits_cat2[["id"]] <- 1:nrow(vect_adop_faolimits_cat2) # need an id field for p-in-p matrix
  vect_adop[["id"]] <- 1:nrow(vect_adop) # need an id field for p-in-p matrix
  pinp_m <- relate(vect_adop_faolimits_cat2, vect_adop, "contains", pairs=TRUE) # point in polygon matrix
  df_pinp <- dplyr::as_tibble(pinp_m) # point in polygon tibble
  vect_adop_faolimits_cat3 <- merge(x = vect_adop_faolimits_cat2, y = df_pinp, by.x = "id", by.y = "id.x", all.x = TRUE)
  vect_adop_faolimits_cat4 <- merge(x = vect_adop_faolimits_cat3, y = vect_adop, by.x = "id.y", by.y = "id", all.x = TRUE)
  
     # project to geo for display in leaflet
  vect_adop_faolimits_cat4_geo <- project(vect_adop_faolimits_cat4, "epsg:4326")
  
  # convert to sf until leaflet properly accepts spatvector
  sf_adop_faolimits_cat4_geo <- st_as_sf(vect_adop_faolimits_cat4_geo)
  
  
  adop_faolimits_palette <- ( c(
      rgb(0,102,0, maxColorValue = 255),       #S1  
      rgb(150,255,127, maxColorValue = 255),   #S2_SE  
      rgb(24,252,0, maxColorValue = 255),      #S2_Cl  
      rgb(60,179,113, maxColorValue = 255),    #S2_Ls  
      rgb(50,205,50, maxColorValue = 255),     #S2_SF  
      rgb(34,139,34, maxColorValue = 255),     #S2_SP  
      rgb(255, 255, 0, maxColorValue = 255),   #S3_SE 
      rgb(245, 206, 51, maxColorValue = 255),  #S3_Cl 
      rgb(247, 218, 102, maxColorValue = 255), #S3_Ls  
      rgb(250, 231, 153, maxColorValue = 255), #S3_SF  
      rgb(252, 243, 204, maxColorValue = 255), #S3_SP  
      rgb(255, 79, 0, maxColorValue = 255),    #N1_SE  
      rgb(255, 127, 0, maxColorValue = 255),   #N1_Cl  
      rgb(255, 168, 54, maxColorValue = 255),  #N1_Ls  
      rgb(255, 87, 40, maxColorValue = 255),   #N1_SF  
      rgb(255, 187, 60, maxColorValue = 255),  #N1_SP 
      rgb(124, 10, 2, maxColorValue = 255),    #N2_SE  
      rgb(234, 60, 83, maxColorValue = 255),   #N2_Cl  
      rgb(180, 55, 87, maxColorValue = 255),   #N2_Ls  
      rgb(66, 13, 9, maxColorValue = 255),     #N2_SF  
      rgb(240, 128, 128, maxColorValue = 255)  #N2_SP  
    )) 

  pal <-
    colorFactor(adop_faolimits_palette, domain = c(1:21), na.color = "#808080")
  
  leaflet_widget <- leaflet(sf_adop_faolimits_cat4_geo, width = "100%") %>%
    addProviderTiles(providers$OpenStreetMap.HOT, group = "OSM (HOT)") %>%
    addPolygons(
      label = ~ stringr::str_c('Likelihood =', FAO_adop_limits),
      labelOptions = labelOptions(direction = 'auto'),
      color = "#03F",
      weight = 1,
      opacity = 0.5,
      fill = T,
      fillColor = ~ pal(bin),
      fillOpacity = 0.2,
      dashArray = NULL,
      smoothFactor = 1,
      noClip = FALSE,
      popup = paste(
        'Adoption FAO Class  =',
        sf_adop_faolimits_cat4_geo$FAO,
        '<br>',
        '<br>',
        'Adoption optimal  =',
        sf_adop_faolimits_cat4_geo$optimal,
        '<br>',
        '<br>',
        'Socio-Economic optimal  =',
        sf_adop_faolimits_cat4_geo$se_1_o,
        '<br>',
        '<br>',
        'Biophysical optimal  =',
        sf_adop_faolimits_cat4_geo$ba_1_o,
        '<br>',
        '<br>',
        'Climate optimal  =',
        sf_adop_faolimits_cat4_geo$ba_2b_o,
        '<br>',
        'Soil Fertility optimal  =',
        sf_adop_faolimits_cat4_geo$ba_2d_o,
        '<br>',
        'Landscape optimal  =',
        sf_adop_faolimits_cat4_geo$ba_2e_o,
        '<br>',
        'Soil Physical optimal  =',
        sf_adop_faolimits_cat4_geo$ba_2c_o,
        '<br>',
        'Land Use optimal  =',
        sf_adop_faolimits_cat4_geo$ba_2a_o
      ),
      popupOptions = NULL,
      highlightOptions = NULL,
    )
  
  frameWidget(leaflet_widget, height = '500')
  
} # end RES if statement 08/12/2019

``` 
</div>



```{r i1_classified_ba_membership_maps01, echo=FALSE, results='asis', eval=ba_crit}

cat("## Classified Map of Biophysical Aptitude")

```

The first map is _without_, the second map  _with_ triangulation points. These points are either high or low, as indicated by the symbols + and - respectively. The colour of the circles behind these symbols refers to the type of adoption, _i.e._, biophysical (b) and/or socio-economic (s). These classes are constructed from the table below:

<div class="fold o"> 
```{r i1_classified_ba_membership_maps02 , cache = TRUE, cache.whatever=params$Agg, warning=FALSE, timeit = TRUE, eval=ba_crit}

# idem + overlay triangulation aptitude points

vect_ba_tri <- vect_triangulation %>%
    mutate(
        baclass = ifelse(grepl(pattern = "suboptimal", x = eval(parse(text = params$TRI1)), ignore.case = TRUE), "suboptimal", ifelse(grepl(pattern = "optimal", x = eval(parse(text = params$TRI1)), ignore.case = TRUE), "optimal", "other"))#,
        #type = NA  #a Farrow commented out 26/09/2023
    ) %>%
    dplyr::filter(!is.na(params$TRI1))


mutate(df_onset, !!as.character(paste0(period_name,"_l")) :=  eval(parse(text = paste0("df_growth_stages_lengths3$", period_name))), .keep = c("all"))


vect_ba_tri$type[grepl(pattern = " AE", x = paste0("vect_ba_tri$",params$TRI1), ignore.case = TRUE)] <- "b"
vect_ba_tri$type[grepl(pattern = " EA", x = paste0("vect_ba_tri$",params$TRI1), ignore.case = TRUE)] <- "b"
vect_ba_tri$type[grepl(pattern = "bio", x = paste0("vect_ba_tri$",params$TRI1), ignore.case = TRUE)] <- "b"
vect_ba_tri$type[grepl(pattern = "SE", x = paste0("vect_ba_tri$",params$TRI1), ignore.case = TRUE)] <- "s"
vect_ba_tri$type[grepl(pattern = "soil", x = paste0("vect_ba_tri$",params$TRI1), ignore.case = TRUE)] <- "b"
vect_ba_tri$type[grepl(pattern = "lowland", x = paste0("vect_ba_tri$",params$TRI1), ignore.case = TRUE)] <- "b"
vect_ba_tri$type[grepl(pattern = " temp", x = paste0("vect_ba_tri$",params$TRI1), ignore.case = TRUE)] <- "b"
vect_ba_tri$type[grepl(pattern = " elevation", x = paste0("vect_ba_tri$",params$TRI1), ignore.case = TRUE)] <- "b"
vect_ba_tri$type[grepl(pattern = "market", x = paste0("vect_ba_tri$",params$TRI1), ignore.case = TRUE)] <- "s"
vect_ba_tri$type[grepl(pattern = "rain", x = paste0("vect_ba_tri$",params$TRI1), ignore.case = TRUE)] <- "b"
vect_ba_tri$type[grepl(pattern = "SPAM presence", x = paste0("vect_ba_tri$",params$TRI1), ignore.case = TRUE)] <- "b"

vect_ba_tri %>%
    dplyr::select(params$TRI1, baclass, type) %>%
    (knitr::kable) %>% kable_styling("striped", full_width = F) %>% scroll_box(height = "300px")

```
</div>


```{r i1_classified_ba_membership_maps_CRASA01, echo=FALSE, results='asis', eval=ba_crit}

cat("### Biophysical Aptitude - one class (CRASA)")

```

<div class="fold o"> 
```{r i1_classified_ba_membership_maps_CRASA02 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, timeit = TRUE, eval=ba_crit}
# create classified aptitude map 

if (params$RES1 != 2) {
  # new method because of df_irm dropped no data
  
  vect_ba_1class <-
    df_irm %>% dplyr::select(ba_1_o, x , y) %>% na.omit %>% vect(geom = c("x", "y"))
  rast_ba_1class_o <- rasterize(vect_ba_1class, rast_mask_proj, field = "ba_1_o")
  rast_ba_1class_bin <- classify(rast_ba_1class_o, matrix(c(-0.5, 0, 0, 0, 1, 3),
        ncol = 3,
        byrow = TRUE)
      )
  names(rast_ba_1class_bin) <- c('optimal')
  
  output_geotiff(rast_ba_1class_bin, paste0("1class_ba1_", params$INN1))

  # export class as polygon
  vect_ba_1class_bin <- as.polygons(rast_ba_1class_bin, dissolve = T)
  
  vect_filename <-
    as.character(paste("spatial_data/output/1class_ba1_", params$INN1, ".shp"))
  writeVector(vect_ba_1class_bin, here(vect_filename), overwrite = TRUE)
  
  
  df_ba_1class_bin <- rast_ba_1class_bin %>%
    as.data.frame(xy = TRUE) %>%
    na.omit
  df_ba_1class_bin_o <- df_ba_1class_bin %>% dplyr::select(-x,-y)
  
 
# project to geo for display in leaflet
  vect_ba_1class_bin_geo <- terra::project(vect_ba_1class_bin, "epsg:4326")
  
  
## for CRASA sourcing pipeline  
  
# for the sourcing pipeline need only a raster of the potential crop areas, with non-N zones having a value of 1

# reclassify rast_ba_1class_bin 
  
v_1class <- c(0, 0.5, 1,
       0.5, 1, 3, NA, NA, 0)
m_1class <- matrix(v_1class, ncol=3, byrow=TRUE)
rast_ba_1class_rcl <- classify(rast_ba_1class_bin$optimal, m_1class, include.lowest=TRUE)
  
rast_ba_1class_rcl_geo <- terra::project(rast_ba_1class_rcl, "epsg:4326", method = "near")

rast_filename <-
  as.character(paste("spatial_data/output/rast_", params$INN1,"_pot-N.tif"))
writeRaster(rast_ba_1class_rcl_geo, here(rast_filename), overwrite=TRUE)

#plot(dB_ba_rcl_geo, main = paste0("Not sub-optimal ", params$INN1," 4 CRASA pipeline"))

levels(rast_ba_1class_rcl_geo) <- data.frame(id = c(0, 1, 3), opt = c("No Cropland", "Unsuitable", "Suitable"))

cols <- c("No Cropland" = NA, "Unsuitable" = "red", "Suitable" = "darkgreen")

g <-  ggplot() +
      geom_spatraster(data = rast_ba_1class_rcl_geo, aes(fill = opt), alpha = 1) +
      geom_spatvector(
        data = unwrap(vect_subdiv),
        fill = NA,
        col = 'black',
        na.rm = TRUE,
        inherit.aes = FALSE
      )  +
      scale_fill_manual(
        values = cols,
        na.translate = F
      ) +
      xlim ((ext(unwrap(vect_subdiv))[1] ), (ext(unwrap(vect_subdiv))[2]) ) +
      ylim ((ext(unwrap(vect_subdiv))[3] ), (ext(unwrap(vect_subdiv))[4]) ) +
      labs(
        fill = paste0(
          "--------------------\nSuitability for\n",
          params$INN1,
          "\n",
          "\n--------------------"
        )
      ) +
      theme(
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank()
      ) +
      coord_sf(expand = FALSE)

g

} # end RES if statement 08/12/2019
``` 
</div>


```{r i1_classified_ba_membership_maps_CRASA03, echo=FALSE, results='asis', eval=ba_crit}

cat("#### Biophysical Aptitude - one class (CRASA) Leaflet")

```


<div class="fold o"> 
```{r i1_classified_ba_membership_maps_CRASA04 , cache = TRUE, cache.whatever=params$Agg, warning=FALSE, timeit = TRUE, eval=ba_crit}


if (params$RES1 != 2) {
  # convert to sf until leaflet properly accepts spatvector
  sf_ba_1class_bin_geo <- st_as_sf(vect_ba_1class_bin_geo)
  
  
  ba_1class_palette <- (c("red", #Unsuitable
                         NA, #No Cropland
                         NA, #No Value
                         "darkgreen")) #Suitable
  
  pal <-
    colorFactor(ba_1class_palette,
                domain = c(0:3),
                na.color = "#808080")
  
  leaflet_widget <- leaflet(sf_ba_1class_bin_geo, width = "100%") %>%
    addProviderTiles(providers$OpenStreetMap.HOT, group = "OSM (HOT)") %>%
    addPolygons(
      label = ~ stringr::str_c('Aptitude =', optimal),
      labelOptions = labelOptions(direction = 'auto'),
      color = "#03F",
      weight = 1,
      opacity = 0.5,
      fillColor = ~ pal(optimal),
      fillOpacity = 0.2,
      dashArray = NULL,
      smoothFactor = 1,
      noClip = FALSE,
      popupOptions = NULL,
      highlightOptions = NULL,
    )
  
  frameWidget(leaflet_widget, height = '500')
  
} # end RES if statement 08/12/2019


``` 
</div>

```{r i1_classified_ba_membership_maps_opt01, echo=FALSE, results='asis', eval=ba_crit}

cat("### Biophysical Aptitude - two classes")

```

<div class="fold o"> 
```{r i1_classified_ba_membership_maps_opt02 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, timeit = TRUE, eval=ba_crit}
# create classified aptitude map 

if (params$RES1 != 2) {
  # new method because of df_irm dropped no data
  
  vect_ba_2class <-
    df_irm %>% dplyr::select(ba_1_o, ba_1_s, x , y) %>% na.omit %>% vect(geom = c("x", "y"))
  rast_ba_2class_o <- rasterize(vect_ba_2class, rast_mask_proj, field = "ba_1_o")
  rast_ba_2class_s <- rasterize(vect_ba_2class, rast_mask_proj, field = "ba_1_s")
  rast_ba_2class <- rast(list(rast_ba_2class_o, rast_ba_2class_s))
  names(rast_ba_2class) <- c('optimal', 'suboptimal')
  
  # get max value and export
  rast_ba_2class_max <- which.max(rast_ba_2class)
  rast_ba_2class_brick <- rast(list(rast_ba_2class_o, rast_ba_2class_s, rast_ba_2class_max))
  names(rast_ba_2class_brick) <- c('optimal', 'suboptimal', 'class')
  output_geotiff(rast_ba_2class_brick, paste0("2class_ba1_", params$INN1))
  
  # export class as polygon
  vect_ba_2class_max <- as.polygons(rast_ba_2class_max, dissolve = T)
  
    vect_filename <-
    as.character(paste("spatial_data/output/2class_ba1_", params$INN1, ".shp"))
  writeVector(vect_ba_2class_max, here(vect_filename), overwrite = TRUE)
  
  
  df_ba_2class <- rast_ba_2class %>%
    as.data.frame(xy = TRUE) %>%
    na.omit
  m <- df_ba_2class %>% dplyr::select(-x,-y)
  
  df_ba_2class$class <- names(m)[apply(X = m, MARGIN = 1, FUN = which.max)]
  df_ba_2class$class <-
    factor(df_ba_2class$class,
           levels = c("optimal", "suboptimal"),
           ordered = TRUE)
  
  g <- ggplot(data = df_ba_2class) +
    geom_raster(mapping = aes(x = x, y = y, fill = class)) +
    #    scale_x_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
#    scale_y_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
    scale_fill_manual(
      name = paste0("Biophysical\nAptitude\n", params$INN1),
      values = c(
        optimal = rgb(0, 158, 115, maxColorValue = 255),
        suboptimal  = rgb(213,  94,   0, maxColorValue = 255)
      ),
      drop = FALSE
    ) +
    coord_sf()
  

  g2 <- add_subdiv_proj_simple_plot(g)
  g2
} # end RES if statement 08/12/2019

``` 
</div>

<div class="fold o"> 
```{r i1_classified_ba_membership_maps_opt03 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, message  = FALSE, timeit = TRUE, eval=ba_crit}
# create classified suitability map and validation
# 01/03/2019 A FARROW this chunk split because map not appearing

if (params$RES1 != 2) {
  
g2 + 
    geom_spatvector(
        data = vect_ba_tri, 
        mapping = aes(colour = ifelse(baclass == "optimal" , "green", "red")), 
        size = 2
    ) +
    geom_spatvector_text(
        data = vect_ba_tri, 
        mapping = aes(label = ifelse(type == "b", "b", "b/s"))
    ) + 
  scale_colour_identity() 

} # end RES if statement 08/12/2019

``` 
</div>

```{r i1_classified_ba_membership_maps_opt04, echo=FALSE, results='asis', eval=ba_crit}

cat("#### Biophysical Aptitude - two classes Leaflet")

```

<div class="fold o"> 
```{r i1_classified_ba_membership_maps_opt05 , cache = TRUE, cache.whatever=params$Agg, warning=FALSE, timeit = TRUE, eval=ba_crit}

if (params$RES1 != 2) {
  
  # get the polygons showing the layer with the max value in rast_ba_2class

  vect_ba_2class_max1 <- as.polygons(rast_ba_2class_max, dissolve=FALSE)
  vect_ba_2class_max1$class <- df_ba_2class$class
  
  # join the polygons with the aptitude points
  vect_ba_2class_max1[["id"]] <- 1:nrow(vect_ba_2class_max1)
  vect_apt[["id"]] <- 1:nrow(vect_apt)
  pinp_m <- relate(vect_ba_2class_max1, vect_apt, "contains", pairs=TRUE)
  df_pinp <- dplyr::as_tibble(pinp_m)
  vect_ba_2class_max2 <- merge(x = vect_ba_2class_max1, y = df_pinp, by.x = "id", by.y = "id.x", all.x = TRUE)
  vect_ba_2class_max2 <- merge(x = vect_ba_2class_max2, y = vect_apt, by.x = "id.y", by.y = "id", all.x = TRUE)
  
     # project to geo for display in leaflet
  vect_ba_2class_max2_geo <- project(vect_ba_2class_max2, "epsg:4326")
  
  # convert to sf until leaflet properly accepts spatvector
  sf_ba_2class_max2_geo <- st_as_sf(vect_ba_2class_max2_geo)
  
  
  ba_2class_palette <- (c(
    rgb(0, 158, 115, maxColorValue = 255),
    #optimal
    rgb(230, 159, 0, maxColorValue = 255)
  )) #suboptimal
  
  pal <-
    colorFactor(ba_2class_palette, domain = c(1:2), na.color = "#808080")
  
  leaflet_widget <- leaflet(sf_ba_2class_max2_geo, width = "100%") %>%
    addProviderTiles(providers$OpenStreetMap.HOT, group = "OSM (HOT)") %>%
    addPolygons(
      label = ~ stringr::str_c('Aptitude =', class),
      labelOptions = labelOptions(direction = 'auto'),
      color = "#03F",
      weight = 1,
      opacity = 0.5,
      fill = which.max,
      fillColor = ~ pal(which.max),
      fillOpacity = 0.2,
      dashArray = NULL,
      smoothFactor = 1,
      noClip = FALSE,
      popup = paste(
        'Bio Apt optimal  =',
        sf_ba_2class_max2_geo$ba_1_o,
        '<br>',
        'Bio Apt suboptimal =',
        sf_ba_2class_max2_geo$ba_1_s,
        '<br>',
        '<br>',
        'Climate suboptimal  =',
        sf_ba_2class_max2_geo$ba_2b_s,
        '<br>',
        'Soil Fertility suboptimal  =',
        sf_ba_2class_max2_geo$ba_2d_s,
        '<br>',
        'Landscape suboptimal  =',
        sf_ba_2class_max2_geo$ba_2e_s,
        '<br>',
        'Soil Physical suboptimal  =',
        sf_ba_2class_max2_geo$ba_2c_s,
        '<br>',
        'Land Use suboptimal  =',
        sf_ba_2class_max2_geo$ba_2a_s
      ),
      popupOptions = NULL,
      highlightOptions = NULL,
    )
  
  frameWidget(leaflet_widget, height = '500')
  
} # end RES if statement 08/12/2019

``` 
</div>

```{r i1_classified_ba_membership_maps_fao01, echo=FALSE, results='asis', eval=ba_crit}

cat("### Biophysical Aptitude - FAO five classes classes")

```

<div class="fold o"> 
```{r i1_classified_ba_membership_maps_fao02 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, timeit = TRUE, eval=ba_crit}
# create classified aptitude map 

if (params$RES1 != 2) {
  # new method because of df_irm dropped no data
  
  vect_ba_fao <-
    df_irm %>% dplyr::select(ba_1_o, x , y) %>% na.omit %>% vect(geom = c("x", "y"))
  rast_ba_fao <- rasterize(vect_ba_fao, rast_mask_proj, field = "ba_1_o")
  names(rast_ba_fao) <- c('FAO')
  
  # classify values and export
  ## from-to-becomes
  # classify the optimal values into five groups
  # all values >= 0 and <= 0.25 become N2, etc.
  v_ba_fao <- c(-Inf, 0.25, 5,
             0.25, 0.4, 4,
             0.4, 0.6, 3,
             0.6, 0.85, 2,
             0.85, Inf, 1)
  m_ba_fao <- matrix(v_ba_fao, ncol = 3, byrow = TRUE)
  rast_ba_fao_bin <- classify(rast_ba_fao, m_ba_fao, include.lowest = TRUE)
  rast_ba_fao_cat <- rast_ba_fao_bin
  df_ba_fao <- data.frame(id = 1:5, FAO = c("S1", "S2", "S3", "N1", "N2"))
  levels(rast_ba_fao_cat) <- df_ba_fao
  rast_ba_fao_brick <- rast(list(rast_ba_fao, rast_ba_fao_bin, rast_ba_fao_cat))
  names(rast_ba_fao_brick) <- c('optimal', 'bin', 'FAO')
  output_geotiff(rast_ba_fao_brick, paste0("1class_ba1_", params$INN1))
  
  # export class and optimal value as polygon
  vect_ba_fao_cat <- as.polygons(rast_ba_fao_cat, dissolve = T)
  
  vect_filename <-
    as.character(paste("spatial_data/output/1class_ba1_", params$INN1, ".shp"))
  writeVector(vect_ba_fao_cat, here(vect_filename), overwrite = TRUE)
  
  g <- ggplot() +
    geom_spatraster(data = rast_ba_fao_cat, na.rm = TRUE, aes(fill = FAO)) +
    scale_fill_manual(
    name = paste0("FAO\nsuitability\n", params$INN1),  na.value = "transparent",
    values = c(
      S1 = rgb(51, 160, 44, maxColorValue = 255),
      S2 = rgb(178, 223, 138, maxColorValue = 255),
      S3 = rgb(255, 255, 153, maxColorValue = 255),      
      N1 = rgb(255, 127, 0, maxColorValue = 255),
      N2 = rgb(227, 26, 28, maxColorValue = 255)
    ))
 
  g2 <- add_subdiv_proj_simple_plot(g)
  g2
} # end RES if statement 08/12/2019

``` 
</div>

<div class="fold o"> 
```{r i1_classified_ba_membership_maps_fao03 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, message  = FALSE, timeit = TRUE, eval=ba_crit}
# create classified suitability map and validation
# 01/03/2019 A FARROW this chunk split because map not appearing

if (params$RES1 != 2) {
  
g2 + 
    geom_spatvector(
        data = vect_ba_tri, 
        mapping = aes(colour = ifelse(baclass == "optimal" , "green", "red")), 
        size = 1, shape = 21
    ) +
    #geom_spatvector_text(
    #    data = vect_ba_tri, 
    #    mapping = aes(label = ifelse(type == "b", "b", "b/s"))
    #) + 
  scale_colour_identity() 

} # end RES if statement 08/12/2019

``` 
</div>

```{r i1_classified_ba_membership_maps_fao04, echo=FALSE, results='asis', eval=ba_crit}

cat("#### Biophysical Aptitude - FAO five classes Leaflet")

```

<div class="fold o"> 
```{r i1_classified_ba_membership_maps_fao05 , cache = TRUE, cache.whatever=params$Agg, warning=FALSE, timeit = TRUE, eval=ba_crit}

if (params$RES1 != 2) {
  
  # convert the spatraster (showing the FAO suitability classes (bin number and class name), and the optimality value) to polygons - do not dissolve
  
  vect_ba_fao_cat2 <- as.polygons(rast_ba_fao_brick, dissolve=FALSE)

  
  # join the polygons (vect_ba_fao_cat2) with the aptitude points (vect_apt)
  
  vect_ba_fao_cat2[["id"]] <- 1:nrow(vect_ba_fao_cat2) # need an id field for p-in-p matrix
  vect_apt[["id"]] <- 1:nrow(vect_apt) # need an id field for p-in-p matrix
  pinp_m <- relate(vect_ba_fao_cat2, vect_apt, "contains", pairs=TRUE) # point in polygon matrix
  df_pinp <- dplyr::as_tibble(pinp_m) # point in polygon tibble
  vect_ba_fao_cat3 <- merge(x = vect_ba_fao_cat2, y = df_pinp, by.x = "id", by.y = "id.x", all.x = TRUE)
  vect_ba_fao_cat4 <- merge(x = vect_ba_fao_cat3, y = vect_apt, by.x = "id.y", by.y = "id", all.x = TRUE)
  
     # project to geo for display in leaflet
  vect_ba_fao_cat4_geo <- project(vect_ba_fao_cat4, "epsg:4326")
  
  # convert to sf until leaflet properly accepts spatvector
  sf_ba_fao_cat4_geo <- st_as_sf(vect_ba_fao_cat4_geo)
  
  
  ba_fao_palette <- (c(
    rgb(51, 160, 44, maxColorValue = 255),#S1
    rgb(178, 223, 138, maxColorValue = 255), #S2
    rgb(255, 255, 153, maxColorValue = 255), #S3
    rgb(255, 127, 0, maxColorValue = 255), #N1
    rgb(227, 26, 28, maxColorValue = 255) #N2
      )) 
  
  pal <-
    colorFactor(ba_fao_palette, domain = c(1:5), na.color = "#808080")
  
  leaflet_widget <- leaflet(sf_ba_fao_cat4_geo, width = "100%") %>%
    addProviderTiles(providers$OpenStreetMap.HOT, group = "OSM (HOT)") %>%
    addPolygons(
      label = ~ stringr::str_c('Aptitude =', FAO),
      labelOptions = labelOptions(direction = 'auto'),
      color = "#03F",
      weight = 1,
      opacity = 0.5,
      fill = T,
      fillColor = ~ pal(bin),
      fillOpacity = 0.2,
      dashArray = NULL,
      smoothFactor = 1,
      noClip = FALSE,
      popup = paste(
        'Bio Apt FAO Class  =',
        sf_ba_fao_cat4_geo$FAO,
        '<br>',
        '<br>',
        'Bio Apt optimal  =',
        sf_ba_fao_cat4_geo$ba_1_o,
        '<br>',
        '<br>',
        'Climate optimal  =',
        sf_ba_fao_cat4_geo$ba_2b_o,
        '<br>',
        'Soil Fertility optimal  =',
        sf_ba_fao_cat4_geo$ba_2d_o,
        '<br>',
        'Landscape optimal  =',
        sf_ba_fao_cat4_geo$ba_2e_o,
        '<br>',
        'Soil Physical optimal  =',
        sf_ba_fao_cat4_geo$ba_2c_o,
        '<br>',
        'Land Use optimal  =',
        sf_ba_fao_cat4_geo$ba_2a_o
      ),
      popupOptions = NULL,
      highlightOptions = NULL,
    )
  
  frameWidget(leaflet_widget, height = '500')
  
} # end RES if statement 08/12/2019

``` 
</div>


```{r i1_classified_ba_membership_maps_faolimits01, echo=FALSE, results='asis', eval=ba_crit}

cat("### Biophysical Aptitude - FAO limitations classes")

```

<div class="fold o"> 
```{r i1_classified_ba_membership_maps_faolimits02 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, timeit = TRUE, eval=ba_crit}
# create classified aptitude map 

if (params$RES1 != 2) {
  # new method because of df_irm dropped no data
  
  df_df_irm_ba_fao <-
    df_irm %>% dplyr::select(x, y, ba_1_o) %>% na.omit %>% mutate(FAO = cut(
      ba_1_o,
      breaks = c(-Inf, 0.25, 0.4, 0.6, 0.8, Inf),
      labels = c("N2", "N1", "S3", "S2", "S1"),
      include.lowest = TRUE
    ))

  df_faolimits <-
    df_irm %>% dplyr::select(ba_2b_s, ba_2c_s, ba_2d_s, ba_2e_s) %>% na.omit
  df_faolimits$limit <- names(df_faolimits)[][max.col(df_faolimits[])]
  
  df_ba_faolimits <- cbind(df_df_irm_ba_fao, df_faolimits)

  df_ba_faolimits <- df_ba_faolimits %>% 
      mutate(FAO_limit = case_match(limit, "ba_2b_s" ~ "Cl", "ba_2c_s" ~ "SP", "ba_2d_s" ~ "SF", "ba_2e_s" ~ "Ls",
  .default = "missing"), .keep = "all")
  
    df_ba_faolimits <- df_ba_faolimits %>% 
      mutate(FAO_limit2 = case_when(FAO == "S1" ~ "S1", .default = paste0(FAO,"_",FAO_limit)))
    
  df_faolimits_values  <-  df_ba_faolimits %>% select(FAO_limit2) %>% unique()
  df_faolimits_values  <- df_faolimits_values[order(df_faolimits_values$FAO_limit2), ] %>% data.frame
  names(df_faolimits_values) <- c('FAO_limit_code')
  
  df_faolimits_values  <- mutate(df_faolimits_values, ID = row_number()-1)
  df_faolimits_values  <- df_faolimits_values[, c(2,1)] # re-order for later use as raster categories
  
  df_faolimits_code <-
    data.frame(
      "FAO_code_num" = c(1:17),
      "FAO_code_char" = c(
        'S1',
        'S2_Cl',
        'S2_Ls',
        'S2_SF',
        'S2_SP',
        'S3_Cl',
        'S3_Ls',
        'S3_SF',
        'S3_SP',
        'N1_Cl',
        'N1_Ls',
        'N1_SF',
        'N1_SP',
        'N2_Cl',
        'N2_Ls',
        'N2_SF',
        'N2_SP'
      )
    )
  
  vect_ba_faolimits  <- vect(df_ba_faolimits, geom = c("x", "y"))
    
  rast_ba_faolimits <- rasterize(vect_ba_faolimits, rast_mask_proj, field = "FAO_limit2")
  names(rast_ba_faolimits) <- c('FAO_limit_code')
  levels(rast_ba_faolimits) <- df_faolimits_values
  
  vect_ba_faolimits <-    merge(
    x = vect_ba_faolimits,
    y = df_faolimits_code,
    by.x = "FAO_limit2",
    by.y = "FAO_code_char",
    all.x = TRUE
  )
  
  rast_ba_faolimits_bin <-
    rasterize(vect_ba_faolimits, rast_mask_proj, field = "FAO_code_num")
  
  rast_ba_1_o <- rasterize(vect_ba_faolimits, rast_mask_proj, field = "ba_1_o")
  
  rast_ba_faolimits_brick <- rast(list(rast_ba_1_o, rast_ba_faolimits, rast_ba_faolimits_bin))
  names(rast_ba_faolimits_brick) <- c('optimal', 'FAO_limits', 'bin')
  output_geotiff(rast_ba_faolimits_brick, paste0("FAO_limits_ba1_", params$INN1))
  
  # export class and optimal value as polygon
  vect_ba_faolimits_cat <- as.polygons(rast_ba_faolimits_brick, dissolve = T)
  
  vect_filename <-
    as.character(paste("spatial_data/output/FAO_limits_ba1_", params$INN1, ".shp"))
  writeVector(vect_ba_faolimits_cat, here(vect_filename), overwrite = TRUE)
  
  g <- ggplot() +
    geom_spatraster(data = rast_ba_faolimits, na.rm = TRUE, aes(fill = FAO_limit_code)) +
    scale_fill_manual(
    name = "FAO\nlimitations\nrice",  
    breaks = c('S1','S2_Cl','S2_Ls','S2_SF','S2_SP','S3_Cl','S3_Ls','S3_SF',
      'S3_SP','N1_Cl','N1_Ls','N1_SF','N1_SP','N2_Cl','N2_Ls','N2_SF','N2_SP'),
    na.value = "transparent",
    values = c(
      S1 = rgb(0,102,0, maxColorValue = 255),
      S2_Cl = rgb(24,252,0, maxColorValue = 255),
      S2_Ls = rgb(60,179,113, maxColorValue = 255),
      S2_SF = rgb(50,205,50, maxColorValue = 255),
      S2_SP = rgb(34,139,34, maxColorValue = 255),
      S3_Cl = rgb(245, 206, 51, maxColorValue = 255),
      S3_Ls = rgb(247, 218, 102, maxColorValue = 255),
      S3_SF = rgb(250, 231, 153, maxColorValue = 255),
      S3_SP = rgb(252, 243, 204, maxColorValue = 255),
      N1_Cl = rgb(255, 127, 0, maxColorValue = 255),
      N1_Ls = rgb(255, 168, 54, maxColorValue = 255),
      N1_SF = rgb(255, 87, 40, maxColorValue = 255),
      N1_SP = rgb(255, 187, 60, maxColorValue = 255),
      N2_Cl = rgb(234, 60, 83, maxColorValue = 255),
      N2_Ls = rgb(180, 55, 87, maxColorValue = 255),
      N2_SF = rgb(66, 13, 9, maxColorValue = 255),
      N2_SP = rgb(240, 128, 128, maxColorValue = 255)
    ))
 
  g2 <- add_subdiv_proj_simple_plot(g)
  g2
} # end RES if statement 08/12/2019

``` 
</div>

<div class="fold o"> 
```{r i1_classified_ba_membership_maps_faolimits03 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, message  = FALSE, timeit = TRUE, eval=ba_crit}
# create classified suitability map and validation
# 01/03/2019 A FARROW this chunk split because map not appearing

if (params$RES1 != 2) {
  
g2 + 
    geom_spatvector(
        data = vect_triangulation, 
        mapping = aes(colour = ifelse(Adoption == "high" , "green", "red")), 
        size = 2
    ) +
  scale_colour_identity() 

} # end RES if statement 08/12/2019

``` 
</div>

```{r i1_classified_ba_membership_maps_faolimits04, echo=FALSE, results='asis', eval=ba_crit}

cat("#### Biophysical Aptitude - FAO limitations classes Leaflet")

```

<div class="fold o"> 
```{r i1_classified_ba_membership_maps_faolimits05 , cache = TRUE, cache.whatever=params$Agg, warning=FALSE, timeit = TRUE, eval=ba_crit}

if (params$RES1 != 2) {
  
  # convert the spatraster (showing the FAO suitability classes (bin number and class name), and the optimality value) to polygons - do not dissolve
  
  vect_ba_faolimits_cat2 <- as.polygons(rast_ba_faolimits_brick, dissolve=FALSE)

  
  # join the polygons (vect_ba_faolimits_cat2) with the likelihood points (vect_ba_faolimits)
  
  vect_ba_faolimits_cat2[["id"]] <- 1:nrow(vect_ba_faolimits_cat2) # need an id field for p-in-p matrix
  vect_adop[["id"]] <- 1:nrow(vect_adop) # need an id field for p-in-p matrix
  pinp_m <- relate(vect_ba_faolimits_cat2, vect_adop, "contains", pairs=TRUE) # point in polygon matrix
  df_pinp <- dplyr::as_tibble(pinp_m) # point in polygon tibble
  vect_ba_faolimits_cat3 <- merge(x = vect_ba_faolimits_cat2, y = df_pinp, by.x = "id", by.y = "id.x", all.x = TRUE)
  vect_ba_faolimits_cat4 <- merge(x = vect_ba_faolimits_cat3, y = vect_adop, by.x = "id.y", by.y = "id", all.x = TRUE)
  
     # project to geo for display in leaflet
  vect_ba_faolimits_cat4_geo <- project(vect_ba_faolimits_cat4, "epsg:4326")
  
  # convert to sf until leaflet properly accepts spatvector
  sf_ba_faolimits_cat4_geo <- st_as_sf(vect_ba_faolimits_cat4_geo)
  
  
  ba_faolimits_palette <- ( c(
      rgb(0,102,0, maxColorValue = 255),       #S1  
      rgb(24,252,0, maxColorValue = 255),      #S2_Cl  
      rgb(60,179,113, maxColorValue = 255),    #S2_Ls  
      rgb(50,205,50, maxColorValue = 255),     #S2_SF  
      rgb(34,139,34, maxColorValue = 255),     #S2_SP 
      rgb(245, 206, 51, maxColorValue = 255),  #S3_Cl 
      rgb(247, 218, 102, maxColorValue = 255), #S3_Ls  
      rgb(250, 231, 153, maxColorValue = 255), #S3_SF  
      rgb(252, 243, 204, maxColorValue = 255), #S3_SP  
      rgb(255, 127, 0, maxColorValue = 255),   #N1_Cl  
      rgb(255, 168, 54, maxColorValue = 255),  #N1_Ls  
      rgb(255, 87, 40, maxColorValue = 255),   #N1_SF  
      rgb(255, 187, 60, maxColorValue = 255),  #N1_SP  
      rgb(234, 60, 83, maxColorValue = 255),   #N2_Cl  
      rgb(180, 55, 87, maxColorValue = 255),   #N2_Ls  
      rgb(66, 13, 9, maxColorValue = 255),     #N2_SF  
      rgb(240, 128, 128, maxColorValue = 255)  #N2_SP  
    )) 

  pal <-
    colorFactor(ba_faolimits_palette, domain = c(1:17), na.color = "#808080")
  
  leaflet_widget <- leaflet(sf_ba_faolimits_cat4_geo, width = "100%") %>%
    addProviderTiles(providers$OpenStreetMap.HOT, group = "OSM (HOT)") %>%
    addPolygons(
      label = ~ stringr::str_c('Likelihood =', FAO_limits),
      labelOptions = labelOptions(direction = 'auto'),
      color = "#03F",
      weight = 1,
      opacity = 0.5,
      fill = T,
      fillColor = ~ pal(bin),
      fillOpacity = 0.2,
      dashArray = NULL,
      smoothFactor = 1,
      noClip = FALSE,
      popup = paste(
        'Adoption FAO Class  =',
        sf_ba_faolimits_cat4_geo$FAO,
        '<br>',
        '<br>',
        'Adoption optimal  =',
        sf_ba_faolimits_cat4_geo$optimal,
        '<br>',
        '<br>',
        'Biophysical optimal  =',
        sf_ba_faolimits_cat4_geo$ba_1_o,
        '<br>',
        '<br>',
        'Climate optimal  =',
        sf_ba_faolimits_cat4_geo$ba_2b_o,
        '<br>',
        'Soil Fertility optimal  =',
        sf_ba_faolimits_cat4_geo$ba_2d_o,
        '<br>',
        'Landscape optimal  =',
        sf_ba_faolimits_cat4_geo$ba_2e_o,
        '<br>',
        'Soil Physical optimal  =',
        sf_ba_faolimits_cat4_geo$ba_2c_o,
        '<br>',
        'Land Use optimal  =',
        sf_ba_faolimits_cat4_geo$ba_2a_o
      ),
      popupOptions = NULL,
      highlightOptions = NULL,
    )
  
  frameWidget(leaflet_widget, height = '500')
  
} # end RES if statement 08/12/2019

``` 
</div>


```{r i1_classified_se_membership_maps01, echo=FALSE, results='asis', eval=sef_crit}

cat("## Classified Map of Socioeconomic Feasibility")

```

<div class="fold o"> 
```{r i1_classified_se_membership_maps02 , cache = TRUE, cache.whatever=params$Agg, warning=FALSE, timeit = TRUE, eval=sef_crit}
# idem + overlay triangulation aptitude points


#vect_se_tri <- sfc_as_cols(vect_triangulation) %>%
  vect_se_tri <- vect_triangulation %>%
    mutate(
        seclass = ifelse(grepl(pattern = "high", x = Feasibility, ignore.case = TRUE), "high", ifelse(grepl(pattern = "moderate", x = Feasibility, ignore.case = TRUE), "moderate", "low")),
        type = NA
    ) %>%
    dplyr::filter(!is.na(Feasibility))


vect_se_tri$type[grepl(pattern = " AE", x = vect_se_tri$Feasibility, ignore.case = TRUE)] <- "b"
vect_se_tri$type[grepl(pattern = " EA", x = vect_se_tri$Feasibility, ignore.case = TRUE)] <- "b"
vect_se_tri$type[grepl(pattern = "bio", x = vect_se_tri$Feasibility, ignore.case = TRUE)] <- "b"
vect_se_tri$type[grepl(pattern = "SE", x = vect_se_tri$Feasibility, ignore.case = TRUE)] <- "s"
vect_se_tri$type[grepl(pattern = "soil", x = vect_se_tri$Feasibility, ignore.case = TRUE)] <- "b"
vect_se_tri$type[grepl(pattern = "lowland", x = vect_se_tri$Feasibility, ignore.case = TRUE)] <- "b"
vect_se_tri$type[grepl(pattern = " temp", x = vect_se_tri$Feasibility, ignore.case = TRUE)] <- "b"
vect_se_tri$type[grepl(pattern = " elevation", x = vect_se_tri$Feasibility, ignore.case = TRUE)] <- "b"
vect_se_tri$type[grepl(pattern = "market", x = vect_se_tri$Feasibility, ignore.case = TRUE)] <- "s"
vect_se_tri$type[grepl(pattern = "rain", x = vect_se_tri$Feasibility, ignore.case = TRUE)] <- "b"

vect_se_tri %>%
    dplyr::select(Feasibility, seclass, type) %>%
    (knitr::kable) %>% kable_styling("striped", full_width = F) %>% scroll_box(height = "300px")
``` 
</div>

```{r i1_classified_se_membership_maps03, echo=FALSE, results='asis', eval=sef_crit}

cat("### Socioeconomic Feasibility - three classes")

```

<div class="fold o"> 
```{r i1_classified_se_membership_maps04 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, timeit = TRUE, eval=sef_crit}
# create classified feasibility map

# new method because of df_irm dropped no data

if (sef_rb == "hml") {
  vect_se_3class <-
    df_irm %>% dplyr::select(se_1_h, se_1_m, se_1_l, x , y) %>% na.omit %>% vect(geom = c("x", "y"))
  rast_se_3class_h <- rasterize(vect_se_3class, rast_mask_proj, field = "se_1_h")
  rast_se_3class_m <- rasterize(vect_se_3class, rast_mask_proj, field = "se_1_m")
  rast_se_3class_l <- rasterize(vect_se_3class, rast_mask_proj, field = "se_1_l")
  rast_se_3class <- rast(list(rast_se_3class_h, rast_se_3class_m, rast_se_3class_l))
  names(rast_se_3class) <- c('high', 'moderate', 'low')

  # get max value and export
  rast_se_3class_max <- which.max(rast_se_3class)
  rast_se_3class_brick <- rast(list(rast_se_3class_h, rast_se_3class_m, rast_se_3class_l, rast_se_3class_max))
  names(rast_se_3class_brick) <- c('high', 'moderate', 'low', 'class')
  output_geotiff(rast_se_3class_brick, paste0("3class_se1_", params$INN1))

} else {
  vect_se_3class <-
    df_irm %>% dplyr::select(se_1_h, se_1_l, x , y) %>% na.omit %>% vect(geom = c("x", "y"))
  rast_se_3class_h <- rasterize(vect_se_3class, rast_mask_proj, field = "se_1_h")
  rast_se_3class_l <- rasterize(vect_se_3class, rast_mask_proj, field = "se_1_l")
  rast_se_3class <- rast(list(d1, d2))
  names(rast_se_3class) <- c('high', 'low')

  # get max value and export
  rast_se_3class_max <- which.max(rast_se_3class)
rast_se_3class_brick <- rast(list(rast_se_3class_h, rast_se_3class_l, rast_se_3class_max))
  names(rast_se_3class_brick) <- c('high', 'low', 'class')
  output_geotiff(rast_se_3class_brick, paste0("3class_se1_", params$INN1))
}

df_se_3class <- rast_se_3class %>%
  as.data.frame(xy = TRUE) %>%
  na.omit
m <- df_se_3class %>% dplyr::select(-x,-y)

df_se_3class$class <- names(m)[apply(X = m, MARGIN = 1, FUN = which.max)]
df_se_3class$class <-
  factor(df_se_3class$class,
         levels = c("low", "moderate", "high"),
         ordered = TRUE)

g <- ggplot(data = df_se_3class) +
  geom_raster(mapping = aes(x = x, y = y, fill = class)) +
  #    scale_x_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
#    scale_y_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
  scale_fill_manual(
    name = paste0("Socio-economic\nFeasibility\n", params$INN1),
    values = c(
      high = rgb(0, 158, 115, maxColorValue = 255),
      low  = rgb(213,  94,   0, maxColorValue = 255),
      moderate = rgb(230, 159, 0, maxColorValue = 255)
    ),
    drop = FALSE
  ) +
  coord_sf()


  g2 <- add_subdiv_proj_simple_plot(g)
g2 
``` 
</div>

<div class="fold o"> 
```{r i1_classified_se_membership_maps05 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, message  = FALSE, timeit = TRUE, eval=sef_crit}
# create classified suitability map and validation
# 01/03/2019 A FARROW this chunk split because map not appearing

if (params$RES1 != 2) {
  
g2 + 
    geom_spatvector(
        data = vect_se_tri, 
        mapping = aes(colour = ifelse(seclass == "optimal" , "green", "red")), 
        size = 2
    ) +
    geom_spatvector_text(
        data = vect_se_tri, 
        mapping = aes(label = ifelse(type == "s", "s", "s/b"))
    ) + 
  scale_colour_identity() 

} # end RES if statement 08/12/2019

``` 
</div>

```{r i1_classified_se_membership_maps06, echo=FALSE, results='asis', eval=sef_crit}

cat("#### Socioeconomic Feasibility - three classes Leaflet")

```

<div class="fold o"> 
```{r i1_classified_se_membership_maps07 , cache = TRUE, cache.whatever=params$Agg, warning=FALSE, timeit = TRUE, eval=sef_crit}

if (params$RES1 != 2) {
  
  vect_se_3class_max1 <- as.polygons(rast_se_3class_max , dissolve=FALSE)
  vect_se_3class_max1$class <- df_se_3class$class
  
  # join the polygons with the aptitude points
  vect_se_3class_max1[["id"]] <- 1:nrow(vect_se_3class_max1)
  vect_se[["id"]] <- 1:nrow(vect_se)
  pinp_m <- relate(vect_se_3class_max1, vect_se, "contains", pairs=TRUE)
  df_pinp <- dplyr::as_tibble(pinp_m)
  vect_se_3class_max2 <- merge(x = vect_se_3class_max1, y = df_pinp, by.x = "id", by.y = "id.x", all.x = TRUE)
  vect_se_3class_max2 <- merge(x = vect_se_3class_max2, y = vect_se, by.x = "id.y", by.y = "id", all.x = TRUE)
  
     # project to geo for display in leaflet
  vect_se_3class_max2_geo <- project(vect_se_3class_max2, "epsg:4326")
  
  # convert to sf until leaflet properly accepts spatvector
  sf_se_3class_max2_geo <- st_as_sf(vect_se_3class_max2_geo)
  
  # get the polygons showing the layer with the max value in dB_se
  # sf method of raster to stars then to sf
  #maxse1_poly1 <- st_transform(st_as_sf(st_as_stars(maxse1)), crs_lam)
  
  # join the polygons with the aptitude points
  #maxse1_poly2 <- st_join(maxse1_poly1, se_sf)
  
  #maxse1_poly3 <-
  #  cbind(maxse1_poly2, d_se$class) # add the adaptation class from d_se
  
  # project to geo for display in leaflet
  #maxse1_poly3_geo <- st_transform(maxse1_poly3, crs = 4326)
  
  
  se_3class_palette <- (c(
    rgb(0, 158, 115, maxColorValue = 255),
    #high
    rgb(230, 159, 0, maxColorValue = 255),
    #low
    rgb(213,  94,   0, maxColorValue = 255)
  )) #moderate
  
  pal <-
    colorFactor(se_3class_palette, domain = c(1:3), na.color = "#808080")
  
  leaflet_widget <- leaflet(sf_se_3class_max2_geo, width = "100%") %>%
    addProviderTiles(providers$OpenStreetMap.HOT, group = "OSM (HOT)") %>%
    addPolygons(
      label = ~ stringr::str_c('Feasibility =', class),
      labelOptions = labelOptions(direction = 'auto'),
      color = "#03F",
      weight = 1,
      opacity = 0.5,
      fill = layer,
      fillColor = ~ pal(which.max),
      fillOpacity = 0.2,
      dashArray = NULL,
      smoothFactor = 1,
      noClip = FALSE,
      popup = paste(
        'Markets Poor  =',
        sf_se_3class_max2_geo$se_2a_l,
        '<br>',
        'Farm production Low  =',
        sf_se_3class_max2_geo$se_2b_p,
        '<br>',
        'Management Poor  =',
        sf_se_3class_max2_geo$se_3a_p,
        '<br>',
        'Farm Input access Poor =',
        sf_se_3class_max2_geo$se_3b_p
      ),
      popupOptions = NULL,
      highlightOptions = NULL,
    )
  
  frameWidget(leaflet_widget, height = '500')
  
} # end RES if statement 08/12/2019

``` 
</div>

# Subdivision Area Statistics

```{r i1_statistics_adop_01, echo=FALSE, results='asis', eval=adop_crit}

cat("## Adoption Subdivision Area Statistics

### Likelihood for Adoption - three classes - total area (ha)

The table and maps shows the area in hectares within each subdivision of each likelihood for adoption class.")

```

<div class="fold o"> 
```{r i1_statistics_adop_02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=adop_crit}

if (params$RES1 != 2) {
  df_extr <- terra::extract(rast_adop_3class, vect_subdiv_proj, fun = sum, na.rm = TRUE)
  
  df_extr <-
    (df_extr * Stat_factor_ha) # calculates area depending on the aggregation level
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
 
  output_vect(vect_subdiv, paste0("adop_subdiv_area_", params$INN1)) # save as a geojson file
  
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
  
  
  fill_var_list <-  c("high", "moderate", "low")
  pal_col <- c("Greens","Oranges" ,"Reds")
  
  plot_subdiv_maps(3, fill_var_list, pal_col)
  
}

``` 
</div>


```{r i1_statistics_adop_fao_01, echo=FALSE, results='asis', eval=adop_crit}

cat("###  Likelihood for Adoption - FAO five classes - total area (ha)

The table and maps shows the area in hectares within each subdivision of each FAO likelihood for adoption class")

```

<div class="fold o"> 
```{r i1_statistics_adop_fao_02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=adop_crit}
# create subdiv level statistics
# 03/03/2019 A FARROW adde

if (params$RES1 != 1) {
  
  # need to subset the rast_adop_fao_bin to separate rasters for each of the five classes
  
  rast_adop_fao_S1 <- ifel(rast_adop_fao_cat == "S1", 1, 0)
  rast_adop_fao_S2 <- ifel(rast_adop_fao_cat == "S2", 1, 0)
  rast_adop_fao_S3 <- ifel(rast_adop_fao_cat == "S3", 1, 0)
  rast_adop_fao_N1 <- ifel(rast_adop_fao_cat == "N1", 1, 0)
  rast_adop_fao_N2 <- ifel(rast_adop_fao_cat == "N2", 1, 0)
  
  rast_adop_fao_trans <- rast(list(rast_adop_fao_S1, rast_adop_fao_S2, rast_adop_fao_S3, rast_adop_fao_N1, rast_adop_fao_N2))
  names(rast_adop_fao_trans) <- c("S1", "S2", "S3", "N1", "N2")
  
  df_extr <- terra::extract(rast_adop_fao_trans, vect_subdiv_proj, fun = sum, na.rm = TRUE)
  
  df_extr <-
    (df_extr * Stat_factor_ha) # calculates area depending on the aggregation level
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
  

  output_vect(vect_subdiv, paste0("adop_fao_subdiv_area_", params$INN1)) # save as a geojson file
  output_csv(as_tibble(vect_subdiv), paste0("adop_fao_subdiv_area_", params$INN1)) # save as a csv file
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
  
  
  fill_var_list <-  c("S1", "S2", "S3", "N1", "N2")
  pal_col <- c("Greens", "Blues", "Purples", "Oranges", "Reds")
  
  plot_subdiv_maps(5, fill_var_list, pal_col)
  
}

```

```{r i1_statistics_adop_faolimits_01, echo=FALSE, results='asis', eval=ba_crit}

cat("### Likelihood for Adoption - FAO twenty-one classes - total area (ha)

The table and maps shows the area in hectares within each subdivision of each FAO suitability classification with limiting criteria.")

```

<div class="fold o"> 
```{r i1_statistics_adop_faolimits_02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=ba_crit}
# create subdiv level statistics
# 03/03/2019 A FARROW adde

if (params$RES1 != 1) {
  
  # need to subset the rast_adop_fao_bin to separate rasters for each of the five classes
  
  rast_adop_faolimits_S1 <- ifel(rast_adop_faolimits == "S1", 1, 0)
  rast_adop_faolimits_S2_SE <- ifel(rast_adop_faolimits == "S2_SE", 1, 0)
  rast_adop_faolimits_S2_Cl <- ifel(rast_adop_faolimits == "S2_Cl", 1, 0)
  rast_adop_faolimits_S2_Ls <- ifel(rast_adop_faolimits == "S2_Ls", 1, 0)
  rast_adop_faolimits_S2_SF <- ifel(rast_adop_faolimits == "S2_SF", 1, 0)
  rast_adop_faolimits_S2_SP <- ifel(rast_adop_faolimits == "S2_SP", 1, 0)
  rast_adop_faolimits_S3_SE <- ifel(rast_adop_faolimits == "S3_SE", 1, 0)
  rast_adop_faolimits_S3_Cl <- ifel(rast_adop_faolimits == "S3_Cl", 1, 0)
  rast_adop_faolimits_S3_Ls <- ifel(rast_adop_faolimits == "S3_Ls", 1, 0)
  rast_adop_faolimits_S3_SF <- ifel(rast_adop_faolimits == "S3_SF", 1, 0)
  rast_adop_faolimits_S3_SP <- ifel(rast_adop_faolimits == "S3_SP", 1, 0)
  rast_adop_faolimits_N1_SE <- ifel(rast_adop_faolimits == "N1_SE", 1, 0)  
  rast_adop_faolimits_N1_Cl <- ifel(rast_adop_faolimits == "N1_Cl", 1, 0)
  rast_adop_faolimits_N1_Ls <- ifel(rast_adop_faolimits == "N1_Ls", 1, 0)
  rast_adop_faolimits_N1_SF <- ifel(rast_adop_faolimits == "N1_SF", 1, 0)
  rast_adop_faolimits_N1_SP <- ifel(rast_adop_faolimits == "N1_SP", 1, 0)
  rast_adop_faolimits_N2_SE <- ifel(rast_adop_faolimits == "N2_SE", 1, 0)  
  rast_adop_faolimits_N2_Cl <- ifel(rast_adop_faolimits == "N2_Cl", 1, 0)
  rast_adop_faolimits_N2_Ls <- ifel(rast_adop_faolimits == "N2_Ls", 1, 0)
  rast_adop_faolimits_N2_SF <- ifel(rast_adop_faolimits == "N2_SF", 1, 0)
  rast_adop_faolimits_N2_SP <- ifel(rast_adop_faolimits == "N2_SP", 1, 0)
  

  rast_adop_faolimits_trans <- rast(
    list(
      rast_adop_faolimits_S1 ,
      rast_adop_faolimits_S2_SE,
      rast_adop_faolimits_S2_Cl,
      rast_adop_faolimits_S2_Ls,
      rast_adop_faolimits_S2_SF,
      rast_adop_faolimits_S2_SP,
      rast_adop_faolimits_S3_SE,
      rast_adop_faolimits_S3_Cl,
      rast_adop_faolimits_S3_Ls,
      rast_adop_faolimits_S3_SF,
      rast_adop_faolimits_S3_SP,
      rast_adop_faolimits_N1_SE,
      rast_adop_faolimits_N1_Cl,
      rast_adop_faolimits_N1_Ls,
      rast_adop_faolimits_N1_SF,
      rast_adop_faolimits_N1_SP,
      rast_adop_faolimits_N2_SE,
      rast_adop_faolimits_N2_Cl,
      rast_adop_faolimits_N2_Ls,
      rast_adop_faolimits_N2_SF,
      rast_adop_faolimits_N2_SP
    )
  )
  names(rast_adop_faolimits_trans) <- c("S1", "S2_SE", "S2_Cl", "S2_Ls","S2_SF","S2_SP","S3_SE","S3_Cl","S3_Ls","S3_SF","S3_SP","N1_SE","N1_Cl","N1_Ls","N1_SF","N1_SP","N2_SE","N2_Cl","N2_Ls","N2_SF","N2_SP")
  
  df_extr <- terra::extract(rast_adop_faolimits_trans, vect_subdiv_proj, fun = sum, na.rm = TRUE)
  
  df_extr <-
    (df_extr * Stat_factor_ha) # calculates area depending on the aggregation level
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
  

  output_vect(vect_subdiv, paste0("adop_faolimits_subdiv_area_", params$INN1)) # save as a geojson file
  output_csv(as_tibble(vect_subdiv), paste0("adop_faolimits_subdiv_area_", params$INN1)) # save as a csv file
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
  
  
  fill_var_list <-  c("S1", "S2_SE", "S2_Cl", "S2_Ls","S2_SF","S2_SP","S3_SE","S3_Cl","S3_Ls","S3_SF","S3_SP","N1_SE","N1_Cl","N1_Ls","N1_SF","N1_SP","N2_SE","N2_Cl","N2_Ls","N2_SF","N2_SP")
  pal_col <- c("Greens", "PuBu","GnBu", "BuGn", "Blues","PuBu","Greys" , "YlGn", "YlGnBu","BuPu", "PuBuGn","PuBu", "Purples", "Oranges","PuRd"  ,"OrRd" ,"YlOrBr" ,"YlOrRd" ,"RdPu" ,"OrRd" ,"Reds")
  
  plot_subdiv_maps(21, fill_var_list, pal_col)
  
}

```

</div>



```{r i1_statistics_adop_05, echo=FALSE, results='asis', eval=adop_crit}

cat("### Likelihood for Adoption - three classes - (%)

The table and maps shows the percentage of each subdivision of each likelihood for adoption class.")

```

<div class="fold o"> 
```{r i1_statistics_adop_06, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=adop_crit}
# create subdiv level statistics
# 03/03/2019 A FARROW adde

if (params$RES1 != 2) {
  df_extr <- terra::extract(rast_adop_3class, vect_subdiv_proj, fun = mean, na.rm = TRUE)
  
  df_extr <- (df_extr * 100) # calculates % of the total area
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
  

  output_vect(vect_subdiv, paste0("adop_subdiv_pc_", params$INN1)) # save as a geojson file
  
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
  
  
  fill_var_list <-  c("high", "moderate", "low")
  pal_col <- c("Greens","Oranges" ,"Reds")
  
  plot_subdiv_maps(3, fill_var_list, pal_col)
  
}

``` 
</div>


```{r i1_statistics_adop_faolimits_03, echo=FALSE, results='asis', eval=adop_crit}

cat("### Likelihood for Adoption - FAO twenty-one classes - total area (%)

The table and maps shows the the percentage of each subdivision of each FAO suitability classification with limiting criteria.")

```

<div class="fold o"> 
```{r i1_statistics_adop_faolimits_04, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=adop_crit}
# create subdiv level statistics

if (params$RES1 != 1) {
  df_extr <- terra::extract(rast_adop_faolimits_trans, vect_subdiv_proj, fun = mean, na.rm = TRUE)
  
  df_extr <- (df_extr * 100) # calculates % of the total area
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
  

  output_vect(vect_subdiv, paste0("adop_faolimits_subdiv_pc_", params$INN1)) # save as a geojson file
  output_csv(as_tibble(vect_subdiv), paste0("adop_faolimits_subdiv_pc_", params$INN1)) # save as a csv file  
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
  
  
  
  fill_var_list <-  c("S1", "S2_SE", "S2_Cl", "S2_Ls","S2_SF","S2_SP","S3_SE","S3_Cl","S3_Ls","S3_SF","S3_SP","N1_SE","N1_Cl","N1_Ls","N1_SF","N1_SP","N2_SE","N2_Cl","N2_Ls","N2_SF","N2_SP")
  pal_col <- c("Greens", "PuBu","GnBu", "BuGn", "Blues","PuBu","Greys" , "YlGn", "YlGnBu","BuPu", "PuBuGn","PuBu", "Purples", "Oranges","PuRd"  ,"OrRd" ,"YlOrBr" ,"YlOrRd" ,"RdPu" ,"OrRd" ,"Reds")
  
  plot_subdiv_maps(21, fill_var_list, pal_col)
  
}

``` 

</div>


```{r i1_statistics_ba_01, echo=FALSE, results='asis', eval=ba_crit}

cat("## Aptitude Subdivision Area Statistics

### Biophysical Aptitude - two classes - total area (ha)

The table and maps shows the area in hectares within each subdivision of each aptitude classification.")

```

<div class="fold o"> 
```{r i1_statistics_ba_02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=ba_crit}
# create subdiv level statistics
# 03/03/2019 A FARROW adde

if (params$RES1 != 2) {
  df_extr <- terra::extract(rast_ba_2class, vect_subdiv_proj, fun = sum, na.rm = TRUE)
  
  df_extr <-
    (df_extr * Stat_factor_ha) # calculates area depending on the aggregation level
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
  

  output_vect(vect_subdiv, paste0("ba_subdiv_area_", params$INN1)) # save as a geojson file
  output_csv(as_tibble(vect_subdiv), paste0("ba_subdiv_area_", params$INN1)) # save as a csv file  
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
  
  
  fill_var_list <-  c("optimal", "suboptimal")
  pal_col <- c("YlGn", "Reds")
  
  plot_subdiv_maps(2, fill_var_list, pal_col)
  
}

``` 
</div>


```{r i1_statistics_ba_fao_01, echo=FALSE, results='asis', eval=ba_crit}

cat("### Biophysical Aptitude - FAO five classes - total area (ha)

The table and maps shows the area in hectares within each subdivision of each FAO suitability classification.")

```

<div class="fold o"> 
```{r i1_statistics_ba_fao_02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=ba_crit}
# create subdiv level statistics
# 03/03/2019 A FARROW adde

if (params$RES1 != 1) {
  
  # need to subset the rast_fao_bin to separate rasters for each of the five classes
  
  rast_fao_S1 <- ifel(rast_ba_fao_cat == "S1", 1, 0)
  rast_fao_S2 <- ifel(rast_ba_fao_cat == "S2", 1, 0)
  rast_fao_S3 <- ifel(rast_ba_fao_cat == "S3", 1, 0)
  rast_fao_N1 <- ifel(rast_ba_fao_cat == "N1", 1, 0)
  rast_fao_N2 <- ifel(rast_ba_fao_cat == "N2", 1, 0)
  
  rast_fao_trans <- rast(list(rast_fao_S1, rast_fao_S2, rast_fao_S3, rast_fao_N1, rast_fao_N2))
  names(rast_fao_trans) <- c("S1", "S2", "S3", "N1", "N2")
  
  df_extr <- terra::extract(rast_fao_trans, vect_subdiv_proj, fun = sum, na.rm = TRUE)
  
  df_extr <-
    (df_extr * Stat_factor_ha) # calculates area depending on the aggregation level
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
  

  output_vect(vect_subdiv, paste0("ba_fao_subdiv_area_", params$INN1)) # save as a geojson file
  output_csv(as_tibble(vect_subdiv), paste0("ba_fao_subdiv_area_", params$INN1)) # save as a csv file
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
  
  
  fill_var_list <-  c("S1", "S2", "S3", "N1", "N2")
  pal_col <- c("Greens", "Blues", "Purples", "Oranges", "Reds")
  
  plot_subdiv_maps(5, fill_var_list, pal_col)
  
}

``` 

```{r i1_statistics_ba_faolimits_01, echo=FALSE, results='asis', eval=ba_crit}

cat("### Biophysical Aptitude - FAO seventeen classes - total area (ha)

The table and maps shows the area in hectares within each subdivision of each FAO suitability classification with limiting criteria.")

```

<div class="fold o"> 
```{r i1_statistics_ba_faolimits_02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=ba_crit}
# create subdiv level statistics
# 03/03/2019 A FARROW adde

if (params$RES1 != 1) {
  
  # need to subset the rast_fao_bin to separate rasters for each of the five classes
  
  rast_ba_faolimits_S1 <- ifel(rast_ba_faolimits == "S1", 1, 0)
  rast_ba_faolimits_S2_Cl <- ifel(rast_ba_faolimits == "S2_Cl", 1, 0)
  rast_ba_faolimits_S2_Ls <- ifel(rast_ba_faolimits == "S2_Ls", 1, 0)
  rast_ba_faolimits_S2_SF <- ifel(rast_ba_faolimits == "S2_SF", 1, 0)
  rast_ba_faolimits_S2_SP <- ifel(rast_ba_faolimits == "S2_SP", 1, 0)
  rast_ba_faolimits_S3_Cl <- ifel(rast_ba_faolimits == "S3_Cl", 1, 0)
  rast_ba_faolimits_S3_Ls <- ifel(rast_ba_faolimits == "S3_Ls", 1, 0)
  rast_ba_faolimits_S3_SF <- ifel(rast_ba_faolimits == "S3_SF", 1, 0)
  rast_ba_faolimits_S3_SP <- ifel(rast_ba_faolimits == "S3_SP", 1, 0)
  rast_ba_faolimits_N1_Cl <- ifel(rast_ba_faolimits == "N1_Cl", 1, 0)
  rast_ba_faolimits_N1_Ls <- ifel(rast_ba_faolimits == "N1_Ls", 1, 0)
  rast_ba_faolimits_N1_SF <- ifel(rast_ba_faolimits == "N1_SF", 1, 0)
  rast_ba_faolimits_N1_SP <- ifel(rast_ba_faolimits == "N1_SP", 1, 0)
  rast_ba_faolimits_N2_Cl <- ifel(rast_ba_faolimits == "N2_Cl", 1, 0)
  rast_ba_faolimits_N2_Ls <- ifel(rast_ba_faolimits == "N2_Ls", 1, 0)
  rast_ba_faolimits_N2_SF <- ifel(rast_ba_faolimits == "N2_SF", 1, 0)
  rast_ba_faolimits_N2_SP <- ifel(rast_ba_faolimits == "N2_SP", 1, 0)
  

  rast_ba_faolimits_trans <- rast(
    list(
      rast_ba_faolimits_S1 ,
      rast_ba_faolimits_S2_Cl,
      rast_ba_faolimits_S2_Ls,
      rast_ba_faolimits_S2_SF,
      rast_ba_faolimits_S2_SP,
      rast_ba_faolimits_S3_Cl,
      rast_ba_faolimits_S3_Ls,
      rast_ba_faolimits_S3_SF,
      rast_ba_faolimits_S3_SP,
      rast_ba_faolimits_N1_Cl,
      rast_ba_faolimits_N1_Ls,
      rast_ba_faolimits_N1_SF,
      rast_ba_faolimits_N1_SP,
      rast_ba_faolimits_N2_Cl,
      rast_ba_faolimits_N2_Ls,
      rast_ba_faolimits_N2_SF,
      rast_ba_faolimits_N2_SP
    )
  )
  names(rast_ba_faolimits_trans) <- c("S1", "S2_Cl", "S2_Ls","S2_SF","S2_SP","S3_Cl","S3_Ls","S3_SF","S3_SP","N1_Cl","N1_Ls","N1_SF","N1_SP","N2_Cl","N2_Ls","N2_SF","N2_SP")
  
  df_extr <- terra::extract(rast_ba_faolimits_trans, vect_subdiv_proj, fun = sum, na.rm = TRUE)
  
  df_extr <-
    (df_extr * Stat_factor_ha) # calculates area depending on the aggregation level
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
  

  output_vect(vect_subdiv, paste0("ba_faolimits_subdiv_area_", params$INN1)) # save as a geojson file
  output_csv(as_tibble(vect_subdiv), paste0("ba_faolimits_subdiv_area_", params$INN1)) # save as a csv file
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
  
  
  fill_var_list <-  c("S1", "S2_Cl", "S2_Ls","S2_SF","S2_SP","S3_Cl","S3_Ls","S3_SF","S3_SP","N1_Cl","N1_Ls","N1_SF","N1_SP","N2_Cl","N2_Ls","N2_SF","N2_SP")
  pal_col <- c("Greens", "GnBu", "BuGn", "Blues","Greys" , "YlGn", "YlGnBu","BuPu", "PuBuGn", "Purples", "Oranges","PuRd"  ,"OrRd" ,"YlOrBr" ,"YlOrRd" ,"RdPu" ,"OrRd" ,"Reds")
  
  plot_subdiv_maps(17, fill_var_list, pal_col)
  
}

```

```{r i1_statistics_ba_03, echo=FALSE, results='asis', eval=ba_crit}

cat("### Biophysical Aptitude - two classes - (%)

The table and maps shows the percentage of each subdivision of each aptitude classification.")

```

<div class="fold o"> 
```{r i1_statistics_ba_04, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=ba_crit}
# create subdiv level statistics
# 03/03/2019 A FARROW adde

if (params$RES1 != 2) {
  df_extr <- terra::extract(rast_ba_2class, vect_subdiv_proj, fun = mean, na.rm = TRUE)
  
  df_extr <- (df_extr * 100) # calculates % of the total area
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
  

  output_vect(vect_subdiv, paste0("ba_subdiv_pc_", params$INN1)) # save as a geojson file
  output_csv(as_tibble(vect_subdiv), paste0("ba_subdiv_pc_", params$INN1)) # save as a csv file
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
  
  
  fill_var_list <-  c("optimal", "suboptimal")
  pal_col <- c("YlGn", "Reds")
  
  plot_subdiv_maps(2, fill_var_list, pal_col)
  
}

``` 
</div>


```{r i1_statistics_ba_faolimits_03, echo=FALSE, results='asis', eval=ba_crit}

cat("### Biophysical Aptitude - seventeen classes - (%)

The table and maps shows the the percentage of each subdivision of each FAO suitability classification with limiting criteria.")

```

<div class="fold o"> 
```{r i1_statistics_ba_faolimits_04, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=ba_crit}
# create subdiv level statistics
# 03/03/2019 A FARROW adde

if (params$RES1 != 1) {
  df_extr <- terra::extract(rast_ba_faolimits_trans, vect_subdiv_proj, fun = mean, na.rm = TRUE)
  
  df_extr <- (df_extr * 100) # calculates % of the total area
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
  

  output_vect(vect_subdiv, paste0("ba_faolimits_subdiv_pc_", params$INN1)) # save as a geojson file
  output_csv(as_tibble(vect_subdiv), paste0("ba_faolimits_subdiv_pc_", params$INN1)) # save as a csv file  
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
  
  
  
  fill_var_list <-  c("S1", "S2_Cl", "S2_Ls","S2_SF","S2_SP","S3_Cl","S3_Ls","S3_SF","S3_SP","N1_Cl","N1_Ls","N1_SF","N1_SP","N2_Cl","N2_Ls","N2_SF","N2_SP")
  pal_col <- c("Greens", "GnBu", "BuGn", "Blues","Greys" , "YlGn", "YlGnBu","BuPu", "PuBuGn", "Purples", "Oranges","PuRd"  ,"OrRd" ,"YlOrBr" ,"YlOrRd" ,"RdPu" ,"OrRd" ,"Reds")
  
  plot_subdiv_maps_pc(17, fill_var_list, pal_col)
  
}

``` 

</div>

```{r i1_statistics_se_01, echo=FALSE, results='asis', eval=sef_crit}

cat("## Feasibility Subdivision Area Statistics

### Socioeconomic Feasibility - three classes - total area (ha)

The table and maps shows the area in hectares within each subdivision of each socioeconomic feasibility class.")

```

<div class="fold o"> 
```{r i1_statistics_se_02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=sef_crit}
# create subdiv level statistics
# 03/03/2019 A FARROW adde

if (params$RES1 != 2) {
  df_extr <- terra::extract(rast_se_3class, vect_subdiv_proj, fun = sum, na.rm = TRUE)
  
  df_extr <-
    (df_extr * Stat_factor_ha) # calculates area depending on the aggregation level
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
  

  output_vect(vect_subdiv, paste0("se_subdiv_area_", params$INN1)) # save as a geojson file
  
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
 
   
  fill_var_list <-  c("high", "moderate", "low")
  pal_col <- c("Greens","Oranges" ,"Reds")
  
  plot_subdiv_maps(3, fill_var_list, pal_col)
  
}

``` 
</div>


```{r i1_statistics_se_03, echo=FALSE, results='asis', eval=sef_crit}

cat("### Socioeconomic Feasibility - three classes - (%)

The table and maps shows the percentage of each subdivision of each socioeconomic feasibility class.")

```

<div class="fold o"> 
```{r i1_statistics_se_04, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=sef_crit}
# create subdiv level statistics
# 03/03/2019 A FARROW adde

if (params$RES1 != 2) {
  df_extr <- terra::extract(rast_se_3class, vect_subdiv_proj, fun = mean, na.rm = TRUE)
  
  df_extr <- (df_extr * 100) # calculates % of the total area
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
  

  output_vect(vect_subdiv, paste0("se_subdiv_pc_", params$INN1)) # save as a geojson file
  
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
  
  
  fill_var_list <-  c("high", "moderate", "low")
  pal_col <- c("Greens","Oranges" ,"Reds")
  
  plot_subdiv_maps(3, fill_var_list, pal_col)
  
}

``` 
</div>

# Calculate yields and production

## Yield proportion

The IRM script already calculates the optimality of the individual criteria as well as the climatic, landscape, soil fertility and soil physical properties groups of criteria.

The first method of calculating yield will calculate the product of the optimality of selected criteria.


```{r i1_calc_yield_1, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", include = TRUE, echo=FALSE, message=FALSE, warning=FALSE, eval=ba_crit}

# get the criteria that contribute to yield

df_yield_rb_1 <- dplyr::select(df_priorities, "rulebase_number","criterion","yield") %>% dplyr::filter(!is.na(yield))

df_yield_rb_1 %>% kable(digits = 3) %>% kable_styling("striped", full_width = T)  %>%  scroll_box(height = "500px")
# make an expression using the rule base numbers

yield_expr <- paste("df_irm$yieldpc <- (")

for (i in seq(from = 1,
              to = nrow(df_yield_rb_1),
              by = 1)) {
  yield_expr <- paste0(yield_expr, "df_irm$" , as.character(df_yield_rb_1[i, 1]), "_o * ")
  
}
yield_expr <- paste(yield_expr, " 100)")
yield_expr

# evaluate the expression
eval(str2expression(yield_expr))
str(df_irm$yieldpc)
if (summarise(df_irm, Average = mean(yieldpc, na.rm = T)) > 0) {

# df_irm <- dplyr::select(df_irm,-yield)

vect_yieldpc <- select(df_irm, x, y, yieldpc) %>% na.omit %>% vect(geom = c("x", "y"))

rast_yieldpc <- rasterize(vect_yieldpc, rast_mask_proj, field="yieldpc")
names(rast_yieldpc) <- c('yieldpc')

# export
output_geotiff(rast_yieldpc, paste0("yieldpc_", params$INN1))

#  dy <- rast_yield %>%
#    as.data.frame(xy = TRUE) %>%
#    na.omit

  
  gy <- ggplot() +
    geom_spatraster(data = rast_yieldpc, aes(fill = yieldpc)) +
    scale_fill_stepsn(
      paste0("Yield % \n", params$INN1),
      n.breaks = 10,
      limits = c(0, 100),
      colours = hcl.colors(palette = "Greens", 10, rev = TRUE),
      guide = "legend",  na.value = "transparent"
    ) +
#    scale_x_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
#    scale_y_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
    coord_sf()
  
  gy2 <- add_subdiv_proj_simple_plot(gy)
gy2
}
```

## Calculate yield

The IRM script converts yield proportion to yield using the yield values for sole crop or intercrop.


```{r i1_calc_yield_2, cache = TRUE, cache.whatever=params$Agg, out.width="100%", include = TRUE, echo=FALSE, message=FALSE, warning=FALSE, eval=ba_crit}

# get the criteria that contribute to yield

filename_yield <-
  as.character(paste("tab_data/input/yield_", params$INN1, ".csv", sep = ""))
df_yield_values <- read.csv(here(filename_yield), na.strings = c("NA"))

df_yield_values %>% kable(digits = 3) %>% kable_styling("striped", full_width = T)  %>%  scroll_box(height = "100px")


if (params$INN2 == "NA") {
  df_irm$yield <- df_irm$yieldpc / 100 * df_yield_values$YA
  cat("Sole crop yield")
} else {
  if (params$SYS == "comparison") {
    df_irm$yield <- df_irm$yieldpc / 100 * df_yield_values$YA
    cat("Sole crop 1 yield (comparison)")
  } else {
    if (params$SYS == "intercrop") {
      df_irm$yield <- df_irm$yieldpc / 100 * df_yield_values$YI
      cat("Intercrop 1 yield")
    } else {
      if (params$SYS == "rotation") {
        df_irm$yield <- df_irm$yieldpc / 100 * df_yield_values$YA
        cat("Rotation crop 1 yield")
      }
    }
  }
}

if (summarise(df_irm, Average = mean(yield, na.rm = T)) > 0) {
  
  vect_yield <-
    select(df_irm, x, y, yield) %>% na.omit %>% vect(geom = c("x", "y"))
  
  rast_yield <- rasterize(vect_yield, rast_mask_proj, field = "yield")
  names(rast_yield) <-  c('yield')

# export
output_geotiff(rast_yield, paste0("yield_", params$INN1))

#dyd <- dByd %>%
#  as.data.frame(xy = TRUE) %>%
#  na.omit


gyd <- ggplot() +
  geom_spatraster(data = rast_yield, aes(fill = yield)) +
  scale_fill_stepsn(
    paste0("Yield (kg/ha) \n", params$INN1),
    n.breaks = 10,
    colours = hcl.colors(palette = "OrRd", 10, rev = TRUE),
    guide = "legend",
    labels = comma,  na.value = "transparent"
  ) +
#  scale_x_continuous(
#    name = "",
#    labels = function(x) {
#      1.0e-3 * x
#    }
#  ) +
#  scale_y_continuous(
#    name = "",
#    labels = function(x) {
#      1.0e-3 * x
#    }
#  ) +
  coord_sf()

  gyd2 <- add_subdiv_proj_simple_plot(gyd)
gyd2
}
```

## Calculate production

The IRM script converts yield proportion to production using the yield values for sole crop or intercrop.


```{r i1_calc_yield_3, cache = TRUE, cache.whatever=params$Agg, out.width="100%", include = TRUE, echo=FALSE, message=FALSE, warning=FALSE, eval=ba_crit}

# get the criteria that contribute to yield

#yield_filename <-
#  as.character(paste("tab_data/input/yield_", params$INN1, ".csv", sep = ""))
#yield_tab <- read.csv(here(yield_filename), na.strings = c("NA"))

#yield_tab %>% kable(digits = 3) %>% kable_styling("striped", full_width = T)  %>%  scroll_box(height = "150px")

df_irm$production <- df_irm$yieldpc *  Stat_factor_ha

if (summarise(df_irm, Average = mean(production, na.rm = T)) > 0) {
  vect_production <-
    select(df_irm, x, y, production) %>% na.omit %>% vect(geom = c("x", "y"))
  
  rast_production <-
    rasterize(vect_production, rast_mask_proj, field = "production")
  names(rast_production) <- c('production')
  
  # export
  output_geotiff(rast_production, paste0("production_", params$INN1))
  
  #  dp <- dBp %>%
  #    as.data.frame(xy = TRUE) %>%
  #    na.omit
  
  gp <- ggplot() +
    geom_spatraster(data = rast_production, aes(fill = production)) +
    scale_fill_stepsn(
      paste0("Production (kg) \n", params$INN1),
      n.breaks = 10,
      colours = hcl.colors(palette = "BuPu", 10, rev = TRUE),
      guide = "legend",
      labels = comma,
      na.value = "transparent"
    ) +
#    scale_x_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
#    scale_y_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
    coord_sf()
  
  gp2 <- add_subdiv_proj_simple_plot(gp)
  gp2
}
```

```{r i1_innovation_name_i2_check01, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

if (params$INN2 == "NA") {
  cat("# Session Information
      ")
  
  si_1 <- sessionInfo()
  si_1
  
}  

knit_exit()

```

```{r i1_innovation_name_i2_check02, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}


if (params$INN2 == "NA") {
  cat(
    "# Acknowledgements

Javascript code and css style used in this script by Martin Schmelzer

https://stackoverflow.com/questions/37755037/how-to-add-code-folding-to-output-chunks-in-rmarkdown-html-documents


Timing for chunks by Yihui Xie
https://stackoverflow.com/questions/24595280/timing-for-chunks  "
  )
  
}

```


```{r i2_innovation_name1, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

cat("# Second Innovation
    ")
```

```{r i2_innovation_name2, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

cat("<div class='INN'>")
cat("Innovation name =", params$INN2)
cat("</div>")
cat("<div class='Agg'>")
cat("Spatial Aggregation =", params$Agg)
cat("</div>")

```

# Basic Settings

## Parameters, Criteria and Rule Bases

Here we load some parameters used in the IRM model, load the table of criteria and their threshold values, weights (if relevant) and data, and display the rule bases in a graphical diagramme. 

### Parameters and Criteria

<div class="fold o"> 
```{r i2_i1_parameters_location, results='asis'}

# Each innovation has potentially different growing periods, rule bases, rule base priorities, and thresholds

# The next set of parameters are for the priorities of the socio-economic rule base.
# Following this there are parameters for the growing period length.
# There then follow parameters for thresholds and threshold widths

# get the priorities filename using the innovation parameter
priorities_filename <-
  as.character(paste("tab_data/input/priorities_", params$INN2, ".csv", sep = ""))

df_priorities <- read.csv(here(priorities_filename), na.strings = c("NA"))

df_priorities %>%

kable(digits = 3) %>% kable_styling("striped", full_width = T) %>%
  row_spec(0, angle = -45) %>%  scroll_box(height = "500px")

```
</div>

### Rule Base Diagramme

Boxes in green show basic rule bases which have data and a fuzzy partition defined. Circles in red are complex rule base stacks, which depend on the results of other rule bases. 

<div class="fold o"> 
```{r i2_i1_rule_base_graphs, results='asis'}

priorities_new_columns_filename <-
  as.character(paste("tab_data/input/priorities_new_columns_", params$INN2, ".csv", sep = ""))

df_priorities_new_columns <- read.csv(here(priorities_new_columns_filename), na.strings = c("NA"))

df_edges <-  select(df_priorities_new_columns, criterion, stack) %>% dplyr::filter( !is.na(stack)) # %>% 
#as.matrix(ncol = 2)

df_vertices <-  select(df_priorities_new_columns, criterion) 

library(igraph)
#graph_rb <- graph_from_edgelist(df_edges)
graph_rb <- graph_from_data_frame(df_edges, directed=TRUE, vertices=df_vertices)
#dotfile_graph_rb <- write_graph(graph_rb, paste0("../../tab_data/output/graph_rb", "dot"))
#if (!interactive()) {
#  unlink(file)
#}
plot(graph_rb)
print(graph_rb, e=TRUE, v=TRUE)
adj_list <- as_adj_list(graph_rb, mode = c("in"))

```
</div>


<div class="fold o"> 
```{r i2_i1_rule_base_graphs2, results='asis'}
# In this chunk we will use the DiagrammeR package to produce a graph diagram of the rule bases, using the information provided by the priorities csv file loaded in the previous chunk.

# the DiagrammeR package expects a valid graph specification in the DOT language. The graph is a kind of network with nodes and edges. For our purposes the nodes are the criteria and the rule bases. The edges are directed lines that show how each contributes and can also the weight of each criteria (or the results of previously run rule bases)

# the graph has a statement followed by the list of nodes and edges

# in this chunk we will construct the string that is equivalent to a .gv file


# this creates a new df with a string of rulebase number and labels

df_rbnumber1 <- unite(df_priorities, "id_label0", "rulebase_number","criterion", sep = " [ label = '", remove = FALSE, na.rm = FALSE)
df_rbnumber1 <- unite(df_rbnumber1, "id_label1", "id_label0", "rulebase_number", sep = " \n", remove = FALSE, na.rm = FALSE)
df_rbnumber1$cl_br <- c(" ']")
df_rbnumber1 <- unite(df_rbnumber1, "id_label", "id_label1","cl_br", sep = "", remove = TRUE, na.rm = FALSE)

rbstacklist1 <- df_rbnumber1[,"rulebase_stack"]  
rbstacklist2 <- rbstacklist1[!is.na(rbstacklist1)] 
rbstacklist3 <- unique(rbstacklist2)
rbstacklist4 <- paste(rbstacklist3, collapse=";")

rbnumberlist1 <- df_rbnumber1[,"rulebase_number"]  
rbnumberlist2 <- rbnumberlist1[!is.na(rbnumberlist1)] 
rbnumberlist3 <- unique(rbnumberlist2)
rbnumberlist4 <- rbnumberlist3[rbnumberlist3 %ni% rbstacklist3]
rbnumberlist5 <- paste(rbnumberlist4, collapse=";")

rbnumberlist2 <- rbnumberlist2[! rbnumberlist2 %in% c('adop_0')]

edges1 <- paste(rbnumberlist2,rbstacklist2, sep="->")  
edges2 <- paste(edges1, collapse=" ")

rbnumberlabellist1 <- df_rbnumber1[,"id_label"]  
rbnumberlabellist2 <- rbnumberlabellist1[!is.na(rbnumberlist1)] 
rbnumberlabellist3 <- unique(rbnumberlabellist2)
rbnumberlabellist4 <- rbnumberlabellist3[rbnumberlist3 %ni% rbstacklist3]
rbnumberlabellist5 <- paste(rbnumberlabellist4, collapse=";")

rbstacklabellist1 <- df_rbnumber1[,"id_label"]
rbstacklabellist2 <- rbstacklabellist1[!is.na(rbstacklist1)] 
rbstacklabellist3 <- rbstacklabellist2[rbnumberlist3 %in% rbstacklist3]
rbstacklabellist4 <- paste(rbstacklabellist3, collapse=";")

rulebasegraph_name <- paste("digraph simple_rule_base")
rulebasegraph_graph_stmt <- paste("graph [overlap = true, fontsize = 100, fontname = Calibri, rankdir = LR, label = 'Rule bases for ", params$INN2, "', labelloc = t]")
rulebasegraph_node_stmt <- paste("node [shape = box, fontsize = 50, fontname = Helvetica, color = 'DarkOliveGreen4', fillcolor = 'OliveDrab2', style = filled]",
  rbnumberlabellist5,
  "node [shape = oval, fixedsize = false, width = 0.9, color = 'red', fillcolor = 'IndianRed3', fontsize = 50, fontname = Helvetica, style = filled] ",
  rbstacklabellist4
  )

rulebasegraph_edge_stmt <- paste(edges2)

rulebasegraph <- paste(rulebasegraph_name, "{", rulebasegraph_graph_stmt, rulebasegraph_node_stmt, rulebasegraph_edge_stmt, "}")

grViz(rulebasegraph)

#frameWidget(grViz(rulebasegraph) , options = frameOptions(allowfullscreen = FALSE))


#knitr::knit_exit() # this stops knitting useful for debugging

```
</div>

```{r i2_i1_rule_base_stack_binary, results='asis'}


# adoption rule base exists?
if (("adop_0" %in% rbstacklist3) & ("ba_1" %in% rbstacklist3) & ("se_1" %in% rbstacklist3)){
    adop_crit <- TRUE
} else {adop_crit <- FALSE}


# biophysical aptitude rule base exists?
if ("ba_1" %in% rbstacklist3) {
    ba_crit <- TRUE
} else {ba_crit <- FALSE}

# agricultural land rule base exists?
if ("ba_2a" %in% rbnumberlist3) {
    land_crit <- TRUE
} else {land_crit <- FALSE}

# season onset non-spatial?
if (params$SOS1 != 1){
    nonsos_crit <- TRUE
} else {nonsos_crit <- FALSE}

# season onset spatial?
if (params$SOS1 == 1){
    sos_crit <- TRUE
} else {sos_crit <- FALSE}


# climate rule base exists?
if ("ba_2b" %in% rbstacklist3) {
    clim_crit <- TRUE
} else {clim_crit <- FALSE}

# soil physical properties rule base exists?
if ("ba_2c" %in% rbstacklist3) {
    soil_p_crit <- TRUE
  } else {soil_p_crit <- FALSE}

# soil fertility rule base exists?
if ("ba_2d" %in% rbstacklist3) {
    soil_f_crit <- TRUE
} else {soil_f_crit <- FALSE}

# landscape rule base exists?
if ("ba_2e" %in% rbstacklist3) {
    lscape_crit <- TRUE
} else {lscape_crit <- FALSE}

# rainfall rule base exists?
if ("ba_3a" %in% rbstacklist3) {
    prec_crit <- TRUE
} else {prec_crit <- FALSE}

# temperature rule base exists?
if ("ba_3b" %in% rbstacklist3) {
    tmp_crit <- TRUE
} else {tmp_crit <- FALSE}

# socio-economic feasibility rule base exists?
if ("se_1" %in% rbstacklist3) {
    sef_crit <- TRUE
} else {sef_crit <- FALSE}

# farm production feasibility rule base exists?
if ("se_2a" %in% rbstacklist3) {
    fpf_crit <- TRUE
} else {fpf_crit <- FALSE}

# market access rule base exists?
if ("se_2b" %in% rbstacklist3) {
    mktaccess_crit <- TRUE
} else {mktaccess_crit <- FALSE}

# management rule base exists?
if ("se_3a" %in% rbstacklist3) {
    management_crit <- TRUE
} else {management_crit <- FALSE}

# inputs access rule base exists?
if ("se_3b" %in% rbstacklist3) {
    inpaccess_crit <- TRUE
} else {inpaccess_crit <- FALSE}

# extension access rule base exists?
if ("se_4a" %in% rbstacklist3) {
    extaccess_crit <- TRUE
} else {extaccess_crit <- FALSE}

# labour access rule base exists?
if ("se_4b" %in% rbstacklist3) {
    lab_crit <- TRUE
} else {lab_crit <- FALSE}

# fertiliser/pesticides access rule base exists?
if ("se_4c" %in% rbstacklist3) {
    fp_crit <- TRUE
} else {fp_crit <- FALSE}


```



# Load Spatial Data

Here we load all the spatial data. The data are used in different chunks below but it is easier to modify filenames if all the spatial data are imported in the same chunk.

## Vector Data

The vector data include the sub-divisions of the area that is being modelled, and triangulation points if available.

The vector data are not projected and in geojson format. Here they are loaded and projected to the working crs


<div class="fold o">   
```{r i2_i1_spatialdataload_vector_01, cache = FALSE, out.width="100%", include = TRUE, echo=FALSE}


vect_subdiv <- load_vector_data( paste0("subdiv_", params$INN2))

vect_subdiv$id <- seq.int(nrow(vect_subdiv))# add an id field
vect_subdiv$id <- formatC(vect_subdiv$id, width = 2, format = "d", flag = "0") #format the id field

vect_subdiv_extent <- ext(vect_subdiv) # get the extent
nudge_xval <-
  ((vect_subdiv_extent[2] - vect_subdiv_extent[1]) /  (nrow(vect_subdiv) * 2.5))
#cat("nudge_xval =", nudge_xval)
nudge_yval <-
  ((vect_subdiv_extent[4] - vect_subdiv_extent[3]) /  (nrow(vect_subdiv) * 2.5))
#cat("nudge_yval =", nudge_yval)

vect_subdiv_pt <- centroids(vect_subdiv)
expr <- paste0("vect_subdiv_pt$", params$SUBDIV2)
vect_subdiv_pt$subdiv_label <- paste(vect_subdiv_pt$id, "=", eval(parse(text=(expr))))
vect_subdiv_pt$subdiv_label <- factor(vect_subdiv_pt$subdiv_label)

g <- ggplot()
gsubdiv <- add_subdiv_plot(g)
gsubdiv

```
</div>

<div class="fold o">   
```{r i2_i1_spatialdataload_vector_02, cache = FALSE, out.width="100%", include = TRUE, echo=FALSE}

vect_triangulation <- load_vector_data( paste0("triangulation_", params$INN2))

vect_triangulation$id <- seq.int(nrow(vect_triangulation))# add an id field
vect_triangulation$id <- formatC(vect_triangulation$id, width = 2, format = "d", flag = "0") #format the id field

vect_triangulation_extent <- ext(vect_triangulation) # get the extent
nudge_xvaltri <-
  ((vect_triangulation_extent[2] - vect_triangulation_extent[1]) /  (nrow(vect_triangulation) * 2.5))
#cat("nudge_xvaltri =", nudge_xvaltri)
nudge_yvaltri <-
  ((vect_triangulation_extent[4] - vect_triangulation_extent[3]) /  (nrow(vect_triangulation) * 2.5))
#cat("nudge_yvaltri =", nudge_yvaltri)

expr <- paste0("vect_triangulation$", params$TRI2)
vect_triangulation$tri_label <- paste(vect_triangulation$id, "=", eval(parse(text=(expr))))
vect_triangulation$tri_label <- factor(vect_triangulation$tri_label)

g <- ggplot()
gtriangulation <- add_triangulation_plot_no_labels(g)

gtriangulation <- add_subdiv_simple_plot(gtriangulation)
gtriangulation

```
</div>


## Raster Data

The raster spatial data are loaded first.
Only the mask need be in the working crs.

<div class="fold o">   
```{r i2_i1_spatialdataload_raster_01, results='asis', warning=FALSE}

# set the working crs using WKT arguments

wkt_lam <-  paste0(
    "PROJCRS[\"unknown\",
    BASEGEOGCRS[\"unknown\",
        DATUM[\"World Geodetic System 1984\",
            ELLIPSOID[\"WGS 84\",6378137,298.257223563,
                LENGTHUNIT[\"metre\",1]],
            ID[\"EPSG\",6326]],
        PRIMEM[\"Greenwich\",0,
            ANGLEUNIT[\"degree\",0.0174532925199433],
            ID[\"EPSG\",8901]]],
    CONVERSION[\"unknown\",
        METHOD[\"Lambert Azimuthal Equal Area\",
            ID[\"EPSG\",9820]],
        PARAMETER[\"Latitude of natural origin\",",
vect_subdiv_extent[3],
    ",ANGLEUNIT[\"degree\",0.0174532925199433],
            ID[\"EPSG\",8801]],
        PARAMETER[\"Longitude of natural origin\",",
vect_subdiv_extent[1],
    ",ANGLEUNIT[\"degree\",0.0174532925199433],
            ID[\"EPSG\",8802]],
        PARAMETER[\"False easting\",1000000,
            LENGTHUNIT[\"metre\",1],
            ID[\"EPSG\",8806]],
        PARAMETER[\"False northing\",1000000,
            LENGTHUNIT[\"metre\",1],
            ID[\"EPSG\",8807]]],
    CS[Cartesian,2],
        AXIS[\"(E)\",east,
            ORDER[1],
            LENGTHUNIT[\"metre\",1,
                ID[\"EPSG\",9001]]],
        AXIS[\"(N)\",north,
            ORDER[2],
            LENGTHUNIT[\"metre\",1,
                ID[\"EPSG\",9001]]]]"
  )


# project the country boundary to LAM

vect_subdiv_proj <-  project(vect_subdiv, wkt_lam)
vect_subdiv_proj_extent <- terra::ext(vect_subdiv_proj)

# make a basic raster with dimensions with 100m resolution 
# and projected crs 

rast_subdiv_mask_proj_extent <- rast(crs = wkt_lam, extent = vect_subdiv_proj_extent, resolution = params$MASK)

# make the mask based on the country boundary

rast_subdiv_mask_proj <- terra::rasterize(
      vect_subdiv_proj,
      rast_subdiv_mask_proj_extent,
      field = 1,
      background = NA
    ) 


# subset the priorities dataframe to keep only the records that have distinct raster data files

df_raster_data <- droplevels(distinct(df_priorities,
                                      data_file_prefix,
                                      .keep_all = T)) %>% drop_na(data_file_prefix)


# for each record in the df_raster_data data frame use the data file prefix and the raster or brick variable to load the raster data, the name of the raster is generated automatically from the data file name
# these rasters needn't have the same crs as the working crs but must have the crs in the metadata (e.g. geotiff format)

for (i in seq(from = 1,
              to = nrow(df_raster_data),
              by = 1)) {
  assign(
    paste0("rast_", df_raster_data[i, 11]),
    load_raster_data(
      as.character(df_raster_data[i, 11]),
      paste0("rast_", df_raster_data[i, 11])
    )
  )
  cat(paste0("\nrast_", df_raster_data[i, 11], " :"))
  #print(crs(get(paste0(
  #  "rast_", df_raster_data[i, 11]
  #))))
  print(get(paste0(
    "rast_", df_raster_data[i, 11]
  )))
}


```
</div>


# Common spatial resolution and extent

## Mask

Let's start with creating a 'mask', _i.e._, a raster map of the area of interest (1 = area to be modelled, NA = ignored). 

The properties of this map are given below:

<div class="fold o">  
```{r i2_i1_mask01, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE}

if (params$Agg == 1){rast_mask_proj <- rast_subdiv_mask_proj} else {
  rast_mask_proj <- aggregate(rast_subdiv_mask_proj, fact = params$Agg, expand = TRUE)}


g <- base_raster_plot(rast_mask_proj, "layer", 'red', 'blue', paste0("Aggregated mask - Resolution = ", res(rast_mask_proj), "m"))

gsubdivsimple <- add_subdiv_simple_plot(g)
gsubdivsimple

```
</div>

A factor is calculated to determine the area of each raster cell in hectares.

```{r i2_i1_mask02, cache = FALSE, warning=FALSE }

Stat_factor_ha <- ((xres(rast_mask_proj)^2) / 10000) # factor used for statistical calculations divides the area of a raster cell (in m2) by 10000 to give the area of the cell in hectares 

cat(paste(Stat_factor_ha, "hectares in each cell"))

```

This mask designates the locations where predictions should be made, and an empty dataframe (tibble) is created with records for all locations.


<div class="fold o">   
```{r i2_i1_mask03, cache = TRUE, cache.whatever=params$Agg, warning=FALSE }

# only run the models for the areas in the mask

df_irm_i2 <- geom(terra::as.points(rast_mask_proj)) %>% as_tibble()

x <-  pull(df_irm_i2, x)
y <-  pull(df_irm_i2, y)
xy <- cbind(x, y)

str(df_irm_i2)

if (params$INT == 1)
  shiny::setProgress(0.17, message = "Resampling data 1st Innovation")  # set progress to 17%
``` 
</div>


## Rough crop, Reproject, Aggregate and Resample

In this section the input spatial data are cropped to the extent of the sub-division boundary, projected if necessary and then aggregated and resampled if necessary.


```{r i2_i1_agg_resample_01, message=FALSE, warning=FALSE, cache=TRUE, out.width="100%", results='hide'}

# do a rough crop of the thematic data for the country extent in the CRS of the thematic data

for (i in seq(from = 1,
              to = nrow(df_raster_data),
              by = 1)) {
  
  temp_crs <- crs(get(paste0("rast_", df_raster_data[i, 11])))
  assign("vect_subdiv_temp_crs", terra::project(vect_subdiv, temp_crs))
  assign("vect_subdiv_temp_crs_extent", terra::ext(vect_subdiv_temp_crs))
    
  assign(
    paste0("rast_", df_raster_data[i, 11], "_roughcrop"),
    crop(get(paste0("rast_", df_raster_data[i, 11])),
      vect_subdiv_temp_crs_extent)
  )  
}

```



<div class="fold o">   
```{r i2_i1_agg_resample_02, cache = TRUE, out.width="100%", results='asis', warning=FALSE, message=FALSE}

# reproject the raster data if necessary

for (i in seq(from = 1,
              to = nrow(df_raster_data),
              by = 1)) {

# compare the crs of the raster with the working crs
# when different project the raster  
  
  if ( paste(crs(get(paste0("rast_", df_raster_data[i, 11])))) %ni% paste(wkt_lam)) {  
  
  cat("different crs - ")  
  assign(
    paste0("rast_", df_raster_data[i, 11], "_prj"),
    raster_project(
      get(paste0("rast_", df_raster_data[i, 11], "_roughcrop")),
      #proj4_lam,
      as.character(df_raster_data[i, 14])
    )
  )  
  
  } else {

   cat("same crs - ") 
# when not different just create a new raster with the same prj suffix  
    assign(
    paste0("rast_", df_raster_data[i, 11], "_prj"),
    get(paste0("rast_", df_raster_data[i, 11], "_roughcrop"))
      )
  }

# calculate aggregate factor for each criterion for both dimensions of the raster (these are the same for a square cell shape)
  
#  cat(paste(df_raster_data[i, 10],"\n"))

  calc_agg_factor <-
    (res(rast_mask_proj) / res(get(paste0(
      "rast_", df_raster_data[i, 11], "_prj"
    ))))
  cat(paste("calculated aggregate factor = ", calc_agg_factor))
  cat("\n")

 if (calc_agg_factor[1] < 1) {
    calc_agg_factor[1] <- 1
    
    # this means that the mask has a higher resolution than the precipitation raster so aggregation is not necessary and the precipitation raster will stay the same resolution
    
#    cat(paste("revised calculated aggregate factor 1 = ", calc_agg_factor[1],"\n"))
  }
  
  
  
  if (calc_agg_factor[2] < 1) {
    calc_agg_factor[2] <- 1
    cat(paste("revised calculated aggregate factor 2 = ", calc_agg_factor[2]))
  }
  
  # for each record in the df_raster_data data frame use the data file prefix to recreate the raster name, and the aggregation and resample functions
#  cat(paste("aggregate and resample"))
  assign(
    paste0("rast_", df_raster_data[i, 11], "_rsmp"),
    agg_resample(
      get(paste0("rast_", df_raster_data[i, 11], "_prj")),
      calc_agg_factor,
      as.character(df_raster_data[i, 13]),
      as.character(df_raster_data[i, 14])
    )
  )
  
#  plot_raster <-
    terra::plot(
      get(paste0("rast_", df_raster_data[i, 11], "_rsmp")),
      main = paste0(
        as.character(df_raster_data[i, 10]),
        "\nagg ",
        as.character(df_raster_data[i, 13]),
        " rsmp ",
        as.character(df_raster_data[i, 14])
      ),
      breaks = 10
   )
  #print(plot_raster)
  

  cat(paste("\nDim = ", dim(get(paste0("rast_", df_raster_data[i, 11], "_rsmp")))))
  cat("\n\n")

#  plot_raster
#  terra::plot(rast_mask_proj, title = "") # this is needed (even if it is not actually plotted) to enable the plot of the raster
  
}


```
</div>

# Requirements for successful production and adoption

In this section the requirements for production and adoption are given in terms of membership functions defined by fuzzy partitions. The membership functions are applied to the data, and can be considered as the lowest level rule bases - seen in the green boxes in the figure of the rule bases above.

The requirements are described and applied first for bio-physical criteria (if defined) and then for socio-economic criteria (if defined).

```{r i2_i1_requirements_themes, results='asis'}

# Each innovation has potentially different criteria and rule bases
# This chunk gets the unique themes which are organised around rule base stacks 
# This new data frame is used to see which themes have criteria for a particular innovation

n_theme <- length(rbstacklist3)

```

```{r i2_i1_requirements_ba01, echo=FALSE, results='asis', eval=ba_crit}

cat("## Bio-physical requirements")

```


```{r i2_i1_requirements_climatic01, echo=FALSE, results='asis', eval=clim_crit}

cat("### Climatic Requirements")

```

<div class="fold o">   
```{r i2_i1_requirements_climatic02, results='asis', eval=clim_crit}

df_criteria_ba3 <-
  subset(df_priorities, grepl("^ba_3", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cba3 <- nrow(df_criteria_ba3)
print(paste(n_cba3, "Climatic criteria: "))

for (i in 1:n_cba3) {
  print(paste(df_criteria_ba3[i, 4]))
  rast_clim_mask <- get(paste0("rast_",df_criteria_ba3[i, 11], "_rsmp"))
  if (paste(df_criteria_ba3[i, 23]) == "m") {
  rast_clim_mask_m <- rast_clim_mask
  names(rast_clim_mask_m) <- c(month.name)
  } else {
  rast_clim_mask_d <- rast_clim_mask
  names(rast_clim_mask_d) <- c(1:36)}
}

# then determine and print the names of the rule bases in the climatic theme
df_rulebases_ba3 <-
  distinct(df_criteria_ba3, rulebase_number, .keep_all = T)
n_rbba3 <- nrow(df_rulebases_ba3)

print(paste(n_rbba3, "Climatic rule bases:"))
for (i in 1:n_rbba3) {
  print(paste(df_rulebases_ba3[i, 2]))
  
  if (paste(df_rulebases_ba3[i, 2]) == "ba_3a") {
    prec_crit <- TRUE
    print("Precipitation criteria exist")
  } else {
    if (paste(df_rulebases_ba3[i, 2]) == "ba_3b") {
      tmp_crit <- TRUE
      print("Temperature criteria exist")
    }
  }
}

```
</div>   


```{r i2_i1_requirements_climatic03, echo=FALSE, results='asis', eval=clim_crit}

cat("If there are climatic criteria that are for specific growth stages and which use monthly or dekadal data then the phenological stages need to be distributed over those periods.")

```


<div class="fold o">   
```{r i2_i1_requirements_phen_stages01, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=clim_crit}

## division by zero rainfall is infinitive, thus edited by Atkilt

if (exists('rast_clim_mask_m')) {
  values(rast_clim_mask_m)[values(rast_clim_mask_m) >= 0] = 0
  values(rast_clim_mask_m)[values(rast_clim_mask_m) < 0] = NA
}

if (exists('rast_clim_mask_d')) {
  values(rast_clim_mask_d)[values(rast_clim_mask_d) >= 0] = 0
  values(rast_clim_mask_d)[values(rast_clim_mask_d) < 0] = NA
}

```
</div>


```{r i2_i1_growth_stages01, echo=FALSE, results='asis'}

cat("#### Growth Stages

Here we load the table of the growth stages.")

```


<div class="fold o"> 
```{r i2_i1_growth_stages02, results='asis'}

# get the growth stages filename using the innovation parameter
growth_stages_filename <-
  as.character(paste("tab_data/input/growth_stages_", params$INN2, ".csv", sep = ""))

df_growth_stages <-  read.csv(here(growth_stages_filename))

df_growth_stages %>%
  kable(digits = 3, caption = "Growth Stage Lengths") %>% kable_styling("striped", full_width = T) %>% print

# create a new table just for where growth stage has requirements
df_growth_stages_req <-
  dplyr::filter(df_growth_stages, (prec_criteria == 1 |
                                  temp_criteria == 1))
df_growth_stages_req_prec <-
  dplyr::filter(df_growth_stages, prec_criteria == 1)
df_growth_stages_req_temp <-
  dplyr::filter(df_growth_stages, temp_criteria == 1)

```
</div>

<div class="fold o"> 
```{r i2_i1_requirements_phen_stages_static01, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=clim_crit, eval=nonsos_crit}

# see if one of the criteria is for the total growing period, if so then generate distribution

# this uses two functions from the irm package called .growth_period_long (for monthly data) and .growth_period_long_dekad (for dekadal data)

# both functions take three arguments: day_begin, and day_end in day numbers (obtained from the growth_stages_req table) and num_years which is calculated based on whether the growing season is spread across more than one calendar year


# for each of the growth stages for which there are requirements create a new raster brick

cat("### Spatially Static Growing Seasons")

  # get the number of variables in growth_stages (excluding sowing/planting date and total length)
  
  # create a list of the growth stages and determine the start and end days of each growth period


phen_tmp <- list()
for (i in 1:(nrow(df_growth_stages) - 2)) {
  phen_tmp[[as.character(df_growth_stages[i + 1, 1])]] <-
    df_growth_stages[i + 1, 3]
}

phen_stages_beg <-
  df_growth_stages$day[1] + c(0, cumsum(phen_tmp)[-length(phen_tmp)])
phen_stages_end <- df_growth_stages$day[1] + cumsum(phen_tmp)
names(phen_stages_beg) <- names(phen_stages_end)

# add the total to the growth stages

phen_stages_beg[["total"]] <- df_growth_stages[1, 2]
phen_stages_end[["total"]] <-
  sum(df_growth_stages[1, 2], df_growth_stages[2, 3])

rbind(start = phen_stages_beg, end = phen_stages_end) %>%
  as.data.frame %>%
  kable(caption = "Growth Stage Days") %>% kable_styling("striped", full_width = T)  %>% print

num_years <- ceiling(phen_stages_end[["total"]] / 365)
cat(paste("Growth Stages span", num_years, "calendar years"))

```
</div>

<div class="fold o"> 
```{r i2_i1_requirements_phen_stages_static02, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=clim_crit, eval=nonsos_crit}

# monthly distribution
if (exists('rast_clim_mask_m')) {
  for (i in 1:(nrow(df_growth_stages_req))) {
    period_name <- as.character(df_growth_stages_req[i, 1])
    v_m <-
      .growth_period_long(phen_stages_beg[period_name], phen_stages_end[period_name], num_years)
    assign(paste0("rast_period_m_", df_growth_stages_req[i, 1]),
           rast_clim_mask_m %>%
             app(function(x) {
               ifelse(is.na(x), NA_real_, v_m)
             }))
    
#    plot_raster <-
      plot(
        get(paste0("rast_period_m_", df_growth_stages_req[i, 1])),
        maxnl = 12,
        breaks = c(0, 0.25, 0.5, 0.75, 1),
        axes = F,
        plg = list(cex = 1, title = paste0(df_growth_stages_req[i, 1]))
      )
#    print(plot_raster)
  }
}
# dekadal distribution
if (exists('rast_clim_mask_d')) {
  for (i in 1:(nrow(df_growth_stages_req))) {
    period_name <- as.character(df_growth_stages_req[i, 1])
    v_d <-
      .growth_period_long_dekad(phen_stages_beg[period_name], phen_stages_end[period_name], num_years)
    assign(paste0("rast_period_d_", df_growth_stages_req[i, 1]),
           rast_clim_mask_d %>%
             app(function(x) {
               ifelse(is.na(x), NA_real_, v_d)
             }))
    
#    plot_raster <-
      plot(
        get(paste0("rast_period_d_", df_growth_stages_req[i, 1])),
        maxnl = 36,
        breaks = c(0, 0.25, 0.5, 0.75, 1),
        axes = F,
        plg = list(cex = 1, title = paste0(df_growth_stages_req[i, 1]))
      )

  }
}

``` 
</div>

```{r i2_i1_requirements_sowing_dates_title, echo=FALSE, results='asis', eval=clim_crit,  eval=sos_crit}

cat("### Spatially Dynamic Growing Seasons")

```

```{r i2_i1_requirements_sowing_dates_intro, echo=FALSE, results='asis', eval=clim_crit,  eval=sos_crit}

cat("For climatic criteria for specific growth stages which use monthly or dekadal data, and which have a spatially variable growth period the phenological stages need to be distributed over those periods and spatially.\n
\n
\n
The maps below give the distribution of each phenological stage over the months.\n
\n
I use the same function as Walvoort (here called growth_period_long_tbl and growth_period_long_dekad_tbl), and apply this on a cell-by-cell basis using the start and end days for each cell.\n
\n
When the function is applied to the tibble using 'apply' it produces a x *x* 12/36 matrix. I transpose this matrix, append it to the original tibble and create a temporary data frame. I save this as a csv, convert this to a spatvector object and create spatrasters for each month/dekad *x* growing period combination. I join the individual rasters in a SpatRaster brick for each growing period - to be used later.")

```


<div class="fold o">   
```{r i2_i1_sowing_dates_sos_onsetdata_01, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=clim_crit, eval=sos_crit}


# get onset for area of interest
rast_filename_onset <-
  as.character(paste("spatial_data/input/rast_onset_",
                     params$INN2,
                     ".tif",
                     sep = ""))
assign(paste0("rast_onset"), rast(here(rast_filename_onset)))
names(rast_onset) <- c("onset")
rast_onset

g <- base_raster_plot(rast_onset, "onset", 'red', 'blue', "Season onset day number (rast_onset)" )

gsubdivsimple <- add_subdiv_simple_plot(g)
gsubdivsimple
```
</div>


<div class="fold o">   
```{r i2_i1_sowing_dates_sos_onsetdata_02, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=clim_crit, eval=sos_crit}

# project onset
rast_onset_proj <- project(rast_onset, rast_mask_proj, method = "near")
rast_onset_proj

g <- base_raster_plot(rast_onset_proj, "onset", 'red', 'blue', "Season onset day number (rast_onset_proj)" )

gsubdivsimple <- add_subdiv_simple_plot(g)
gsubdivsimple

```
</div>


<div class="fold o">   
```{r i2_i1_sowing_dates_sos_onsetdata_03, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=clim_crit, eval=sos_crit}

# do a rough crop to boundaries
rast_onset_crop <- crop(rast_onset_proj, rast_mask_proj)
rast_onset_crop

g <- base_raster_plot(rast_onset_crop, "onset", 'red', 'blue', "Season onset day number (rast_onset_crop)" )

gsubdivsimple <- add_subdiv_simple_plot(g)
gsubdivsimple

```
</div>


<div class="fold o">   
```{r i2_i1_sowing_dates_sos_onsetdata_04, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=clim_crit, eval=sos_crit}

rast_onset_crop_rsmp <- resample(rast_onset_crop, rast_mask_proj,  method="near")
rast_onset_crop_rsmp


g <- base_raster_plot(rast_onset_crop_rsmp, "onset", 'red', 'blue', "Season onset day number (rast_onset_crop_rsmp)" )

gsubdivsimple <- add_subdiv_simple_plot(g)
gsubdivsimple
```
</div>

<div class="fold o">   
```{r i2_i1_sowing_dates_sos_onsetdata_05, cache = TRUE, cache.whatever=params$Agg, out.width="100%", warning=FALSE, eval=clim_crit, eval=sos_crit}

# convert to df
df_onset <- as.data.frame(rast_onset_crop_rsmp, xy=TRUE, cells=TRUE, na.rm=NA)
df_onset <- mutate(df_onset, onset = as.integer(onset))

```

<div class="fold o">   
```{r i2_i1_sowing_dates_sos_transpose, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=clim_crit, eval=sos_crit}

df_growth_stages_lengths <- df_growth_stages[-1, ]
#df_growth_stages_lengths

df_growth_stages_lengths1 <- t(select(df_growth_stages_lengths, name, length)) %>% data.frame()
#df_growth_stages_lengths1

df_growth_stages_lengths2 <- setNames(df_growth_stages_lengths1, df_growth_stages_lengths[,1])
#df_growth_stages_lengths2

df_growth_stages_lengths3 <- df_growth_stages_lengths2[-1, ] 
#df_growth_stages_lengths3

df_growth_stages_lengths3[] <- lapply(df_growth_stages_lengths3, as.integer)
df_growth_stages_lengths3 %>%
  kable(caption = "Growth Stage Days") %>% kable_styling("striped", full_width = T)  #%>% print

```
</div>


</div> 

<div class="fold o">   
```{r i2_sowing_dates_sos_onsetdata_06, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=clim_crit, eval=sos_crit}

# add the growth stage lengths to the df
for (i in 1:(nrow(df_growth_stages_lengths))) {
  period_name <- as.character(df_growth_stages_lengths[i, 1])
#  cat(paste(period_name))
#  cat(eval(parse(text = paste0("df_growth_stages_lengths3$", period_name))))
  df_onset <-  mutate(df_onset, !!as.character(paste0(period_name,"_l")) :=  eval(parse(text = paste0("df_growth_stages_lengths3$", period_name))), .keep = c("all"))
} 


# add the start day for the first growth stage (which is the onset)

first_period_name <- as.character(df_growth_stages_lengths[1, 1])
#cat(paste(first_period_name))
df_onset <-
  mutate(df_onset,!!as.character(paste0(first_period_name, "_s")) :=  eval(parse(text = paste0(
    "df_onset$onset"
  ))),
  .keep = c("all"))

# add the start days for each of the growth stages (excluding the first which is the onset)

for (i in 1:(nrow(df_growth_stages_lengths)- 2) ) {
  
#  cat(paste(i))
      
  previous_period_name <- as.character(df_growth_stages_lengths[i, 1])
#  cat(paste("Prev = ", previous_period_name))
#  cat("\n")
  period_name <- as.character(df_growth_stages_lengths[i + 1, 1])
#  cat(paste("Current = ", period_name))
#  cat("\n")
#  cat(paste0("df_growth_stages_lengths3$", period_name))
#  cat(paste(parse(text =paste0("df_onset$", previous_period_name,"_s"))))
#  cat("\n")
#  cat(paste(parse(text =paste0("df_onset$", previous_period_name,"_l"))))
#  cat("\n\n")
 
eval_expr_1 <- eval(parse(text =paste0("df_onset$", previous_period_name, "_s + df_onset$", previous_period_name,"_l")))

  df_onset <-
    mutate(df_onset, !!as.character(paste0(period_name, "_s")) :=  eval_expr_1,
           .keep = c("all"))

}

# add the end days for each of the growth stages

for (i in 1:(nrow(df_growth_stages_lengths) - 1) ) {
  
#  cat(paste(i))
      
#  previous_period_name <- as.character(df_growth_stages_lengths[i, 1])
#  cat(paste("Prev = ", previous_period_name))
#  cat("\n")
  period_name <- as.character(df_growth_stages_lengths[i, 1])
#  cat(paste("Current = ", period_name))
#  cat("\n")
#  cat(paste0("df_growth_stages_lengths3$", period_name))
#  cat(paste(parse(text =paste0("df_onset$", period_name,"_s"))))
#  cat("\n")
#  cat(paste(parse(text =paste0("df_onset$", period_name,"_l"))))
#  cat("\n\n")
 
eval_expr_2 <- eval(parse(text =paste0("df_onset$", period_name, "_s + df_onset$", period_name,"_l - 1")))

  df_onset <-
    mutate(df_onset, !!as.character(paste0(period_name, "_e")) :=  eval_expr_2,
           .keep = c("all"))

}  
  
onset_max <- max(select(df_onset, -cell, -x, -y)) # gets the maximum value of the julian day numbers
num_years <- max(ceiling(onset_max / 365))

cat(paste("Growth Stages span", num_years, "calendar years"))

```
</div>

<div class="fold o">
```{r i2_sowing_dates_sos_maps_m, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=clim_crit, eval=sos_crit}

# to reduce unnecessary processing follow these steps
# for each growth stage:

# (1) does the monthly and/or dekad raster mask exist on file?
#   YES - (i) load raster file to env
#         (ii) plot raster file
#         (iii) move to next growth stage or next chunk
#   NO -  (i) go to (2)

# (2) does the monthly and/or dekad raster mask csv exist on file?
#   YES - (i) load csv file to env as vect
#         (ii) rasterize vect
#         (iii) write raster to file
#         (iv) go to (1)
#   NO -  (i) go to (3)

# (3) does the monthly and/or dekad raster mask df exist in the env?
#   YES - (i) write df to file as csv
#         (ii) go to (2)
#   NO -  (i) go to (4)

# (4) does the monthly and/or dekad raster mask matrix exist in the env?
#   YES - (i) join the matrix to the onset df
#         (ii) write df to file as csv
#         (iii) go to (3)
#   NO -  (i) create the matrix using the growth_period_long functions
#         (ii) join the matrix to the onset df
#         (iii) go to (4)

if (exists('rast_clim_mask_m')) {
  cat(paste("\n1 Monthly data exist"))
    
  # set static vectors of days and months
  days <- 1:365
  day_months <- days %>% as.character %>% as.Date("%j") %>% 
    format("%m") %>% as.integer
  months <- rep.int(day_months, num_years)
  
  
  for (i in 1:(nrow(df_growth_stages_lengths))) {
    period_name <- as.character(df_growth_stages_lengths[i, 1])
    cat(paste("\nCurrent growth stage = ", period_name))
    
    rast_filename_m <-
      as.character(paste0(
        "spatial_data/output/rast_",
        period_name,
        "_m_",
        params$INN2, "_", params$MASK,
        ".tif"
      ))
    
    if (!file.exists(here(rast_filename_m))) {
      cat(paste("\n2 No spatraster"))
      
      if (!exists(paste0("vect_", period_name, "_m"))) {
        cat(paste("\n3 No spatvector"))
        
        csv_filename_m <-
          as.character(
            paste(
              "tab_data/output/df_onset_",
              period_name,
              "_m_",
              params$INN2, "_", params$MASK,
              ".csv",
              sep = ""
            )
          )
        
        if (!file.exists(here(csv_filename_m))) {
          cat(paste("\n4 No csv data"))
          
          if (!exists(paste0("df_onset_", period_name, "_m"))) {
            cat(paste("\n5 No df"))
            
            if (!exists(paste0(period_name, "_matrix_days_m"))) {
              cat(paste("\n6 No matrix"))
              
              if (period_name == "total") {
                expr_3_m <- parse(
                  text = paste0(
                    "t(apply(df_onset, 1, .growth_period_long_tbl_short, day_begin = \"onset\", day_end = \"",
                    df_growth_stages_lengths[nrow(df_growth_stages_lengths) - 1, 1],
                    "_e\", num_years = num_years))"
                  )
                )
              } else {
                expr_3_m <- parse(
                  text = paste0(
                    "t(apply(df_onset, 1, .growth_period_long_tbl_short, day_begin = \"",
                    period_name,
                    "_s\",
        day_end = \"",
        period_name,
        "_e\", num_years = num_years))"
                  )
                )
              }
              
              assign(paste0(period_name, "_matrix_days_m"),
                     eval(expr_3_m))
                            
                            expr_3_m2 <- parse(
                  text = paste0(period_name, "_matrix_days_m * 1000"))
              
              assign(paste0(period_name, "_matrix_days_m"), eval(expr_3_m2))
              
              eval(parse(text = paste0(
                "mode(", period_name, "_matrix_days_m) <- \"integer\""
              )))
              
              cat(paste("\n-6"))
            }
            
            
            assign(paste0("df_onset_", period_name, "_m"),
                   data.frame(df_onset, get(
                     paste0(period_name, "_matrix_days_m")
                   )))
            
            cat(paste("\n-5"))
          }
          
          rm(list = paste0(period_name, "_matrix_days_m")) # remove matrix when df created
          
          write.csv(get(paste0("df_onset_", period_name, "_m")),
                    here(csv_filename_m))
          
          cat(paste("\n-4"))
        }
        rm(list = paste0("df_onset_", period_name, "_m")) # remove df when csv created
        assign(paste0("vect_", period_name, "_m"),
               vect(
                 read_csv(here(csv_filename_m), show_col_types = FALSE),
                 geom = c("x", "y"),
                 crs = wkt_lam
               ))
        cat(paste("\n-3"))
      }
      
      
      assign(paste0("list_rast_", period_name, "_m"),
             list())
      
      #create an empty raster
      assign(paste0("rast_", period_name, "_m"), rast())
      
      for (j in 1:12) {
        assign(
          paste0("rast_", period_name, "_m_", j),
          rasterize(get(
            paste0("vect_", period_name, "_m")
          ), rast_clim_mask_m, field = paste0("X", j))
        )
        
        assign(paste0("list_rast_", period_name, "_m"),
               append(get(
                 paste0("list_rast_", period_name, "_m")
               ), paste0("rast_", period_name, "_m_", j)))
        expr_5_m <-
          parse(text = paste0(
            "add(rast_",
            period_name,
            "_m) <- (rast_",
            period_name,
            "_m_",
            j,
            ")"
          ))
        
        eval(expr_5_m)
        rm(list = paste0("rast_", period_name, "_m_", j)) # remove month rast when added to brick
      }
      
      rm(list = paste0("vect_", period_name, "_m")) # remove vect when raster created
      writeRaster(get(paste0("rast_", period_name, "_m")), here(rast_filename_m), overwrite = TRUE)
      cat(paste("\n-2"))
    }
    
    assign(paste0("rast_", period_name, "_m"), rast(here(rast_filename_m)))
    cat(paste0("\n", rast_filename_m))
    
    expr_6_m <-
      parse(
        text = paste0(
          "names(rast_",
          period_name,
          "_m) <- c(\"January\", \"February\", \"March\", \"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\")"
        )
      )
    
    eval(expr_6_m)
    
#    plot(
#      get(paste0("rast_", period_name, "_m")),
#      maxnl = 12,
#      breaks = c(0, 0.25, 0.5, 0.75, 1),
#      axes = F,
#      plg = list(cex = 1, title = paste0(period_name))
#    )
    
  }
  cat(paste("\n-1"))
}

```
</div>

<div class="fold o">
```{r i2_sowing_dates_sos_maps_d, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=clim_crit, eval=sos_crit}

# to reduce unnecessary processing follow these steps
# for each growth stage:

# (1) does the monthly and/or dekad raster mask exist on file?
#   YES - (i) load raster file to env
#         (ii) plot raster file
#         (iii) move to next growth stage or next chunk
#   NO -  (i) go to (2)

# (2) does the monthly and/or dekad raster mask csv exist on file?
#   YES - (i) load csv file to env as vect
#         (ii) rasterize vect
#         (iii) write raster to file
#         (iv) go to (1)
#   NO -  (i) go to (3)

# (3) does the monthly and/or dekad raster mask df exist in the env?
#   YES - (i) write df to file as csv
#         (ii) go to (2)
#   NO -  (i) go to (4)

# (4) does the monthly and/or dekad raster mask matrix exist in the env?
#   YES - (i) join the matrix to the onset df
#         (ii) write df to file as csv
#         (iii) go to (3)
#   NO -  (i) create the matrix using the growth_period_long functions
#         (ii) join the matrix to the onset df
#         (iii) go to (4)


if (exists('rast_clim_mask_d')) {
  cat(paste("\n1 Dekad data exist"))
  
  # set static vectors of days and dekads
  days <- 1:365
  day_dekads <- days %>% as.character %>% as.Date("%j") %>%
    dekad(type = "year") %>% as.integer
  dekads <- rep.int(day_dekads, num_years)
  
  
  for (i in 1:(nrow(df_growth_stages_lengths))) {
    period_name <- as.character(df_growth_stages_lengths[i, 1])
    cat(paste("\nCurrent growth stage = ", period_name))
    
    
    rast_filename_d <-
      as.character(paste0(
        "spatial_data/output/rast_",
        period_name,
        "_d_",
        params$INN2, "_", params$MASK, 
        ".tif"
      ))
    
    if (!file.exists(here(rast_filename_d))) {
      cat(paste("\n2 No spatraster"))
      
      if (!exists(paste0("vect_", period_name, "_d"))) {
        cat(paste("\n3 No spatvector"))
        
        csv_filename_d <-
          as.character(
            paste(
              "tab_data/output/df_onset_",
              period_name,
              "_d_",
              params$INN2, "_", params$MASK,
              ".csv",
              sep = ""
            )
          )
        
        if (!file.exists(here(csv_filename_d))) {
          cat(paste("\n4 No csv data"))
          
          if (!exists(paste0("df_onset_", period_name, "_d"))) {
            cat(paste("\n5 No df"))
            
            if (!exists(paste0(period_name, "_matrix_days_d"))) {
              cat(paste("\n6 No matrix"))
              
              if (period_name == "total") {
                expr_3_d <- parse(
                  text = paste0(
                    "t(apply(df_onset, 1, .growth_period_long_dekad_tbl_short, day_begin = \"onset\", day_end = \"",
                    df_growth_stages_lengths[nrow(df_growth_stages_lengths) - 1, 1],
                    "_e\", num_years = num_years))"
                  )
                )
              } else {
                expr_3_d <- parse(
                  text = paste0(
                    "t(apply(df_onset, 1, .growth_period_long_dekad_tbl_short, day_begin = \"",
                    period_name,
                    "_s\",
        day_end = \"",
        period_name,
        "_e\", num_years = num_years))"
                  )
                )
              }
              
              assign(paste0(period_name, "_matrix_days_d"),
                     eval(expr_3_d))
              expr_3_d2 <- parse(
                  text = paste0(period_name, "_matrix_days_d * 1000"))
              
              assign(paste0(period_name, "_matrix_days_d"), eval(expr_3_d2))
              
              eval(parse(text = paste0(
                "mode(", period_name, "_matrix_days_d) <- \"integer\""
              )))
              
              cat(paste("\n-6"))
            }
            
            assign(paste0("df_onset_", period_name, "_d"),
                   data.frame(df_onset, get(
                     paste0(period_name, "_matrix_days_d")
                   )))
            
            cat(paste("\n-5"))
          }
          rm(list = paste0(period_name, "_matrix_days_d")) # remove matrix when df created
          write.csv(get(paste0("df_onset_", period_name, "_d")),
                    here(csv_filename_d))
          
          cat(paste("\n-4"))
        }
        rm(list = paste0("df_onset_", period_name, "_d")) # remove df when csv created
        assign(paste0("vect_", period_name, "_d"),
               vect(
                 read_csv(here(csv_filename_d), show_col_types = FALSE),
                 geom = c("x", "y"),
                 crs = wkt_lam
               ))
        cat(paste("\n-3"))
      }
      assign(paste0("list_rast_", period_name, "_d"),
             list())
      
      #create an empty raster
      assign(paste0("rast_", period_name, "_d"), rast())
      
      for (j in 1:36) {
        assign(
          paste0("rast_", period_name, "_d_", j),
          rasterize(get(
            paste0("vect_", period_name, "_d")
          ), rast_clim_mask_d, field = paste0("X", j))
        )
        
        assign(paste0("list_rast_", period_name, "_d"),
               append(get(
                 paste0("list_rast_", period_name, "_d")
               ), paste0("rast_", period_name, "_d_", j)))
        expr_5_d <-
          parse(text = paste0(
            "add(rast_",
            period_name,
            "_d) <- (rast_",
            period_name,
            "_d_",
            j,
            ")"
          ))
        
        eval(expr_5_d)
        rm(list = paste0("rast_", period_name, "_d_", j)) # remove dekad rast when added to brick
        
      }
      
      rm(list = paste0("vect_", period_name, "_d")) # remove vect when raster created
      writeRaster(get(paste0("rast_", period_name, "_d")), here(rast_filename_d), overwrite = TRUE)
      cat(paste("\n-2"))
    }
    
    assign(paste0("rast_", period_name, "_d"), rast(here(rast_filename_d)))
    cat(paste0("\n", rast_filename_d))
    
    expr_6_d <-
      parse(
        text = paste0(
          "names(rast_",
          period_name,
          "_d) <- c(\"Ja1\", \"Ja2\", \"Ja3\", \"Fe1\", \"Fe2\", \"Fe3\",\"Mr1\", \"Mr2\", \"Mr3\",\"Ap1\", \"Ap2\", \"Ap3\",\"My1\", \"My2\", \"My3\",\"Jn1\", \"Jn2\", \"Jn3\",\"Jl1\",\"Jl2\", \"Jl3\",\"Ag1\",\"Ag2\", \"Ag3\",\"Sp1\",\"Sp2\", \"Sp3\",\"Oc1\",\"Oc2\", \"Oc3\",\"No1\",\"No2\", \"No3\",\"De1\",\"De2\", \"De3\")"
        )
      )
    
    eval(expr_6_d)
    
#    plot(
#      get(paste0("rast_", period_name, "_d")),
#      maxnl = 36,
#      breaks = c(0, 0.25, 0.5, 0.75, 1),
#      axes = F,
#      plg = list(cex = 1, title = paste0(period_name))
#    )
    
  }
  cat(paste("\n-1"))
}

```
</div>

<div class="fold o">   
```{r i2_requirements_phen_stages01_sos_m, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=clim_crit, eval=sos_crit}

##-- monthly distribution --

if (exists('rast_clim_mask_m')) {
  for (i in 1:(nrow(df_growth_stages_req))) {
    period_name <- as.character(df_growth_stages_req[i, 1])
    cat("period_name = ", period_name, "\n")
    
    
    # load growth period rasters
    rast_filename_m <-
      as.character(paste0(
        "spatial_data/output/rast_",
        period_name,
        "_m_",
        params$INN2, "_", params$MASK,
        ".tif"
      ))
    
    assign(paste0("rast_period_m_", period_name, "_original"),
           rast(here(rast_filename_m))/1000) # divide by 1000 because the values were multiplied by 1000 when creating the matrix
    
    # reproject growth period rasters
    
    assign(
      paste0("rast_period_m_", period_name, "_prj"),
      terra::project(get(
        paste0("rast_period_m_", period_name, "_original")
      ),   rast_mask_proj, "near")
    )
    
    # aggregate if necessary
    
    #calc_agg_factor_m <-
    #    (res(rast_mask_proj) / res(rast_period_m_total_prj))
    #  cat(paste("calculated aggregate factor m = ", calc_agg_factor_m))
    
    calc_agg_factor_m <-
      (res(rast_mask_proj) / res(get(
        paste0("rast_period_m_", period_name, "_prj")
      )))
    
    cat(paste("calculated aggregate factor m = ", calc_agg_factor_m))
    
    
    if (calc_agg_factor_m[1] < 1) {
      calc_agg_factor_m[1] <- 1
      
      # this means that the mask has a higher resolution than the precipitation raster so aggregation is not necessary and the precipitation raster will stay the same resolution
      
      cat(paste(
        "revised calculated aggregate factor m1 = ",
        calc_agg_factor_m[1]
      ))
    }
    cat("\n")
    
    if (calc_agg_factor_m[2] < 1) {
      calc_agg_factor_m[2] <- 1
      cat(paste(
        "revised calculated aggregate factor m2 = ",
        calc_agg_factor_m[2]
      ))
    }
    
    # resample
    
    cat(paste("aggregate and resample"))
    
    #    rast_period_m_total <-
    #    agg_resample(
    #      rast_period_m_total_prj,
    #      calc_agg_factor_m, "modal", "near")
    
    assign(
      paste0("rast_period_m_", period_name),
      agg_resample(get(
        paste0("rast_period_m_", period_name, "_prj")
      ),
      calc_agg_factor_m, "modal", "near")
    )
    
    # plot
    
    expr_7_m <-
      parse(
        text = paste0(
          "names(rast_period_m_",
          period_name,
          ") <- c(\"January\", \"February\", \"March\", \"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\")"
        )
      )
    
    eval(expr_7_m)
    plot(
      get(paste0("rast_period_m_", period_name)),
      maxnl = 12,
      breaks = c(0, 0.25, 0.5, 0.75, 1),
      axes = F,
      plg = list(cex = 1, title = paste0(period_name))
    )
    
  }
}

```  
</div>    
 
<div class="fold o">   
```{r i2_requirements_phen_stages01_sos_d, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=clim_crit, eval=sos_crit}

# dekadal growth stages have been pre-modelled for the spatial onset of season

# for each of the growth stages for which there are requirements create a new raster brick

##-- dekadal distribution --


if (exists('rast_clim_mask_d')) {
  for (i in 1:(nrow(df_growth_stages_req))) {
    period_name <- as.character(df_growth_stages_req[i, 1])
    cat("period_name = ", period_name, "\n")
    
    
    # load growth period rasters
    rast_filename_d <-
      as.character(paste0(
        "spatial_data/output/rast_",
        period_name,
        "_d_",
        params$INN2, "_", params$MASK,
        ".tif"
      ))
    
    assign(paste0("rast_period_d_", period_name, "_original"),
           rast(here(rast_filename_d))/1000) # divide by 1000 because the values were multiplied by 1000 when creating the matrix
    
    # reproject growth period rasters
    
    assign(
      paste0("rast_period_d_", period_name, "_prj"),
      terra::project(get(
        paste0("rast_period_d_", period_name, "_original")
      ),   rast_mask_proj, "near")
    )
    
    # aggregate if necessary
    
    #calc_agg_factor_d <-
    #    (res(rast_mask_proj) / res(rast_period_d_total_prj))
    #  cat(paste("calculated aggregate factor m = ", calc_agg_factor_d))
    
    calc_agg_factor_d <-
      (res(rast_mask_proj) / res(get(
        paste0("rast_period_d_", period_name, "_prj")
      )))
    
    cat(paste("calculated aggregate factor d = ", calc_agg_factor_d))
    
    
    if (calc_agg_factor_d[1] < 1) {
      calc_agg_factor_d[1] <- 1
      
      # this means that the mask has a higher resolution than the precipitation raster so aggregation is not necessary and the precipitation raster will stay the same resolution
      
      cat(paste(
        "revised calculated aggregate factor d1 = ",
        calc_agg_factor_d[1]
      ))
    }
    cat("\n")
    
    if (calc_agg_factor_d[2] < 1) {
      calc_agg_factor_d[2] <- 1
      cat(paste(
        "revised calculated aggregate factor d2 = ",
        calc_agg_factor_d[2]
      ))
    }
    
    # resample
    
    cat(paste("aggregate and resample"))
    
    #    rast_period_d_total <-
    #    agg_resample(
    #      rast_period_d_total_prj,
    #      calc_agg_factor_d, "modal", "near")
    
    assign(
      paste0("rast_period_d_", period_name),
      agg_resample(get(
        paste0("rast_period_d_", period_name, "_prj")
      ),
      calc_agg_factor_d, "modal", "near")
    )
    
    # plot
    
    expr_7_d <-
      parse(
        text = paste0(
          "names(rast_period_d_",
          period_name,
          ") <- c(\"Ja1\", \"Ja2\", \"Ja3\", \"Fe1\", \"Fe2\", \"Fe3\",\"Mr1\", \"Mr2\", \"Mr3\",\"Ap1\", \"Ap2\", \"Ap3\",\"My1\", \"My2\", \"My3\",\"Jn1\", \"Jn2\", \"Jn3\",\"Jl1\",\"Jl2\", \"Jl3\",\"Ag1\",\"Ag2\", \"Ag3\",\"Sp1\",\"Sp2\", \"Sp3\",\"Oc1\",\"Oc2\", \"Oc3\",\"No1\",\"No2\", \"No3\",\"De1\",\"De2\", \"De3\")"
        )
      )
    
    eval(expr_7_d)
    plot(
      get(paste0("rast_period_d_", period_name)),
      maxnl = 36,
      breaks = c(0, 0.25, 0.5, 0.75, 1),
      axes = F,
      plg = list(cex = 1, title = paste0(period_name))
    )
    
  }
}

```     
    
 
</div>

```{r i2_requirements_prec01, echo=FALSE, results='asis', eval=prec_crit, eval=clim_crit}

cat("#### Precipitation

By combining precipitation in each month and the phenological stages above, we can derive the precipitation for each phenological stage that has requirements.")

```


<div class="fold o">   
```{r i2_requirements_prec02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=prec_crit, eval=clim_crit}

df_criteria_ba3a <-
    dplyr::filter(df_criteria_ba3, grepl("^ba_3a", rulebase_stack) & temp_resolution == "m") # filter precipitation criteria
  
  for (i in 1:nrow(df_growth_stages_req_prec)) {
        period_name <- as.character(df_growth_stages_req_prec[i, 1])
#      print(period_name)
      if (sum(df_criteria_ba3a[i, 'phen_stage'] == period_name, na.rm = TRUE) == 1) {
        print(paste0("period_name = ", as.character(period_name)))
        crit_rownum <-
          which(df_criteria_ba3a$phen_stage == period_name)
        assign(paste0("rast_",df_criteria_ba3a[crit_rownum, 11], "_rsmp_", df_growth_stages_req_prec[i, 1]),
               sum(get(
                 paste0("rast_",df_criteria_ba3a[crit_rownum, 11], "_rsmp")
               ) * get(
                 paste0("rast_period_", df_growth_stages_req_prec[i, 1])
               )))
        print(paste0("rast_", df_criteria_ba3a[crit_rownum, 11], "_rsmp_", df_growth_stages_req_prec[i, 1]))
#        plot_raster <-
          plot(get(
            paste0("rast_", df_criteria_ba3a[crit_rownum, 11], "_rsmp_", df_growth_stages_req_prec[i, 1])
          ),
          main = paste0("rast_period_m_",
                         as.character(df_growth_stages_req_prec[i, 1])))
#        print(plot_raster)
        
        
        new_col <-
          get(paste0("rast_", df_criteria_ba3a[crit_rownum, 11], "_rsmp_", df_growth_stages_req_prec[i , 1])) %>% terra::extract(xy) # extract the raster values using xy points
        
        new_col <- new_col[[1]]
        
        df_irm_i2 <- dplyr::select(df_irm_i2, -any_of(c(as.character(paste0(df_criteria_ba3a[crit_rownum, 3]))))) # remove column if name already exists
        
        df_irm_i2 <-
          mutate(df_irm_i2,!!as.character(paste0(df_criteria_ba3a[crit_rownum, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm_i2 tibble, this needs to be dynamic so uses the !! and := operators
        
        
      } else {
        print(sum(df_criteria_ba3a[, 'phen_stage'] == period_name, na.rm = TRUE))
      }
    }

df_criteria_ba3a <-
    dplyr::filter(df_criteria_ba3, grepl("^ba_3a", rulebase_stack) & temp_resolution == "d") # filter precipitation criteria
  
  for (i in 1:nrow(df_growth_stages_req_prec)) {
        period_name <- as.character(df_growth_stages_req_prec[i, 1])
#      print(period_name)
      if (sum(df_criteria_ba3a[i, 'phen_stage'] == period_name, na.rm = TRUE) == 1) {
        print(paste0("period_name = ", as.character(period_name)))
        crit_rownum <-
          which(df_criteria_ba3a$phen_stage == period_name)
        assign(paste0("rast_", df_criteria_ba3a[crit_rownum, 11], "_rsmp_", df_growth_stages_req_prec[i, 1]),
               sum(get(
                 paste0("rast_", df_criteria_ba3a[crit_rownum, 11], "_rsmp")
               ) * get(
                 paste0("rast_period_d_", df_growth_stages_req_prec[i, 1])
               )))
        print(paste0("rast_", df_criteria_ba3a[crit_rownum, 11], "_rsmp_", df_growth_stages_req_prec[i, 1]))
#        plot_raster <-
          plot(get(
            paste0("rast_", df_criteria_ba3a[crit_rownum, 11], "_rsmp_", df_growth_stages_req_prec[i, 1])
          ),
          main = paste0("rast_period_d_",
                         as.character(df_growth_stages_req_prec[i, 1])))
#        print(plot_raster)
        
        
        new_col <-
          get(paste0("rast_", df_criteria_ba3a[crit_rownum, 11], "_rsmp_", df_growth_stages_req_prec[i , 1])) %>% terra::extract(xy) # extract the raster values using xy points
        
        new_col <- new_col[[1]]
        
        df_irm_i2 <- dplyr::select(df_irm_i2, -any_of(c(as.character(paste0(df_criteria_ba3a[crit_rownum, 3]))))) # remove column if name already exists
        
        df_irm_i2 <-
          mutate(df_irm_i2,!!as.character(paste0(df_criteria_ba3a[crit_rownum, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm_i2 tibble, this needs to be dynamic so uses the !! and := operators
        
        
      } else {
        print(sum(df_criteria_ba3a[, 'phen_stage'] == period_name, na.rm = TRUE))
      }
    }

``` 
</div>

```{r i2_requirements_prec03, echo=FALSE, results='asis', eval=prec_crit, eval=clim_crit}

cat("##### Precipitation optimality

We used the requirements to construct fuzzy partitions and the rulebases.")

```


<div class="fold o">   
```{r i2_requirements_prec04, cache = TRUE, cache.whatever=params$Agg, out.width="100%", fig.show="hold", warning=FALSE, eval=prec_crit, eval=clim_crit}

for (i in 1:(nrow(df_criteria_ba3a))) {
  if (!is.na(df_criteria_ba3a[i, 18])) {
    # for those criteria with three proposition values
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_criteria_ba3a[i, 16]),
        as.character(df_criteria_ba3a[i, 17]),
        as.character(df_criteria_ba3a[i, 18])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        as.character(df_criteria_ba3a[i, 19]),
        as.character(df_criteria_ba3a[i, 20]),
        as.character(df_criteria_ba3a[i, 21])
      )
    # get  the 2 crossover points
    cross_points <-
      c(df_criteria_ba3a[i, 6],
        df_criteria_ba3a[i, 7])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_criteria_ba3a[i, 8],
        df_criteria_ba3a[i, 9])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_criteria_ba3a[i, 6] - df_criteria_ba3a[i, 8]),
        (df_criteria_ba3a[i, 7] + df_criteria_ba3a[i, 9]))
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    prop_levels <-
      c(as.character(df_criteria_ba3a[i, 16]),
        as.character(df_criteria_ba3a[i, 17]))
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(as.character(df_criteria_ba3a[i, 19]),
        as.character(df_criteria_ba3a[i, 20]))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_criteria_ba3a[i, 6])
    
    # get  the 1 transition width
    trans_width <-
      c(df_criteria_ba3a[i, 8])
    
    # get  the 1 xlim for the plot
    plot_xlim <-
      c((df_criteria_ba3a[i, 6] - df_criteria_ba3a[i, 8]),
        (df_criteria_ba3a[i, 6] + df_criteria_ba3a[i, 8]))
    
  }
  assign(
    paste0("fp_", df_criteria_ba3a[i, 3]),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  plot_fp <-
    plot(
      get(paste0("fp_", df_criteria_ba3a[i, 3])),
      xlim = plot_xlim,
      xlab = as.character(df_criteria_ba3a[i, 4]),
      title = "fuzzy partition"
    )
  print(plot_fp)
  
  # construct the rule bases
  
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_ba3a[i, 3]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_criteria_ba3a[i, 3]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                df_criteria_ba3a[i, 3]),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0("rb_",
                   df_criteria_ba3a[i, 3])))
  
  # apply the fuzzy partitions to the data
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    df_criteria_ba3a[i, 3],
    ", newdata = df_irm_i2,",
    df_criteria_ba3a[i, 3],
    "=",
    "fp_",
    df_criteria_ba3a[i, 3],
    ")"
  )
  
  
  assign(paste0("fpm_",
                df_criteria_ba3a[i, 3]), eval(parse(text = x)))
  
  
  o_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba3a[i, 3]))$optimal)
  s_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba3a[i, 3]))$suboptimal)
  df_irm_i2 <-
    mutate(df_irm_i2,!!as.character(paste0(df_criteria_ba3a[i, 3], "_o")) := o_col, .keep = c("all"))
  df_irm_i2 <-
    mutate(df_irm_i2,!!as.character(paste0(df_criteria_ba3a[i, 3], "_s")) := s_col, .keep = c("all"))
  
  n <- 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_ba3a[i, 3], "_o")), as.character(paste0(df_criteria_ba3a[i, 3], "_s")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_ba3a[i, 4], " optimal")), as.character(paste0(df_criteria_ba3a[i, 4], " suboptimal")))
  fpm_plot_title <-
    "Precipitation growth\nstages optimality\nmembership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
  print(plot_fpm)
  
  
}

``` 
</div>

```{r i2_requirements_temp01, echo=FALSE, results='asis', eval=tmp_crit, eval=clim_crit}

cat("#### Temperature

By combining temperature in each month and the phenological stages above, we can derive the temperature for each phenological stage that has requirements.")

```

<div class="fold o">   
```{r i2_requirements_temp02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=temp_crit, eval=clim_crit}

#df_criteria_ba3b <-
#    subset(df_criteria_ba3,
#           grepl("^ba_3b", df_criteria_ba3$rulebase_stack)) # subset temperature criteria

df_criteria_ba3b_m <-
    dplyr::filter(df_criteria_ba3, grepl("^ba_3b", rulebase_stack) & temp_resolution == "m") # filter temperature criteria

# A Farrow 01/06/2023 the following assumes that there is only one temperature criterion per growth stage
# In fact there may be multiple so a different way of looping through the criteria is needed


if (nrow(df_criteria_ba3b_m) > 0) {
  for (i in 1:nrow(df_growth_stages_req_temp)) {
      period_name <- as.character(df_growth_stages_req_temp[i, 1])
     # print(paste0("m period_name = ", as.character(period_name)))
     # print(df_criteria_ba3b_m[i, 'phen_stage'])
     # print(sum(df_criteria_ba3b_m[i, 'phen_stage'] == period_name))
      
      if (sum(df_criteria_ba3b_m[i, 'phen_stage'] == period_name, na.rm = TRUE) == 1) {
        print(paste0("m period_name = ", as.character(period_name)))
        
        # get criterion row number for the specific growth stage
        
        crit_rownum <-
          which(df_criteria_ba3b_m$phen_stage == period_name)
        
        # add another for loop if more than one value in crit_rownum vector
        
        for (j in 1:length(crit_rownum)) {
        
        assign(paste0("rast_", df_criteria_ba3b_m[crit_rownum[j], 11], "_rsmp_", df_growth_stages_req_temp[i, 1]),
               (sum(get(
                 paste0("rast_", df_criteria_ba3b_m[crit_rownum[j], 11], "_rsmp")
               ) * get(
                 paste0("rast_period_m_", df_growth_stages_req_temp[i, 1])
               )) / sum(get(
                 paste0("rast_period_m_", df_growth_stages_req_temp[i, 1])
               ))))
        
        #sum(r_tmean_calc_agg_mean_rsmp_bil * r_period_v) / sum(r_period_v)
        
        #print(get(
#          paste0("rast_", df_criteria_ba3b_m[crit_rownum, 11], "_rsmp_", df_growth_stages_req_temp[i, 1])
#        ))
#        plot_raster <-
          plot(get(
            paste0("rast_", df_criteria_ba3b_m[crit_rownum[j], 11], "_rsmp_", df_growth_stages_req_temp[i, 1])
          ),
          main = paste0("rast_period_m_",
                         as.character(df_growth_stages_req_temp[i, 1])))
#        print(plot_raster)
        
        
        new_col <-
          get(paste0("rast_", df_criteria_ba3b_m[crit_rownum[j], 11], "_rsmp_", df_growth_stages_req_temp[i , 1])) %>% terra::extract(xy) # extract the raster values using xy points
        
        new_col <- new_col[[1]]
        
        df_irm_i2 <- dplyr::select(df_irm_i2, -any_of(c(as.character(paste0(df_criteria_ba3b_m[crit_rownum[j], 3]))))) # remove column if name already exists
        
        df_irm_i2 <-
          mutate(df_irm_i2,!!as.character(paste0(df_criteria_ba3b_m[crit_rownum[j], 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm_i2 tibble, this needs to be dynamic so uses the !! and := operators
        
        } 
      } else {
        print(paste0("else m ", period_name, sum(df_criteria_ba3b_m[, 'phen_stage'] == period_name, na.rm = TRUE)))
      }
    }
}


df_criteria_ba3b_d <-
    dplyr::filter(df_criteria_ba3, grepl("^ba_3b", rulebase_stack) & temp_resolution == "d") # filter temperature criteria

if (nrow(df_criteria_ba3b_d) > 0) {  
  for (i in 1:nrow(df_growth_stages_req_temp)) {
        period_name <- as.character(df_growth_stages_req_temp[i, 1])
#      print(period_name)
      if (sum(df_criteria_ba3b_d[i, 'phen_stage'] == period_name, na.rm = TRUE) == 1) {
        print(paste0("period_name = ", as.character(period_name)))
        crit_rownum <-
          which(df_criteria_ba3b_d$phen_stage == period_name)
        assign(paste0("rast_", df_criteria_ba3b_d[crit_rownum, 11], "_rsmp_", df_growth_stages_req_temp[i, 1]),
               (sum(get(
                 paste0("rast_", df_criteria_ba3b_m[crit_rownum, 11], "_rsmp")
               ) * get(
                 paste0("rast_period_d_", df_growth_stages_req_temp[i, 1])
               )) / sum(get(
                 paste0("rast_period_d_", df_growth_stages_req_temp[i, 1])
               ))))
#        print(get(
#          paste0("rast_", df_criteria_ba3b_d[crit_rownum, 11], "_rsmp_", #df_growth_stages_req_temp[i, 1])
#        ))
#        plot_raster <-
          plot(get(
            paste0("rast_", df_criteria_ba3b_d[crit_rownum, 11], "_rsmp_", df_growth_stages_req_temp[i, 1])
          ),
          main = paste0("rast_period_d_",
                         as.character(df_growth_stages_req_temp[i, 1])))
#        print(plot_raster)
        
        
        new_col <-
          get(paste0("rast_", df_criteria_ba3b_d[crit_rownum, 11], "_rsmp_", df_growth_stages_req_temp[i , 1])) %>% terra::extract(xy) # extract the raster values using xy points
        
        new_col <- new_col[[1]]
        
        df_irm_i2 <- dplyr::select(df_irm_i2, -any_of(c(as.character(paste0(df_criteria_ba3b_d[crit_rownum, 3]))))) # remove column if name already exists
        
        df_irm_i2 <-
          mutate(df_irm_i2,!!as.character(paste0(df_criteria_ba3b_d[crit_rownum, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm_i2 tibble, this needs to be dynamic so uses the !! and := operators
        
        
      } else {
        print(sum(df_criteria_ba3b_d[, 'phen_stage'] == period_name, na.rm = TRUE))
      }
    }
}

df_criteria_ba3b <- rbind(df_criteria_ba3b_m, df_criteria_ba3b_d)

```
</div>


```{r i2_requirements_temp03, echo=FALSE, results='asis', eval=tmp_crit, eval=clim_crit}

cat("##### Temperature optimality

We used the requirements to construct fuzzy partitions and the rulebases.")

```

<div class="fold o">   
```{r i2_requirements_temp04, cache = TRUE, cache.whatever=params$Agg, out.width="100%", fig.show="hold", warning=FALSE, eval=tmp_crit, eval=clim_crit}



for (i in 1:(nrow(df_criteria_ba3b))) {
  if (!is.na(df_criteria_ba3b[i, 18])) {
    # for those criteria with three proposition values
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_criteria_ba3b[i, 16]),
        as.character(df_criteria_ba3b[i, 17]),
        as.character(df_criteria_ba3b[i, 18])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        as.character(df_criteria_ba3b[i, 19]),
        as.character(df_criteria_ba3b[i, 20]),
        as.character(df_criteria_ba3b[i, 21])
      )
    # get  the 2 crossover points
    cross_points <-
      c(df_criteria_ba3b[i, 6],
        df_criteria_ba3b[i, 7])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_criteria_ba3b[i, 8],
        df_criteria_ba3b[i, 9])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_criteria_ba3b[i, 6] - df_criteria_ba3b[i, 8]),
        (df_criteria_ba3b[i, 7] + df_criteria_ba3b[i, 9]))
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    prop_levels <-
      c(as.character(df_criteria_ba3b[i, 16]),
        as.character(df_criteria_ba3b[i, 17]))
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(as.character(df_criteria_ba3b[i, 19]),
        as.character(df_criteria_ba3b[i, 20]))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_criteria_ba3b[i, 6])
    
    # get  the 1 transition width
    trans_width <-
      c(df_criteria_ba3b[i, 8])
    
    # get  the 1 xlim for the plot
    plot_xlim <-
      c((df_criteria_ba3b[i, 6] - df_criteria_ba3b[i, 8]),
        (df_criteria_ba3b[i, 6] + df_criteria_ba3b[i, 8]))
    
  }
  assign(
    paste0("fp_", df_criteria_ba3b[i, 3]),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  plot_fp <-
    plot(
      get(paste0("fp_", df_criteria_ba3b[i, 3])),
      xlim = plot_xlim,
      xlab = as.character(df_criteria_ba3b[i, 4]),
      title = "fuzzy partition"
    )
  print(plot_fp)
  
  # construct the rule bases
  
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_ba3b[i, 3]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_criteria_ba3b[i, 3]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                df_criteria_ba3b[i, 3]),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0("rb_",
                   df_criteria_ba3b[i, 3])))
  
  # apply the fuzzy partitions to the data
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    df_criteria_ba3b[i, 3],
    ", newdata = df_irm_i2,",
    df_criteria_ba3b[i, 3],
    "=",
    "fp_",
    df_criteria_ba3b[i, 3],
    ")"
  )
  
  # evaluate the rule base and create the fpm
  
  assign(paste0("fpm_",
                df_criteria_ba3b[i, 3]), eval(parse(text = x)))
  
  # get the membership values from the fpm
  
  o_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba3b[i, 3]))$optimal)
  s_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba3b[i, 3]))$suboptimal)
  df_irm_i2 <-
    mutate(df_irm_i2,!!as.character(paste0(df_criteria_ba3b[i, 3], "_o")) := o_col, .keep = c("all"))
  df_irm_i2 <-
    mutate(df_irm_i2,!!as.character(paste0(df_criteria_ba3b[i, 3], "_s")) := s_col, .keep = c("all"))
  
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_ba3b[i, 3], "_o")), as.character(paste0(df_criteria_ba3b[i, 3], "_s")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_ba3b[i, 4], " optimal")), as.character(paste0(df_criteria_ba3b[i, 4], " suboptimal")))
  fpm_plot_title <-
    "Temperature growth\nstages optimality\nmembership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
  print(plot_fpm)
  
  
}

``` 
</div>

```{r i2_requirements_soilp01, echo=FALSE, results='asis', eval=soil_p_crit}

cat("### Soil physical properties requirements

If soil texture is a criterion then the USDA codes are reclassified quantitatively so that the fuzzy partitions can be applied.

Soil texture classes are reclassified in with 1, corresponding to S1 in Sys _et al._ (1993, p.159), 0.5 corresponding to S2, and 0 corresponding to S3, N1, N2 in Sys _et al._. 

An example is shown in the table below: 
 
USDA Class | USDA Texture Code | Suitability | Value 
-----------|-------------------|-------------|-------
     '1'   |     'Cl'          |  S2         |  0.5
     '2'   |     'SiCl'        |  S1         |  1
     '3'   |     'SaCl'        |  S1         |  1
     '4'   |     'ClLo'        |  S1         |  1
     '5'   |     'SiClLo'      |  S1         |  1
     '6'   |     'SaClLo'      |  S1         |  1
     '7'   |     'Lo'          |  S1         |  1
     '8'   |     'SiLo'        |  S1         |  1
     '9'   |     'SaLo'        |  S1         |  1
    '10'   |     'Si'          |  S1         |  1
    '11'   |     'LoSa'        |  S1         |  1
    '12'   |     'Sa'          |  S3         |  0
   '255'   |     'NODATA'      |  NA         |  NA")

```


   
```{r i2_requirements_soilp02, results='asis', warning=FALSE, eval=soil_p_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria

df_criteria_ba2c <-
  subset(df_priorities, grepl("^ba_2c", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cba2c <- nrow(df_criteria_ba2c)
cat(paste(n_cba2c, "Soil physical properties criteria:\n\n"))

# then determine and print the names of the rule bases in the soil physical properties theme
cat(paste(n_cba2c, "Soil physical properties rule bases:\n\n"))
for (i in 1:n_cba2c) {
  cat(paste(df_criteria_ba2c[i, 3],"\n", df_criteria_ba2c[i, 4],"\n"))
  
  if (paste(df_criteria_ba2c[i, 4]) == "Soil texture") {
    soil_texture_filename <-
      as.character(paste("tab_data/input/usda_texture_", params$INN2, ".csv", sep = ""))
    
    df_soil_texture <-  read.csv(here(soil_texture_filename))
    
    df_soil_texture %>%
      kable(digits = 3, caption = "Soil Texture ") %>% kable_styling("striped", full_width = T) %>% print
    
    # reclass using df_soil_texture table
    
    rast_texture <-
      get(paste0("rast_", df_criteria_ba2c[i, 11], "_rsmp")) %>% classify(as.matrix(
        dplyr::select(df_soil_texture, USDA_Texture_Class, IRM_Value)
      ))
    
    
    assign(paste0("rast_", df_criteria_ba2c[i, 11], "_rsmp"),  rast_texture[[1:5]])
    
    # standard depths for interpolation
    standard_depths <- c(0.025, 0.10, 0.225, 0.45, 0.80, 1.50)
    
    # thicknesses of individual layers
    bottom_layer <- c(0.05, 0.15, 0.30, 0.60, 1.0)
    thickness <- diff(c(0, bottom_layer))
    stopifnot(max(abs(
      bottom_layer - 0.5 *  thickness - standard_depths[1:5]
    )) < 1.0e-6)
    
    # depth weighted texture class (0-1)
    assign(paste0("rast_", df_criteria_ba2c[i, 11], "_rsmp"),
           get(paste0("rast_", df_criteria_ba2c[i, 11], "_rsmp")) %>% app(function(x) {
             sum((x * thickness) / sum(thickness))
           }))
  } else if (paste(df_criteria_ba2c[i, 4]) == "Coarse fragments") {
    assign(paste0("rast_", df_criteria_ba2c[i, 11], "_rsmp"),  get(paste0("rast_", df_criteria_ba2c[i, 11], "_rsmp"))[[1:5]])
    
    # standard depths for interpolation
    standard_depths <- c(0.025, 0.10, 0.225, 0.45, 0.80, 1.50)
    
    # thicknesses of individual layers
    bottom_layer <- c(0.05, 0.15, 0.30, 0.60, 1.0)
    thickness <- diff(c(0, bottom_layer))
    stopifnot(max(abs(
      bottom_layer - 0.5 *  thickness - standard_depths[1:5]
    )) < 1.0e-6)
    
    # depth weighted map
    assign(paste0("rast_", df_criteria_ba2c[i, 11], "_rsmp"),
           get(paste0("rast_", df_criteria_ba2c[i, 11], "_rsmp")) %>% app(function(x) {
             sum((x * thickness) / sum(thickness))
           }))
  }
}

```

```{r i2_requirements_soilp03, echo=FALSE, results='asis', eval=soil_p_crit}

cat("The reclassified classes are averaged over the entire soil profile from 0 to 0.8 m, taking the layer thicknesses as weights")

```


<div class="fold o">   
```{r i2_requirements_soilp04, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=soil_p_crit}

for (i in 1:n_cba2c) {
  new_col <-
    get(paste0("rast_", df_criteria_ba2c[i, 11], "_rsmp")) %>% terra::extract(xy) # extract the raster values using xy points
          
  new_col <- new_col[[1]]
  
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba2c[i, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm_i2 tibble, this needs to be dynamic so uses the !! and := operators
  
}

```
</div>

```{r i2_requirements_soilp05, echo=FALSE, results='asis', eval=soil_p_crit}

cat("#### Soil physical properties optimality

We used the requirements to construct fuzzy partitions and the rulebases.")

```


<div class="fold o">   
```{r i2_requirements_soilp06, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=soil_p_crit}

for (i in 1:(nrow(df_criteria_ba2c))) {
  if (!is.na(df_criteria_ba2c[i, 18])) {
    # for those criteria with three proposition values
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_criteria_ba2c[i, 16]),
        as.character(df_criteria_ba2c[i, 17]),
        as.character(df_criteria_ba2c[i, 18])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        as.character(df_criteria_ba2c[i, 19]),
        as.character(df_criteria_ba2c[i, 20]),
        as.character(df_criteria_ba2c[i, 21])
      )
    # get  the 2 crossover points
    cross_points <-
      c(df_criteria_ba2c[i, 6],
        df_criteria_ba2c[i, 7])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_criteria_ba2c[i, 8],
        df_criteria_ba2c[i, 9])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_criteria_ba2c[i, 6] - df_criteria_ba2c[i, 8]),
        (df_criteria_ba2c[i, 7] + df_criteria_ba2c[i, 9]))
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    prop_levels <-
      c(as.character(df_criteria_ba2c[i, 16]),
        as.character(df_criteria_ba2c[i, 17]))
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(as.character(df_criteria_ba2c[i, 19]),
        as.character(df_criteria_ba2c[i, 20]))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_criteria_ba2c[i, 6])
    
    # get  the 1 transition width
    trans_width <-
      c(df_criteria_ba2c[i, 8])
    
    # get  the 1 xlim for the plot
    plot_xlim <-
      c((df_criteria_ba2c[i, 6] - df_criteria_ba2c[i, 8]),
        (df_criteria_ba2c[i, 6] + df_criteria_ba2c[i, 8]))
    
  }
  assign(
    paste0("fp_", df_criteria_ba2c[i, 3]),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  plot_fp <-
    plot(
      get(paste0("fp_", df_criteria_ba2c[i, 3])),
      xlim = plot_xlim,
      xlab = as.character(df_criteria_ba2c[i, 4]),
      title = "fuzzy partition"
    )
  print(plot_fp)
  
  # construct the rule bases
  
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_ba2c[i, 3]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_criteria_ba2c[i, 3]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                df_criteria_ba2c[i, 3]),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0("rb_",
                   df_criteria_ba2c[i, 3])))
  
  # apply the fuzzy partitions to the data
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    df_criteria_ba2c[i, 3],
    ", newdata = df_irm_i2,",
    df_criteria_ba2c[i, 3],
    "=",
    "fp_",
    df_criteria_ba2c[i, 3],
    ")"
  )
  
  # evaluate the rule base and create the fpm
  
  assign(paste0("fpm_",
                df_criteria_ba2c[i, 3]), eval(parse(text = x)))
  
  # get the membership values from the fpm
  
  o_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba2c[i, 3]))$optimal)
  s_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba2c[i, 3]))$suboptimal)
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba2c[i, 3], "_o")) := o_col, .keep = c("all"))
  
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba2c[i, 3], "_s")) := s_col, .keep = c("all"))
  
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_ba2c[i, 3], "_o")), as.character(paste0(df_criteria_ba2c[i, 3], "_s")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_ba2c[i, 4], " optimal")), as.character(paste0(df_criteria_ba2c[i, 4], " suboptimal")))
  fpm_plot_title <-
    "Soil physical properties optimality membership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
  print(plot_fpm)
  
  
}

``` 
</div>


```{r i2_requirements_soilf01, echo=FALSE, results='asis', eval=soil_f_crit}

cat("### Soil fertility requirements")

```


```{r i2_requirements_soilf02, results='asis', warning=FALSE, eval=soil_f_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria

df_criteria_ba2d <-
  subset(df_priorities, grepl("^ba_2d", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cba2d <- nrow(df_criteria_ba2d)
cat(paste(n_cba2d, "Soil fertility criteria:\n\n "))

# then determine and print the names of the rule bases in the soil fertility theme

cat(paste(n_cba2d, "Soil fertility rule bases:\n\n"))
```


<div class="fold o">   
```{r i2_requirements_soilf03, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=soil_f_crit}

for (i in 1:n_cba2d) {
  new_col <-
    get(paste0("rast_", df_criteria_ba2d[i, 11], "_rsmp")) %>% terra::extract(xy) # extract the raster values using xy points
  
  new_col <- new_col[[1]]
  
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba2d[i, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm_i2 tibble, this needs to be dynamic so uses the !! and := operators
  
}

```
</div>

```{r i2_requirements_soilf04, echo=FALSE, results='asis', eval=soil_f_crit}

cat("#### Soil fertility optimality

We used the requirements to construct fuzzy partitions and the rulebases.")

```

<div class="fold o">   
```{r i2_requirements_soilf05, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=soil_f_crit}

for (i in 1:(nrow(df_criteria_ba2d))) {
  if (!is.na(df_criteria_ba2d[i, 18])) {
    # for those criteria with three proposition values
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_criteria_ba2d[i, 16]),
        as.character(df_criteria_ba2d[i, 17]),
        as.character(df_criteria_ba2d[i, 18])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        as.character(df_criteria_ba2d[i, 19]),
        as.character(df_criteria_ba2d[i, 20]),
        as.character(df_criteria_ba2d[i, 21])
      )
    # get  the 2 crossover points
    cross_points <-
      c(df_criteria_ba2d[i, 6],
        df_criteria_ba2d[i, 7])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_criteria_ba2d[i, 8],
        df_criteria_ba2d[i, 9])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_criteria_ba2d[i, 6] - df_criteria_ba2d[i, 8]),
        (df_criteria_ba2d[i, 7] + df_criteria_ba2d[i, 9]))
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    prop_levels <-
      c(as.character(df_criteria_ba2d[i, 16]),
        as.character(df_criteria_ba2d[i, 17]))
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(as.character(df_criteria_ba2d[i, 19]),
        as.character(df_criteria_ba2d[i, 20]))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_criteria_ba2d[i, 6])
    
    # get  the 1 transition width
    trans_width <-
      c(df_criteria_ba2d[i, 8])
    
    # get  the 1 xlim for the plot
    plot_xlim <-
      c((df_criteria_ba2d[i, 6] - df_criteria_ba2d[i, 8]),
        (df_criteria_ba2d[i, 6] + df_criteria_ba2d[i, 8]))
    
  }
  assign(
    paste0("fp_", df_criteria_ba2d[i, 3]),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  plot_fp <-
    plot(
      get(paste0("fp_", df_criteria_ba2d[i, 3])),
      xlim = plot_xlim,
      xlab = as.character(df_criteria_ba2d[i, 4]),
      title = "fuzzy partition"
    )
  print(plot_fp)
  
  # construct the rule bases
  
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_ba2d[i, 3]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_criteria_ba2d[i, 3]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                df_criteria_ba2d[i, 3]),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0("rb_",
                   df_criteria_ba2d[i, 3])))
  
  # apply the fuzzy partitions to the data
  
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    df_criteria_ba2d[i, 3],
    ", newdata = df_irm_i2,",
    df_criteria_ba2d[i, 3],
    "=",
    "fp_",
    df_criteria_ba2d[i, 3],
    ")"
  )
  
  # evaluate the rule base and create the fpm
  
  assign(paste0("fpm_",
                df_criteria_ba2d[i, 3]), eval(parse(text = x)))
  
  # get the membership values from the fpm
  
  o_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba2d[i, 3]))$optimal)
  s_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba2d[i, 3]))$suboptimal)
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba2d[i, 3], "_o")) := o_col, .keep = c("all"))
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba2d[i, 3], "_s")) := s_col, .keep = c("all"))
  
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_ba2d[i, 3], "_o")), as.character(paste0(df_criteria_ba2d[i, 3], "_s")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_ba2d[i, 4], " optimal")), as.character(paste0(df_criteria_ba2d[i, 4], " suboptimal")))
  fpm_plot_title <-
    "Soil fertility optimality membership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
  print(plot_fpm)

}

``` 
</div>

```{r i2_requirements_lscape01, echo=FALSE, results='asis', eval=lscape_crit}

cat("### Landscape requirements

Drainage classes are from ISRIC's SoilGrids (ftp://soilgrids:soilgrids@ftp.soilgrids.org/data/AF/recent/)

Drainage classes are according to the FAO Guidelines for profile description. See ISRIC_report 2008_02.pdf (http://www.isric.org/isric/webdocs/docs/ISRIC_Report_2008_02.pdf)

The drainage classes are:

- V: very poorly drained
- P: poorly drained
- I: somewhat poorly (imperfectly) drained
- M: moderately well drained
- W: well drained
- S: somewhat excessively drained
- E: excessively drained

The map below is a recoded version of this map (1:V, 2:P, 3:I, 4:M, 5:W, 6:S, 7:E)")

```


```{r i2_requirements_lscape02, results='asis', warning=FALSE, eval=lscape_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria
df_criteria_ba2e <-
  subset(df_priorities, grepl("^ba_2e", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cba2e <- nrow(df_criteria_ba2e)
cat(paste(n_cba2e, "Landscape criteria:\n\n"))

# then determine and print the names of the rule bases in the landscape theme

cat(paste(n_cba2e, "Landscape rule bases:\n\n"))
for (i in 1:n_cba2e) {
  cat(paste(df_criteria_ba2e[i, 3], "\n", df_criteria_ba2e[i, 4], "\n"))
}

```

<div class="fold o">   
```{r i2_requirements_lscape03, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=lscape_crit}

for (i in 1:n_cba2e) {
  new_col <-
    get(paste0("rast_", df_criteria_ba2e[i, 11], "_rsmp")) %>% terra::extract(xy) # extract the raster values using xy points
          
  new_col <- new_col[[1]]
  
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba2e[i, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm_i2 tibble, this needs to be dynamic so uses the !! and := operators
  
}

```
</div>


```{r i2_requirements_lscape04, echo=FALSE, results='asis', eval=lscape_crit}

cat("#### Landscape optimality

We used the requirements to construct fuzzy partitions and the rulebases.")

```


<div class="fold o">   
```{r i2_requirements_lscape05, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=lscape_crit}

for (i in 1:(nrow(df_criteria_ba2e))) {
  if (!is.na(df_criteria_ba2e[i, 18])) {
    # for those criteria with three proposition values
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_criteria_ba2e[i, 16]),
        as.character(df_criteria_ba2e[i, 17]),
        as.character(df_criteria_ba2e[i, 18])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        as.character(df_criteria_ba2e[i, 19]),
        as.character(df_criteria_ba2e[i, 20]),
        as.character(df_criteria_ba2e[i, 21])
      )
    # get  the 2 crossover points
    cross_points <-
      c(df_criteria_ba2e[i, 6],
        df_criteria_ba2e[i, 7])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_criteria_ba2e[i, 8],
        df_criteria_ba2e[i, 9])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_criteria_ba2e[i, 6] - df_criteria_ba2e[i, 8]),
        (df_criteria_ba2e[i, 7] + df_criteria_ba2e[i, 9]))
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    prop_levels <-
      c(as.character(df_criteria_ba2e[i, 16]),
        as.character(df_criteria_ba2e[i, 17]))
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(as.character(df_criteria_ba2e[i, 19]),
        as.character(df_criteria_ba2e[i, 20]))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_criteria_ba2e[i, 6])
    
    # get  the 1 transition width
    trans_width <-
      c(df_criteria_ba2e[i, 8])
    
    # get  the 1 xlim for the plot
    plot_xlim <-
      c((df_criteria_ba2e[i, 6] - df_criteria_ba2e[i, 8]),
        (df_criteria_ba2e[i, 6] + df_criteria_ba2e[i, 8]))
    
  }
  assign(
    paste0("fp_", df_criteria_ba2e[i, 3]),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  plot_fp <-
    plot(
      get(paste0("fp_", df_criteria_ba2e[i, 3])),
      xlim = plot_xlim,
      xlab = as.character(df_criteria_ba2e[i, 4]),
      title = "fuzzy partition"
    )
  print(plot_fp)
  
  # construct the rule bases
  
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_ba2e[i, 3]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_criteria_ba2e[i, 3]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                df_criteria_ba2e[i, 3]),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0("rb_",
                   df_criteria_ba2e[i, 3])))
  
  # apply the fuzzy partitions to the data
  
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    df_criteria_ba2e[i, 3],
    ", newdata = df_irm_i2,",
    df_criteria_ba2e[i, 3],
    "=",
    "fp_",
    df_criteria_ba2e[i, 3],
    ")"
  )
  
  # evaluate the rule base and create the fpm
  
  assign(paste0("fpm_",
                df_criteria_ba2e[i, 3]), eval(parse(text = x)))
  
  # get the membership values from the fpm
  
  o_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba2e[i, 3]))$optimal)
  s_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba2e[i, 3]))$suboptimal)
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba2e[i, 3], "_o")) := o_col, .keep = c("all"))
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba2e[i, 3], "_s")) := s_col, .keep = c("all"))
  
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_ba2e[i, 3], "_o")), as.character(paste0(df_criteria_ba2e[i, 3], "_s")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_ba2e[i, 4], " optimal")), as.character(paste0(df_criteria_ba2e[i, 4], " suboptimal")))
  fpm_plot_title <-
    "Landscape optimality membership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
  print(plot_fpm)

}

``` 
</div>


```{r i2_requirements_agland01, echo=FALSE, results='asis', eval=land_crit}

cat("### Agricultural Land requirements")

```

```{r i2_requirements_agland02, results='asis', warning=FALSE, eval=land_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria

df_criteria_ba2a <-
  subset(df_priorities, grepl("^ba_2a", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cba2a <- nrow(df_criteria_ba2a)
cat(paste(n_cba2a, "Agricultural Land criteria: \n\n"))

# then determine and print the names of the rule bases in the land theme
# here in contrast to the previous themes we need to account for criteria which have no data but instead use rule base stacks - these are removed now from the criteria data frame and evaluated later

data_rulebase <- !is.na(df_criteria_ba2a$data_file_prefix)
df_criteria_ba2a <- df_criteria_ba2a[data_rulebase,]

n_cse3b <- nrow(df_criteria_ba2a)

cat(paste(n_cba2a, "Agricultural Land rule bases:\n\n"))
for (i in 1:n_cba2a) {
  cat(paste(df_criteria_ba2a[i, 3],"\n", df_criteria_ba2a[i, 4],"\n"))
}

```

<div class="fold o">   
```{r i2_requirements_agland03, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=land_crit}

for (i in 1:n_cba2a) {
  new_col <-
    get(paste0("rast_", df_criteria_ba2a[i, 11], "_rsmp")) %>% terra::extract(xy) # extract the raster values using xy points
          
  new_col <- new_col[[1]]
        
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba2a[i, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm_i2 tibble, this needs to be dynamic so uses the !! and := operators
  
}

```
</div>

```{r i2_requirements_agland04, echo=FALSE, results='asis', eval=land_crit}

cat("#### Agricultural Land optimality

We used the requirements to construct fuzzy partitions and the rulebases.")

```

<div class="fold o">   
```{r i2_requirements_agland05, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=land_crit}

for (i in 1:(nrow(df_criteria_ba2a))) {
  if (!is.na(df_criteria_ba2a[i, 18])) {
    # for those criteria with three proposition values
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_criteria_ba2a[i, 16]),
        as.character(df_criteria_ba2a[i, 17]),
        as.character(df_criteria_ba2a[i, 18])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        as.character(df_criteria_ba2a[i, 19]),
        as.character(df_criteria_ba2a[i, 20]),
        as.character(df_criteria_ba2a[i, 21])
      )
    # get  the 2 crossover points
    cross_points <-
      c(df_criteria_ba2a[i, 6],
        df_criteria_ba2a[i, 7])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_criteria_ba2a[i, 8],
        df_criteria_ba2a[i, 9])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_criteria_ba2a[i, 6] - df_criteria_ba2a[i, 8]),
        (df_criteria_ba2a[i, 7] + df_criteria_ba2a[i, 9]))
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    prop_levels <-
      c(as.character(df_criteria_ba2a[i, 16]),
        as.character(df_criteria_ba2a[i, 17]))
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(as.character(df_criteria_ba2a[i, 19]),
        as.character(df_criteria_ba2a[i, 20]))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_criteria_ba2a[i, 6])
    
    # get  the 1 transition width
    trans_width <-
      c(df_criteria_ba2a[i, 8])
    
    # get  the 1 xlim for the plot
    plot_xlim <-
      c((df_criteria_ba2a[i, 6] - df_criteria_ba2a[i, 8]),
        (df_criteria_ba2a[i, 6] + df_criteria_ba2a[i, 8]))
    
  }
  assign(
    paste0("fp_", df_criteria_ba2a[i, 3]),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  plot_fp <-
    plot(
      get(paste0("fp_", df_criteria_ba2a[i, 3])),
      xlim = plot_xlim,
      xlab = as.character(df_criteria_ba2a[i, 4]),
      title = "fuzzy partition"
    )
  print(plot_fp)
  
  # construct the rule bases
  
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_ba2a[i, 3]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_criteria_ba2a[i, 3]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                df_criteria_ba2a[i, 3]),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0("rb_",
                   df_criteria_ba2a[i, 3])))
  
  # apply the fuzzy partitions to the data
  
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    df_criteria_ba2a[i, 3],
    ", newdata = df_irm_i2,",
    df_criteria_ba2a[i, 3],
    "=",
    "fp_",
    df_criteria_ba2a[i, 3],
    ")"
  )
  
  # evaluate the rule base and create the fpm
  
  assign(paste0("fpm_",
                df_criteria_ba2a[i, 3]), eval(parse(text = x)))
  
  # get the membership values from the fpm
  
  
  
  o_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba2a[i, 3]))$optimal)
  s_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_ba2a[i, 3]))$suboptimal)
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba2a[i, 3], "_o")) := o_col, .keep = c("all"))
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba2a[i, 3], "_s")) := s_col, .keep = c("all"))
  
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_ba2a[i, 3], "_o")), as.character(paste0(df_criteria_ba2a[i, 3], "_s")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_ba2a[i, 4], " optimal")), as.character(paste0(df_criteria_ba2a[i, 4], " suboptimal")))
  fpm_plot_title <-
    "Agricultural\nLand\noptimality\nmembership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
  print(plot_fpm)
  
  
}

``` 
</div>

```{r i2_requirements_sef01, echo=FALSE, results='asis', eval=sef_crit}

cat("## Socio-economic requirements")

```


```{r i2_requirements_market_access01, echo=FALSE, results='asis', eval=mktaccess_crit}

cat("### Market Access requirements")

```

```{r i2_requirements_market_access02, results='asis', warning=FALSE, eval=mktaccess_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria

df_criteria_se2b <-
  subset(df_priorities, grepl("^se_2b", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cse2b <- nrow(df_criteria_se2b)
cat(paste(n_cse2b, "Market Access criteria: \n\n"))

# then determine and print the names of the rule bases in the Market Access theme

cat(paste(n_cse2b, "Market Access rule bases: \n\n"))
for (i in 1:n_cse2b) {
  cat(paste(df_criteria_se2b[i, 3], "\n", df_criteria_se2b[i, 4], "\n"))
}

```

<div class="fold o">   
```{r i2_requirements_market_access03, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=mktaccess_crit}

for (i in 1:n_cse2b) {
  new_col <-
    get(paste0("rast_", df_criteria_se2b[i, 11], "_rsmp")) %>% terra::extract(xy) # extract the raster values using xy points
        
  new_col <- new_col[[1]]
  
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_se2b[i, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm_i2 tibble, this needs to be dynamic so uses the !! and := operators
  
}

```
</div>

```{r i2_requirements_market_access04, echo=FALSE, results='asis', eval=mktaccess_crit}

cat("#### Market Access optimality

We used the requirements to construct fuzzy partitions and the rulebases.")

```

<div class="fold o">   
```{r i2_requirements_market_access05, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=mktaccess_crit}

for (i in 1:(nrow(df_criteria_se2b))) {
  if (!is.na(df_criteria_se2b[i, 18])) {
    # for those criteria with three proposition values
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_criteria_se2b[i, 16]),
        as.character(df_criteria_se2b[i, 17]),
        as.character(df_criteria_se2b[i, 18])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        as.character(df_criteria_se2b[i, 19]),
        as.character(df_criteria_se2b[i, 20]),
        as.character(df_criteria_se2b[i, 21])
      )
    # get  the 2 crossover points
    cross_points <-
      c(df_criteria_se2b[i, 6],
        df_criteria_se2b[i, 7])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_criteria_se2b[i, 8],
        df_criteria_se2b[i, 9])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_criteria_se2b[i, 6] - df_criteria_se2b[i, 8]),
        (df_criteria_se2b[i, 7] + df_criteria_se2b[i, 9]))
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    prop_levels <-
      c(as.character(df_criteria_se2b[i, 16]),
        as.character(df_criteria_se2b[i, 17]))
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(as.character(df_criteria_se2b[i, 19]),
        as.character(df_criteria_se2b[i, 20]))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_criteria_se2b[i, 6])
    
    # get  the 1 transition width
    trans_width <-
      c(df_criteria_se2b[i, 8])
    
    # get  the 1 xlim for the plot
    plot_xlim <-
      c((df_criteria_se2b[i, 6] - df_criteria_se2b[i, 8]),
        (df_criteria_se2b[i, 6] + df_criteria_se2b[i, 8]))
    
  }
  assign(
    paste0("fp_", df_criteria_se2b[i, 3]),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  plot_fp <-
    plot(
      get(paste0("fp_", df_criteria_se2b[i, 3])),
      xlim = plot_xlim,
      xlab = as.character(df_criteria_se2b[i, 4]),
      title = "fuzzy partition"
    )
  print(plot_fp)
  
  # construct the rule bases
  
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_se2b[i, 3]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_criteria_se2b[i, 3]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                df_criteria_se2b[i, 3]),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0("rb_",
                   df_criteria_se2b[i, 3])))
  
  # apply the fuzzy partitions to the data
  
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    df_criteria_se2b[i, 3],
    ", newdata = df_irm_i2,",
    df_criteria_se2b[i, 3],
    "=",
    "fp_",
    df_criteria_se2b[i, 3],
    ")"
  )
  
  # evaluate the rule base and create the fpm
  
  assign(paste0("fpm_",
                df_criteria_se2b[i, 3]), eval(parse(text = x)))
  
  # get the membership values from the fpm
  
  g_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se2b[i, 3]))$good)
  p_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se2b[i, 3]))$poor)
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_se2b[i, 3], "_g")) := g_col, .keep = c("all"))
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_se2b[i, 3], "_p")) := p_col, .keep = c("all"))
  
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se2b[i, 3], "_g")), as.character(paste0(df_criteria_se2b[i, 3], "_p")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se2b[i, 4], " good")), as.character(paste0(df_criteria_se2b[i, 4], " poor")))
  fpm_plot_title <-
    "Market Access\noptimality\nmembership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
  print(plot_fpm)
  
  
}

``` 
</div>

```{r i2_requirements_inputs_access01, echo=FALSE, results='asis', eval=inpaccess_crit}

cat("### Inputs Access requirements")

```

```{r i2_requirements_inputs_access02, results='asis', warning=FALSE, eval=inpaccess_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria

df_criteria_se3b <-
  subset(df_priorities, grepl("^se_3b", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cse3b <- nrow(df_criteria_se3b)
cat(paste(n_cse3b, "Inputs Access criteria: \n\n"))

# then determine and print the names of the rule bases in the Inputs Access theme
# here in contrast to the previous themes we need to account for criteria which have no data but instead use rule base stacks - these are removed now from the criteria data frame and evaluated later

data_rulebase <- !is.na(df_criteria_se3b$data_file_prefix)
df_criteria_se3b <- df_criteria_se3b[data_rulebase,]

n_cse3b <- nrow(df_criteria_se3b)

cat(paste(n_cse3b, "Inputs Access data rule bases:\n\n"))
for (i in 1:n_cse3b) {
  cat(paste(df_criteria_se3b[i, 3], "\n", df_criteria_se3b[i, 4], "\n"))
}

```

<div class="fold o">   
```{r i2_requirements_inputs_access03, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=inpaccess_crit}

for (i in 1:n_cse3b) {
  new_col <-
    get(paste0("rast_", df_criteria_se3b[i, 11], "_rsmp")) %>% terra::extract(xy) # extract the raster values using xy points
        
  new_col <- new_col[[1]] 
  
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_se3b[i, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm_i2 tibble, this needs to be dynamic so uses the !! and := operators
  
}

```
</div>

```{r i2_requirements_inputs_access04, echo=FALSE, results='asis', eval=inpaccess_crit}

cat("#### Inputs Access optimality

We used the requirements to construct fuzzy partitions and the data rule bases.")

```

<div class="fold o">   
```{r i2_requirements_inputs_access05, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=inpaccess_crit}

for (i in 1:(nrow(df_criteria_se3b))) {
  if (!is.na(df_criteria_se3b[i, 18])) {
    # for those criteria with three proposition values
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_criteria_se3b[i, 16]),
        as.character(df_criteria_se3b[i, 17]),
        as.character(df_criteria_se3b[i, 18])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        as.character(df_criteria_se3b[i, 19]),
        as.character(df_criteria_se3b[i, 20]),
        as.character(df_criteria_se3b[i, 21])
      )
    # get  the 2 crossover points
    cross_points <-
      c(df_criteria_se3b[i, 6],
        df_criteria_se3b[i, 7])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_criteria_se3b[i, 8],
        df_criteria_se3b[i, 9])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_criteria_se3b[i, 6] - df_criteria_se3b[i, 8]),
        (df_criteria_se3b[i, 7] + df_criteria_se3b[i, 9]))
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    prop_levels <-
      c(as.character(df_criteria_se3b[i, 16]),
        as.character(df_criteria_se3b[i, 17]))
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(as.character(df_criteria_se3b[i, 19]),
        as.character(df_criteria_se3b[i, 20]))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_criteria_se3b[i, 6])
    
    # get  the 1 transition width
    trans_width <-
      c(df_criteria_se3b[i, 8])
    
    # get  the 1 xlim for the plot
    plot_xlim <-
      c((df_criteria_se3b[i, 6] - df_criteria_se3b[i, 8]),
        (df_criteria_se3b[i, 6] + df_criteria_se3b[i, 8]))
    
  }
  assign(
    paste0("fp_", df_criteria_se3b[i, 3]),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  plot_fp <-
    plot(
      get(paste0("fp_", df_criteria_se3b[i, 3])),
      xlim = plot_xlim,
      xlab = as.character(df_criteria_se3b[i, 4]),
      title = "fuzzy partition"
    )
  print(plot_fp)
  
  # construct the rule bases
  
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_se3b[i, 3]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_criteria_se3b[i, 3]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                df_criteria_se3b[i, 3]),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0("rb_",
                   df_criteria_se3b[i, 3])))
  
  # apply the fuzzy partitions to the data
  
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    df_criteria_se3b[i, 3],
    ", newdata = df_irm_i2,",
    df_criteria_se3b[i, 3],
    "=",
    "fp_",
    df_criteria_se3b[i, 3],
    ")"
  )
  
  # evaluate the rule base and create the fpm
  
  assign(paste0("fpm_",
                df_criteria_se3b[i, 3]), eval(parse(text = x)))
  
  # get the membership values from the fpm
  
  g_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se3b[i, 3]))$good)
  p_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se3b[i, 3]))$poor)
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_se3b[i, 3], "_g")) := g_col, .keep = c("all"))
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_se3b[i, 3], "_p")) := p_col, .keep = c("all"))
  
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se3b[i, 3], "_g")), as.character(paste0(df_criteria_se3b[i, 3], "_p")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se3b[i, 4], " good")), as.character(paste0(df_criteria_se3b[i, 4], " poor")))
  fpm_plot_title <-
    "Inputs Access\noptimality\nmembership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
  print(plot_fpm)
  
  
}

``` 
</div>

```{r i2_requirements_extension_access01, echo=FALSE, results='asis', eval=extaccess_crit}

cat("### Extension Access requirements")

```


```{r i2_requirements_extension_access02, results='asis', warning=FALSE, eval=extaccess_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria

df_criteria_se4a <-
  subset(df_priorities, grepl("^se_4a", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cse4a <- nrow(df_criteria_se4a)
cat(paste(n_cse4a, "Extension Access criteria: \n\n"))

# then determine and print the names of the rule bases in the Extension Access theme
# here in contrast to the previous themes we need to account for criteria which have no data but instead use rule base stacks - these are removed now from the criteria data frame and evaluated later

data_rulebase <- !is.na(df_criteria_se4a$data_file_prefix)
df_criteria_se4a <- df_criteria_se4a[data_rulebase,]

n_cse4a <- nrow(df_criteria_se4a)

cat(paste(n_cse4a, "Extension Access data rule bases:\n\n"))
for (i in 1:n_cse4a) {
  cat(paste(df_criteria_se4a[i, 3], "\n", df_criteria_se4a[i, 4],"\n"))
}

```

<div class="fold o">   
```{r i2_requirements_extension_access03, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=extaccess_crit}

for (i in 1:n_cse4a) {
  new_col <-
    get(paste0("rast_", df_criteria_se4a[i, 11], "_rsmp")) %>% terra::extract(xy) # extract the raster values using xy points
  
  new_col <- new_col[[1]]
  
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_se4a[i, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm_i2 tibble, this needs to be dynamic so uses the !! and := operators
  
}

```
</div>

```{r i2_requirements_extension_access04, echo=FALSE, results='asis', eval=extaccess_crit}

cat("#### Extension Access optimality

We used the requirements to construct fuzzy partitions and the data rule bases.")

```

<div class="fold o">   
```{r i2_requirements_extension_access05, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=extaccess_crit}

for (i in 1:(nrow(df_criteria_se4a))) {
  if (!is.na(df_criteria_se4a[i, 18])) {
    # for those criteria with three proposition values
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_criteria_se4a[i, 16]),
        as.character(df_criteria_se4a[i, 17]),
        as.character(df_criteria_se4a[i, 18])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        as.character(df_criteria_se4a[i, 19]),
        as.character(df_criteria_se4a[i, 20]),
        as.character(df_criteria_se4a[i, 21])
      )
    # get  the 2 crossover points
    cross_points <-
      c(df_criteria_se4a[i, 6],
        df_criteria_se4a[i, 7])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_criteria_se4a[i, 8],
        df_criteria_se4a[i, 9])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_criteria_se4a[i, 6] - df_criteria_se4a[i, 8]),
        (df_criteria_se4a[i, 7] + df_criteria_se4a[i, 9]))
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    prop_levels <-
      c(as.character(df_criteria_se4a[i, 16]),
        as.character(df_criteria_se4a[i, 17]))
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(as.character(df_criteria_se4a[i, 19]),
        as.character(df_criteria_se4a[i, 20]))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_criteria_se4a[i, 6])
    
    # get  the 1 transition width
    trans_width <-
      c(df_criteria_se4a[i, 8])
    
    # get  the 1 xlim for the plot
    plot_xlim <-
      c((df_criteria_se4a[i, 6] - df_criteria_se4a[i, 8]),
        (df_criteria_se4a[i, 6] + df_criteria_se4a[i, 8]))
    
  }
  assign(
    paste0("fp_", df_criteria_se4a[i, 3]),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  plot_fp <-
    plot(
      get(paste0("fp_", df_criteria_se4a[i, 3])),
      xlim = plot_xlim,
      xlab = as.character(df_criteria_se4a[i, 4]),
      title = "fuzzy partition"
    )
  print(plot_fp)
  
  # construct the rule bases
  
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_se4a[i, 3]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_criteria_se4a[i, 3]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                df_criteria_se4a[i, 3]),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0("rb_",
                   df_criteria_se4a[i, 3])))
  
  # apply the fuzzy partitions to the data
  
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    df_criteria_se4a[i, 3],
    ", newdata = df_irm_i2,",
    df_criteria_se4a[i, 3],
    "=",
    "fp_",
    df_criteria_se4a[i, 3],
    ")"
  )
  
  # evaluate the rule base and create the fpm
  
  assign(paste0("fpm_",
                df_criteria_se4a[i, 3]), eval(parse(text = x)))
  
  # get the membership values from the fpm
  
  g_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se4a[i, 3]))$good)
  p_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se4a[i, 3]))$poor)
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_se4a[i, 3], "_g")) := g_col, .keep = c("all"))
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_se4a[i, 3], "_p")) := p_col, .keep = c("all"))
  
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se4a[i, 3], "_g")), as.character(paste0(df_criteria_se4a[i, 3], "_p")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se4a[i, 4], " good")), as.character(paste0(df_criteria_se4a[i, 4], " poor")))
  fpm_plot_title <-
    "Extension\nAccess\noptimality\nmembership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
  print(plot_fpm)
  
  
}

``` 
</div>

```{r i2_requirements_labour_access01, echo=FALSE, results='asis', eval=lab_crit}

cat("### Labour requirements")

```

```{r i2_requirements_labour_access02, results='asis', warning=FALSE, eval=lab_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria


df_criteria_se4b <-
  subset(df_priorities, grepl("^se_4b", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cse4b <- nrow(df_criteria_se4b)
cat(paste(n_cse4b, "Labour criteria: \n\n"))

# then determine and print the names of the rule bases in the Labour theme
# here in contrast to the previous themes we need to account for criteria which have no data but instead use rule base stacks - these are removed now from the criteria data frame and evaluated later

data_rulebase <- !is.na(df_criteria_se4b$data_file_prefix)
df_criteria_se4b <- df_criteria_se4b[data_rulebase,]

n_cse4b <- nrow(df_criteria_se4b)

cat(paste(n_cse4b, "Labour data rule bases:\n\n"))
for (i in 1:n_cse4b) {
  cat(paste(df_criteria_se4b[i, 3], "\n", df_criteria_se4b[i, 4],"\n"))
}

```

<div class="fold o">   
```{r i2_requirements_labour_access03, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=lab_crit}

for (i in 1:n_cse4b) {
  new_col <-
    get(paste0("rast_", df_criteria_se4b[i, 11], "_rsmp")) %>% terra::extract(xy) # extract the raster values using xy points
  
  new_col <- new_col[[1]]
  
  
  
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_se4b[i, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm_i2 tibble, this needs to be dynamic so uses the !! and := operators
  
}

```
</div>

```{r i2_requirements_labour_access04, echo=FALSE, results='asis', eval=lab_crit}

cat("#### Labour optimality

We used the requirements to construct fuzzy partitions and the data rule bases.")

```


<div class="fold o">   
```{r i2_requirements_labour_access05, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=lab_crit}

for (i in 1:(nrow(df_criteria_se4b))) {
  if (!is.na(df_criteria_se4b[i, 18])) {
    # for those criteria with three proposition values
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_criteria_se4b[i, 16]),
        as.character(df_criteria_se4b[i, 17]),
        as.character(df_criteria_se4b[i, 18])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        as.character(df_criteria_se4b[i, 19]),
        as.character(df_criteria_se4b[i, 20]),
        as.character(df_criteria_se4b[i, 21])
      )
    # get  the 2 crossover points
    cross_points <-
      c(df_criteria_se4b[i, 6],
        df_criteria_se4b[i, 7])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_criteria_se4b[i, 8],
        df_criteria_se4b[i, 9])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_criteria_se4b[i, 6] - df_criteria_se4b[i, 8]),
        (df_criteria_se4b[i, 7] + df_criteria_se4b[i, 9]))
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    prop_levels <-
      c(as.character(df_criteria_se4b[i, 16]),
        as.character(df_criteria_se4b[i, 17]))
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(as.character(df_criteria_se4b[i, 19]),
        as.character(df_criteria_se4b[i, 20]))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_criteria_se4b[i, 6])
    
    # get  the 1 transition width
    trans_width <-
      c(df_criteria_se4b[i, 8])
    
    # get  the 1 xlim for the plot
    plot_xlim <-
      c((df_criteria_se4b[i, 6] - df_criteria_se4b[i, 8]),
        (df_criteria_se4b[i, 6] + df_criteria_se4b[i, 8]))
    
  }
  assign(
    paste0("fp_", df_criteria_se4b[i, 3]),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  plot_fp <-
    plot(
      get(paste0("fp_", df_criteria_se4b[i, 3])),
      xlim = plot_xlim,
      xlab = as.character(df_criteria_se4b[i, 4]),
      title = "fuzzy partition"
    )
  print(plot_fp)
  
  # construct the rule bases
  
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_se4b[i, 3]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_criteria_se4b[i, 3]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                df_criteria_se4b[i, 3]),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0("rb_",
                   df_criteria_se4b[i, 3])))
  
  # apply the fuzzy partitions to the data
  
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    df_criteria_se4b[i, 3],
    ", newdata = df_irm_i2,",
    df_criteria_se4b[i, 3],
    "=",
    "fp_",
    df_criteria_se4b[i, 3],
    ")"
  )
  
  # evaluate the rule base and create the fpm
  
  assign(paste0("fpm_",
                df_criteria_se4b[i, 3]), eval(parse(text = x)))
  
  # get the membership values from the fpm
  
  g_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se4b[i, 3]))$good)
  p_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se4b[i, 3]))$poor)
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_se4b[i, 3], "_g")) := g_col, .keep = c("all"))
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_se4b[i, 3], "_p")) := p_col, .keep = c("all"))
  
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se4b[i, 3], "_g")), as.character(paste0(df_criteria_se4b[i, 3], "_p")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se4b[i, 4], " good")), as.character(paste0(df_criteria_se4b[i, 4], " poor")))
  fpm_plot_title <-
    "Labour\noptimality\nmembership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
  print(plot_fpm)
  
  
}

``` 
</div>

```{r i2_requirements_fp_access01, echo=FALSE, results='asis', eval=fp_crit}

cat("### Fertilisers and Pesticides requirements")

```


```{r i2_requirements_fp_access02, results='asis', warning=FALSE, eval=fp_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria

df_criteria_se4c <-
  subset(df_priorities, grepl("^se_4c", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cse4c <- nrow(df_criteria_se4c)
cat(paste(n_cse4c, "Fertilisers and Pesticides criteria: \n\n"))

# then determine and print the names of the rule bases in the Fertilisers and Pesticides theme
# here in contrast to the previous themes we need to account for criteria which have no data but instead use rule base stacks - these are removed now from the criteria data frame and evaluated later

data_rulebase <- !is.na(df_criteria_se4c$data_file_prefix)
df_criteria_se4c <- df_criteria_se4c[data_rulebase,]

n_cse4c <- nrow(df_criteria_se4c)

cat(paste(n_cse4c, "Fertilisers and Pesticides data rule bases:\n\n"))
for (i in 1:n_cse4c) {
  cat(paste(df_criteria_se4c[i, 3], "\n", df_criteria_se4c[i, 4],"\n"))
}

```

<div class="fold o">   
```{r i2_requirements_fp_access03, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=fp_crit}

for (i in 1:n_cse4c) {
  new_col <-
    get(paste0("rast_", df_criteria_se4c[i, 11], "_rsmp")) %>% terra::extract(xy) # extract the raster values using xy points
  
  new_col <- new_col[[1]]
  
  
  
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_se4c[i, 3])) := new_col, .keep = c("all"))   # add the raster values to the df_irm_i2 tibble, this needs to be dynamic so uses the !! and := operators
  
}

```
</div>

```{r i2_requirements_fp_access04, echo=FALSE, results='asis', eval=fp_crit}

cat("#### Fertilisers and Pesticides optimality

We used the requirements to construct fuzzy partitions and the data rule bases.")

```


<div class="fold o">   
```{r i2_requirements_fp_access05, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", fig.show="hold", warning=FALSE, eval=fp_crit}

for (i in 1:(nrow(df_criteria_se4c))) {
  if (!is.na(df_criteria_se4c[i, 18])) {
    # for those criteria with three proposition values
    # get  the 3 proposition levels
    prop_levels <-
      c(
        as.character(df_criteria_se4c[i, 16]),
        as.character(df_criteria_se4c[i, 17]),
        as.character(df_criteria_se4c[i, 18])
      )
    
    # get  the 3 conclusion levels
    conc_levels <-
      c(
        as.character(df_criteria_se4c[i, 19]),
        as.character(df_criteria_se4c[i, 20]),
        as.character(df_criteria_se4c[i, 21])
      )
    # get  the 2 crossover points
    cross_points <-
      c(df_criteria_se4c[i, 6],
        df_criteria_se4c[i, 7])
    
    # get  the 2 transition widths
    trans_width <-
      c(df_criteria_se4c[i, 8],
        df_criteria_se4c[i, 9])
    
    # get  the 2 xlims for the plot
    plot_xlim <-
      c((df_criteria_se4c[i, 6] - df_criteria_se4c[i, 8]),
        (df_criteria_se4c[i, 7] + df_criteria_se4c[i, 9]))
    
    
  } else {
    # for those criteria with two proposition values
    # get  the 2 proposition levels
    prop_levels <-
      c(as.character(df_criteria_se4c[i, 16]),
        as.character(df_criteria_se4c[i, 17]))
    
    # get  the 2 conclusion levels
    conc_levels <-
      c(as.character(df_criteria_se4c[i, 19]),
        as.character(df_criteria_se4c[i, 20]))
    
    # get  the 1 crossover point
    cross_points <-
      c(df_criteria_se4c[i, 6])
    
    # get  the 1 transition width
    trans_width <-
      c(df_criteria_se4c[i, 8])
    
    # get  the 1 xlim for the plot
    plot_xlim <-
      c((df_criteria_se4c[i, 6] - df_criteria_se4c[i, 8]),
        (df_criteria_se4c[i, 6] + df_criteria_se4c[i, 8]))
    
  }
  assign(
    paste0("fp_", df_criteria_se4c[i, 3]),
    LinearFuzzyPartition(
      level =  prop_levels,
      crossoverPoint  = cross_points,
      transitionWidth = trans_width
    )
  )
  
  plot_fp <-
    plot(
      get(paste0("fp_", df_criteria_se4c[i, 3])),
      xlim = plot_xlim,
      xlab = as.character(df_criteria_se4c[i, 4]),
      title = "fuzzy partition"
    )
  print(plot_fp)
  
  # construct the rule bases
  
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_se4c[i, 3]))
  # set the conclusion name
  Conc_name <-
    paste0(as.character(df_criteria_se4c[i, 3]),
           "_o")
  
  # thanks to https://stackoverflow.com/questions/45741498/add-column-in-tibble-with-variable-column-name for the following dynamic assignment of variable names in a tibble
  
  # set the proposition values
  df_prop <- tibble(!!Prop_name := c(prop_levels))
  # set the conclusion values
  df_conc <- tibble(!!Conc_name := c(conc_levels))
  
  # new proposition and conclusion class objects are made here
  new_prop <- new("Proposition", table = df_prop)
  new_conc <- new("Conclusion", table = df_conc)
  
  assign(paste0("rb_",
                df_criteria_se4c[i, 3]),
         
         RuleBase(new_prop, new_conc))
  
  print(get(paste0("rb_",
                   df_criteria_se4c[i, 3])))
  
  # apply the fuzzy partitions to the data
  
  
  # first construct the predict function with all arguments as text
  
  x <- paste0(
    "predict(rb_",
    df_criteria_se4c[i, 3],
    ", newdata = df_irm_i2,",
    df_criteria_se4c[i, 3],
    "=",
    "fp_",
    df_criteria_se4c[i, 3],
    ")"
  )
  
  # evaluate the rule base and create the fpm
  
  assign(paste0("fpm_",
                df_criteria_se4c[i, 3]), eval(parse(text = x)))
  
  # get the membership values from the fpm
  
  g_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se4c[i, 3]))$good)
  p_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se4c[i, 3]))$poor)
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_se4c[i, 3], "_g")) := g_col, .keep = c("all"))
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_se4c[i, 3], "_p")) := p_col, .keep = c("all"))
  
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se4c[i, 3], "_g")), as.character(paste0(df_criteria_se4c[i, 3], "_p")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se4c[i, 4], " good")), as.character(paste0(df_criteria_se4c[i, 4], " poor")))
  fpm_plot_title <-
    "Fertilisers\nand Pesticides\noptimality\nmembership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
  print(plot_fpm)
  
  
}

``` 
</div>

# Rule Base Creation and Evaluation

We will not construct one big rule base but follow a hierarchical approach consisting of many small interrelated rule bases for the following reasons:

- one big rule base is hard, if not impossible, to understand
- a set of smaller hierarchically organised rule bases gives more information about the limiting factors
- a hierarchically structured rule base is much faster and less memory demanding.
- a hierarchically structured rule base gives exactly the same results as one big rule base.

If we have both bio-physical and socio-economic criteria then these have separate rule bases, and are combined to give the Likelihood for Adoption.

```{r i2_rulebases_ba01, echo=FALSE, results='asis', eval=ba_crit}
cat("## Bio-physical rule bases

There are no weights attached to the biophysical rule bases and it would be possible to create a single rule base with each criterion as propositions. However, this would be difficult to visualise and to interpret.

By constructing and evaluating smaller thematic rule bases it is possible to identify criteria that limit the biophysical aptitude.
")
```

```{r i2_rulebases_land01, echo=FALSE, results='asis', eval=land_crit}

cat("### Land rule bases

")
```

<div class="fold o"> 
```{r i2_rulebases_land02, cache = TRUE, warning=FALSE, eval=land_crit}

  df_criteria_ba1_2a <-
    subset(df_priorities, grepl("^ba_2a", df_priorities$rulebase_number)) # use regular expressions to find criteria
  n_cba1_2a <- nrow(df_criteria_ba1_2a)
  
  # put the rulebase in a list for use later in the overall biophysical aptitude
  
  assign(paste0("rbs_", df_criteria_ba1_2a[1, 3], "_list"),
         paste0("rb_", df_criteria_ba1_2a[1, 3])) # initialise the rule base list
  
  # get a list of the fuzzy partitions
  assign(
    paste0("fp_", df_criteria_ba1_2a[1, 3], "_list"),
    paste0( df_criteria_ba1_2a[1, 3]," = fp_",
    df_criteria_ba1_2a[1, 3] ))


```
</div>

```{r i2_rulebases_clim01, echo=FALSE, results='asis', eval=clim_crit}

cat("### Climatic rule bases")
```

```{r i2_rulebases_prec01, echo=FALSE, results='asis', eval=prec_crit}

cat("#### Precipitation rule bases

")
```


<div class="fold o"> 
```{r i2_rulebases_prec02, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, warning=FALSE, eval=prec_crit}

df_criteria_ba2b_3a <-
  subset(df_priorities, grepl("^ba_3a", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cba2b_3a <- nrow(df_criteria_ba2b_3a)

# df_criteria_ba3a includes all of the precipitation criteria
# for each criterion we know that the new proposition is the same as the conclusion from the previous rule base

assign(paste0("rbs_", df_criteria_ba2b_3a[1, 3], "_list"), c()) # initialise the rule base list
assign(paste0("fp_", df_criteria_ba2b_3a[1, 3], "_list"), c()) # initialise the fuzzy partition list
rm(df_prop) # remove previous instances of df_prop
rm(df_conc) # remove previous instances of df_prop
rm(prop)
rm(conc)
for (i in 1:(nrow(df_criteria_ba3a))) {
  if (!is.na(df_criteria_ba3a[i, 18])) {
    # set the proposition name
    Prop_name <-
      paste0(as.character(df_criteria_ba3a[i, 3]), "_o")
    
    # for those criteria with three conclusion values
    # get  the 3 conclusion levels and get the unique values
    prop_levels <-
      c(
        as.character(df_criteria_ba3a[i, 19]),
        as.character(df_criteria_ba3a[i, 20]),
        as.character(df_criteria_ba3a[i, 21])
      )  %>% unique()
    
    
    
    # set the proposition values
    if (!exists("df_prop")) {
      df_prop <- tibble(!!Prop_name := c(prop_levels))
    } else {
      #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
      df_prop <-
        bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
    }
    
    # get a list of the previous rule bases
    assign(paste0("rbs_", df_criteria_ba2b_3a[1, 3], "_list"),
           append(get(
             paste0("rbs_", df_criteria_ba2b_3a[1, 3], "_list")
           ), paste0("rb_", df_criteria_ba3a[i, 3])))
    
    # get a list of the fuzzy partitions
    assign(paste0("fp_", df_criteria_ba2b_3a[1, 3], "_list"),
           append(
             get(paste0("fp_", df_criteria_ba2b_3a[1, 3], "_list")),
             paste0(df_criteria_ba3a[i, 3], " = fp_", df_criteria_ba3a[i, 3])
           ))
  } else {
    # set the proposition name
    Prop_name <-
      paste0(as.character(df_criteria_ba3a[i, 3]), "_o")
    
    # for those criteria with two conclusion values
    # get  the 2 conclusion levels and get the unique values
    prop_levels <-
      c(as.character(df_criteria_ba3a[i, 19]),
        as.character(df_criteria_ba3a[i, 20]))  %>% unique()
    
    
    # set the proposition values
    if (!exists("df_prop")) {
      df_prop <- tibble(!!Prop_name := c(prop_levels))
    } else {
      #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
      df_prop <-
        bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
    }
    
    # get a list of the previous rule bases
    assign(paste0("rbs_", df_criteria_ba2b_3a[1, 3], "_list"),
           append(get(
             paste0("rbs_", df_criteria_ba2b_3a[1, 3], "_list")
           ), paste0("rb_", df_criteria_ba3a[i, 3])))
    
    # get a list of the fuzzy partitions
    assign(paste0("fp_", df_criteria_ba2b_3a[1, 3], "_list"),
           append(
             get(paste0("fp_", df_criteria_ba2b_3a[1, 3], "_list")),
             paste0(df_criteria_ba3a[i, 3], " = fp_", df_criteria_ba3a[i, 3])
           ))
    
  }
}

# new proposition object is made here
prop <- new("Proposition", table = df_prop %>% cross_df)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here
# needs to moe or less replicate the original ifelse construction:

#  df_conc <-
#    mutate(tbl_prop_cross, P = ifelse(((tbl_prop_cross[1] == "optimal") &
#                                     (tbl_prop_cross[2] == "optimal") &
#                                     (tbl_prop_cross[3] == "optimal") &
#                                     (tbl_prop_cross[4] == "optimal")
#    ), "optimal", "suboptimal")) %>% dplyr::select(P) # this works


#z <- paste0("ifelse (1 == 1, 1, 2)")
#y <- eval(parse(text = "ifelse(1==1, 1,2)"))
#y <- NULL
#y <- eval(parse(text = z)) # this works

#z <- paste0("ifelse (1 == 1, \"optimal\", \"suboptimal\")")
#y <- NULL
#y <- eval(parse(text = z)) # this works

#z <- paste0(
#  "ifelse (((tbl_prop_cross[1] == \"optimal\") &
#                                   (tbl_prop_cross[2] == \"optimal\") &
#                                   (tbl_prop_cross[3] == \"optimal\") &
#                                   (tbl_prop_cross[4] == \"optimal\")
#  ), \"optimal\", \"suboptimal\")"
#)
#y <- NULL
#y <- eval(parse(text = z)) # this works


# build the ifelse expression based on number of propositions

x <- 1
z <- NULL
while (x <= n_prop)  {
  z <- paste0(z, "(tbl_prop_cross[", x, "] == \"optimal\") &")
  x <- x + 1
}

z <-
  paste0("ifelse ((", z, " 1 == 1), \"optimal\", \"suboptimal\")")
df_conc <- NULL

# evaluate the ifelse expression to produce a conclusion table and class
df_conc <- eval(parse(text = z)) %>% as_tibble()
names(df_conc) <- df_criteria_ba2b_3a[1, 3] # this works
conc <- new("Conclusion", table = df_conc)

# create a rule base
assign(paste0("rb_", df_criteria_ba2b_3a[1, 3]), RuleBase(prop, conc)) %>% print()

#           RuleBase <- RuleBase(prop, conc) %>% print()


# add to the list of previous rule bases

assign(paste0("rbs_", df_criteria_ba2b_3a[1, 3], "_list"),
       append(get(
         paste0("rbs_", df_criteria_ba2b_3a[1, 3], "_list")
       ), paste0("rb_", df_criteria_ba2b_3a[1, 3])))

# create the rule base stack from the list

# original rbs_prec_aptitude <- stack(rb_prec_g_4a, rb_prec_v_4b, rb_prec_f_4c, rb_prec_r_4d, rb_P_3a)

#assign(
#  paste0("rbs_", df_criteria_ba3a[1, 3]),
#  stack(rb_ba_4a, rb_ba_4b, rb_ba_4c, rb_ba_4d, rb_ba_3a)
#) # this works

#x <- rbs_ba_4a_list
#print(x)

#x <- paste0(rbs_ba_4a_list, sep = ",")
#print(x)

#x <- paste0(rbs_ba_4a_list, sep = ",", collapse = "")
#print(x)

#x <- gsub(",$", "", paste0(rbs_ba_4a_list, sep = ",", collapse = ""))
#print(x)

#x <-
#  paste("stack(", gsub(",$", "", paste0(
#    rbs_ba_4a_list, sep = ",", collapse = ""
#  )), ")")
#print(x)

x <-
  paste("stack(", gsub(",$", "", paste0(
    get(paste0("rbs_", df_criteria_ba2b_3a[1, 3], "_list")), sep = ",", collapse = ""
  )), ")")

rbs_prec <-
  assign(paste0("rbs_", df_criteria_ba2b_3a[1, 3]), eval(parse(text = x)))

# evaluate the rule base stack
# this is the original

#fpm_prec <-
# predict(
#      rbs_prec_aptitude,
#      newdata = df_irm_i2,
#      P_g = fp_prec_g,
#      P_v = fp_prec_v,
#      P_f = fp_prec_f,
#     P_r = fp_prec_r
#  )

# add to the list of previous rule bases



w <-
  paste("predict(",
        "rbs_prec, newdata = df_irm_i2,",
        gsub(",$", "", paste0(
          get(paste0("fp_", df_criteria_ba2b_3a[1, 3], "_list")), sep = ",", collapse = ""
        )),
        ")")

assign(paste0("fpm_", df_criteria_ba2b_3a[1, 3]), eval(parse(text = w)))


o_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba2b_3a[1, 3]))$optimal)
s_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba2b_3a[1, 3]))$suboptimal)
df_irm_i2 <-
  mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba2b_3a[1, 3], "_o")) := o_col, .keep = c("all"))
df_irm_i2 <-
  mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba2b_3a[1, 3], "_s")) := s_col, .keep = c("all"))

n = 2
fpm_conc_var <-
  c(as.character(paste0(df_criteria_ba2b_3a[1, 3], "_o")), as.character(paste0(df_criteria_ba2b_3a[1, 3], "_s")), "x" , "y")
fpm_conc_name <-
  c(as.character(paste0(df_criteria_ba2b_3a[1, 4], " optimal")), as.character(paste0(df_criteria_ba2b_3a[1, 4], " suboptimal")))
fpm_plot_title <-
  "Precipitation optimality membership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
print(plot_fpm)

```
</div>

```{r i2_rulebases_tmp01, echo=FALSE, results='asis', eval=tmp_crit}

cat("#### Temperature rule bases

")
```

<div class="fold o"> 
```{r i2_rulebases_tmp02, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, warning=FALSE, eval=tmp_crit}

df_criteria_ba2b_3b <-
  subset(df_priorities, grepl("^ba_3b", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cba2b_3b <- nrow(df_criteria_ba2b_3b)

# df_criteria_ba3b includes all of the temperature criteria
# for each criterion we know that the new proposition is the same as the conclusion from the previous rule base

assign(paste0("rbs_", df_criteria_ba2b_3b[1, 3], "_list"), c()) # initialise the rule base list
assign(paste0("fp_", df_criteria_ba2b_3b[1, 3], "_list"), c()) # initialise the fuzzy partition list
rm(df_prop) # remove previous instances of df_prop
rm(df_conc) # remove previous instances of df_prop
rm(prop)
rm(conc)
for (i in 1:(nrow(df_criteria_ba3b))) {
  if (!is.na(df_criteria_ba3b[i, 18])) {
    # set the proposition name
    Prop_name <-
      paste0(as.character(df_criteria_ba3b[i, 3]), "_o")
    
    # for those criteria with three conclusion values
    # get  the 3 conclusion levels and get the unique values
    prop_levels <-
      c(
        as.character(df_criteria_ba3b[i, 19]),
        as.character(df_criteria_ba3b[i, 20]),
        as.character(df_criteria_ba3b[i, 21])
      )  %>% unique()
    
    
    
    # set the proposition values
    if (!exists("df_prop")) {
      df_prop <- tibble(!!Prop_name := c(prop_levels))
    } else {
      #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
      df_prop <-
        bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
    }
    
    # get a list of the previous rule bases
    assign(paste0("rbs_", df_criteria_ba2b_3b[1, 3], "_list"),
           append(get(
             paste0("rbs_", df_criteria_ba2b_3b[1, 3], "_list")
           ), paste0("rb_", df_criteria_ba3b[i, 3])))
    
    # get a list of the fuzzy partitions
    assign(paste0("fp_", df_criteria_ba2b_3b[1, 3], "_list"),
           append(
             get(paste0("fp_", df_criteria_ba2b_3b[1, 3], "_list")),
             paste0(df_criteria_ba3b[i, 3], " = fp_", df_criteria_ba3b[i, 3])
           ))
  }
}

# new proposition object is made here
prop <- new("Proposition", table = df_prop %>% cross_df)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here
# needs to more or less replicate the original ifelse construction:

# build the ifelse expression based on number of propositions

x <- 1
z <- NULL
while (x <= n_prop)  {
  z <- paste0(z, "(tbl_prop_cross[", x, "] == \"optimal\") &")
  x <- x + 1
}

z <-
  paste0("ifelse ((", z, " 1 == 1), \"optimal\", \"suboptimal\")")
df_conc <- NULL

# evaluate the ifelse expression to produce a conclusion table and class
df_conc <- eval(parse(text = z)) %>% as_tibble()
names(df_conc) <- df_criteria_ba2b_3b[1, 3] # this works
conc <- new("Conclusion", table = df_conc)

# create a rule base
assign(paste0("rb_", df_criteria_ba2b_3b[1, 3]), RuleBase(prop, conc)) %>% print()


# add to the list of previous rule bases

assign(paste0("rbs_", df_criteria_ba2b_3b[1, 3], "_list"),
       append(get(
         paste0("rbs_", df_criteria_ba2b_3b[1, 3], "_list")
       ), paste0("rb_", df_criteria_ba2b_3b[1, 3])))

# create the rule base stack from the list

# original rbs_tmp_aptitude <- stack(rb_tmp_g_4a, rb_tmp_v_4b, rb_tmp_f_4c, rb_tmp_r_4d, rb_P_3a)

x <-
  paste("stack(", gsub(",$", "", paste0(
    get(paste0("rbs_", df_criteria_ba2b_3b[1, 3], "_list")), sep = ",", collapse = ""
  )), ")")

rbs_tmp <-
  assign(paste0("rbs_", df_criteria_ba2b_3b[1, 3]), eval(parse(text = x)))

# evaluate the rule base stack

w <-
  paste("predict(",
        "rbs_tmp, newdata = df_irm_i2,",
        gsub(",$", "", paste0(
          get(paste0("fp_", df_criteria_ba2b_3b[1, 3], "_list")), sep = ",", collapse = ""
        )),
        ")")

assign(paste0("fpm_", df_criteria_ba2b_3b[1, 3]), eval(parse(text = w)))


o_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba2b_3b[1, 3]))$optimal)
s_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba2b_3b[1, 3]))$suboptimal)
df_irm_i2 <-
  mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba2b_3b[1, 3], "_o")) := o_col, .keep = c("all"))
df_irm_i2 <-
  mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba2b_3b[1, 3], "_s")) := s_col, .keep = c("all"))

n = 2
fpm_conc_var <-
  c(as.character(paste0(df_criteria_ba2b_3b[1, 3], "_o")), as.character(paste0(df_criteria_ba2b_3b[1, 3], "_s")), "x" , "y")
fpm_conc_name <-
  c(as.character(paste0(df_criteria_ba2b_3b[1, 4], " optimal")), as.character(paste0(df_criteria_ba2b_3b[1, 4], " suboptimal")))
fpm_plot_title <-
  "Temperature\noptimality\nmembership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
print(plot_fpm)


```
</div>

```{r i2_rulebases_clim02, echo=FALSE, results='asis', eval=clim_crit}

cat("#### Combined Climatic Aptitude rule bases

")

```

<div class="fold o"> 
```{r i2_rulebases_clim03, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, warning=FALSE, eval=prec_crit, eval=tmp_crit}

# need to join the rule base stacks for precipitation and temperature

df_criteria_ba1_2b <-
  subset(df_priorities, grepl("^ba_2b", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cba1_2b <- nrow(df_criteria_ba1_2b)

df_criteria_ba2b <-
  subset(df_priorities, grepl("^ba_2b", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cba2b <- nrow(df_criteria_ba2b)

assign(paste0("rbs_", df_criteria_ba2b[1, 2], "_list"), c()) # initialise the rule base list
assign(paste0("fp_", df_criteria_ba2b[1, 2], "_list"), c()) # initialise the fuzzy partition list

# need to construct a new rule base for climatic aptitude and add this to the combined rule base stacks and fill the rb and fp lists


rm(df_prop) # remove previous instances of df_prop
rm(df_conc) # remove previous instances of df_prop
rm(prop)
rm(conc)

for (i in 1:n_cba2b) {
  assign(paste0("rbs_", df_criteria_ba2b[1, 2], "_list"),
         append(get(
           paste0("rbs_", df_criteria_ba2b[1, 2], "_list")
         ), get(
           paste0("rbs_", df_criteria_ba2b[i, 3], "_list")
         )))
  
  assign(paste0("fp_", df_criteria_ba2b[1, 2], "_list"),
         append(get(paste0(
           "fp_", df_criteria_ba2b[1, 2], "_list"
         )), get(paste0(
           "fp_", df_criteria_ba2b[i, 3], "_list"
         ))))
  
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_ba2b[i, 3]))
  
  # get  the 2 conclusion levels and get the unique values
  prop_levels <-
    c(as.character(df_criteria_ba2b[i, 19]),
      as.character(df_criteria_ba2b[i, 20]))  %>% unique()
  
  
  # set the proposition values
  if (!exists("df_prop")) {
    df_prop <- tibble(!!Prop_name := c(prop_levels))
  } else {
    #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
    df_prop <-
      bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
  }
}


# new proposition object is made here
prop <- new("Proposition", table = df_prop %>% cross_df)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here
# needs to more or less replicate the original ifelse construction:

# build the ifelse expression based on number of propositions

x <- 1
z <- NULL
while (x <= n_prop)  {
  z <- paste0(z, "(tbl_prop_cross[", x, "] == \"optimal\") &")
  x <- x + 1
}

z <-
  paste0("ifelse ((", z, " 1 == 1), \"optimal\", \"suboptimal\")")
df_conc <- NULL

# evaluate the ifelse expression to produce a conclusion table and class
df_conc <- eval(parse(text = z)) %>% as_tibble()
names(df_conc) <- df_criteria_ba2b[1, 2] # this works
conc <- new("Conclusion", table = df_conc)

# create a rule base
assign(paste0("rb_", df_criteria_ba2b[1, 2]), RuleBase(prop, conc)) %>% print()

# add to the list of previous rule bases

assign(paste0("rbs_", df_criteria_ba2b[1, 2], "_list"),
       append(get(paste0(
         "rbs_", df_criteria_ba2b[1, 2], "_list"
       )), paste0("rb_", df_criteria_ba2b[1, 2])))



# create the rule base stack from the list

# original rbs_tmp_aptitude <- stack(rb_tmp_g_4a, rb_tmp_v_4b, rb_tmp_f_4c, rb_tmp_r_4d, rb_P_3a)

x <-
  paste("stack(", gsub(",$", "", paste0(
    get(paste0("rbs_", df_criteria_ba2b[1, 2], "_list")), sep = ",", collapse = ""
  )), ")")

rbs_tmp <-
  assign(paste0("rbs_", df_criteria_ba2b[1, 2]), eval(parse(text = x)))

# evaluate the rule base stack

w <-
  paste("predict(",
        "rbs_tmp, newdata = df_irm_i2,",
        gsub(",$", "", paste0(
          get(paste0("fp_", df_criteria_ba2b[1, 2], "_list")), sep = ",", collapse = ""
        )),
        ")")

assign(paste0("fpm_", df_criteria_ba2b[1, 2]), eval(parse(text = w)))


o_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba2b[1, 2]))$optimal)
s_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba2b[1, 2]))$suboptimal)
df_irm_i2 <-
  mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba2b[1, 2], "_o")) := o_col, .keep = c("all"))
df_irm_i2 <-
  mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba2b[1, 2], "_s")) := s_col, .keep = c("all"))

n = 2
fpm_conc_var <-
  c(as.character(paste0(df_criteria_ba2b[1, 2], "_o")), as.character(paste0(df_criteria_ba2b[1, 2], "_s")), "x" , "y")
fpm_conc_name <-
  c(as.character(paste0(df_criteria_ba1_2b[1, 4], " optimal")), as.character(paste0(df_criteria_ba1_2b[1, 4], " suboptimal")))
fpm_plot_title <-
  "Climatic Aptitude membership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
print(plot_fpm)


```
</div>


```{r i2_rulebases_soilp01, echo=FALSE, results='asis', eval=soil_p_crit}

cat("### Soil physical properties rule bases

")

```

<div class="fold o"> 
```{r i2_rulebases_soilp02, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, warning=FALSE, eval=soil_p_crit}

df_criteria_ba1_2c <-
  subset(df_priorities, grepl("^ba_2c", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cba1_2c <- nrow(df_criteria_ba1_2c)

# df_criteria_ba2c includes all of the soil physical properties criteria
# for each criterion we know that the new proposition is the same as the conclusion from the previous rule base

assign(paste0("rbs_", df_criteria_ba1_2c[1, 3], "_list"), c()) # initialise the rule base list
assign(paste0("fp_", df_criteria_ba1_2c[1, 3], "_list"), c()) # initialise the fuzzy partition list
rm(df_prop) # remove previous instances of df_prop
rm(df_conc) # remove previous instances of df_prop
rm(prop)
rm(conc)
for (i in 1:(nrow(df_criteria_ba2c))) {
  if (!is.na(df_criteria_ba2c[i, 18])) {
    # set the proposition name
    Prop_name <-
      paste0(as.character(df_criteria_ba2c[i, 3]), "_o")
    
    # for those criteria with three conclusion values
    # get  the 3 conclusion levels and get the unique values
    prop_levels <-
      c(
        as.character(df_criteria_ba2c[i, 19]),
        as.character(df_criteria_ba2c[i, 20]),
        as.character(df_criteria_ba2c[i, 21])
      )  %>% unique()
    
    
    
    # set the proposition values
    if (!exists("df_prop")) {
      df_prop <- tibble(!!Prop_name := c(prop_levels))
    } else {
      #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
      df_prop <-
        bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
    }
    
    # get a list of the previous rule bases
    assign(paste0("rbs_", df_criteria_ba1_2c[1, 3], "_list"),
           append(get(
             paste0("rbs_", df_criteria_ba1_2c[1, 3], "_list")
           ), paste0("rb_", df_criteria_ba2c[i, 3])))
    
    # get a list of the fuzzy partitions
    assign(paste0("fp_", df_criteria_ba1_2c[1, 3], "_list"),
           append(
             get(paste0("fp_", df_criteria_ba1_2c[1, 3], "_list")),
             paste0(df_criteria_ba2c[i, 3], " = fp_", df_criteria_ba2c[i, 3])
           ))
  } else {
    # set the proposition name
    Prop_name <-
      paste0(as.character(df_criteria_ba2c[i, 3]), "_o")
    
    # for those criteria with two conclusion values
    # get  the 2 conclusion levels and get the unique values
    prop_levels <-
      c(as.character(df_criteria_ba2c[i, 19]),
        as.character(df_criteria_ba2c[i, 20]))  %>% unique()
    
    
    # set the proposition values
    if (!exists("df_prop")) {
      df_prop <- tibble(!!Prop_name := c(prop_levels))
    } else {
      #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
      df_prop <-
        bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
    }
    
    # get a list of the previous rule bases
    assign(paste0("rbs_", df_criteria_ba1_2c[1, 3], "_list"),
           append(get(
             paste0("rbs_", df_criteria_ba1_2c[1, 3], "_list")
           ), paste0("rb_", df_criteria_ba2c[i, 3])))
    
    # get a list of the fuzzy partitions
    assign(paste0("fp_", df_criteria_ba1_2c[1, 3], "_list"),
           append(
             get(paste0("fp_", df_criteria_ba1_2c[1, 3], "_list")),
             paste0(df_criteria_ba2c[i, 3], " = fp_", df_criteria_ba2c[i, 3])
           ))
    
  }
}

# new proposition object is made here
prop <- new("Proposition", table = df_prop %>% cross_df)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here
# needs to more or less replicate the original ifelse construction:

# build the ifelse expression based on number of propositions

x <- 1
z <- NULL
while (x <= n_prop)  {
  z <- paste0(z, "(tbl_prop_cross[", x, "] == \"optimal\") &")
  x <- x + 1
}

z <-
  paste0("ifelse ((", z, " 1 == 1), \"optimal\", \"suboptimal\")")
df_conc <- NULL

# evaluate the ifelse expression to produce a conclusion table and class
df_conc <- eval(parse(text = z)) %>% as_tibble()
names(df_conc) <- df_criteria_ba1_2c[1, 3] # this works
conc <- new("Conclusion", table = df_conc)

# create a rule base
assign(paste0("rb_", df_criteria_ba1_2c[1, 3]), RuleBase(prop, conc)) %>% print()


# add to the list of previous rule bases

assign(paste0("rbs_", df_criteria_ba1_2c[1, 3], "_list"),
       append(get(
         paste0("rbs_", df_criteria_ba1_2c[1, 3], "_list")
       ), paste0("rb_", df_criteria_ba1_2c[1, 3])))

# create the rule base stack from the list

x <-
  paste("stack(", gsub(",$", "", paste0(
    get(paste0("rbs_", df_criteria_ba1_2c[1, 3], "_list")), sep = ",", collapse = ""
  )), ")")

rbs_tmp <-
  assign(paste0("rbs_", df_criteria_ba1_2c[1, 3]), eval(parse(text = x)))

# evaluate the rule base stack

w <-
  paste("predict(",
        "rbs_tmp, newdata = df_irm_i2,",
        gsub(",$", "", paste0(
          get(paste0("fp_", df_criteria_ba1_2c[1, 3], "_list")), sep = ",", collapse = ""
        )),
        ")")

assign(paste0("fpm_", df_criteria_ba1_2c[1, 3]), eval(parse(text = w)))


o_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba1_2c[1, 3]))$optimal)
s_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba1_2c[1, 3]))$suboptimal)
df_irm_i2 <-
  mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba1_2c[1, 3], "_o")) := o_col, .keep = c("all"))
df_irm_i2 <-
  mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba1_2c[1, 3], "_s")) := s_col, .keep = c("all"))

n = 2
fpm_conc_var <-
  c(as.character(paste0(df_criteria_ba1_2c[1, 3], "_o")), as.character(paste0(df_criteria_ba1_2c[1, 3], "_s")), "x" , "y")
fpm_conc_name <-
  c(as.character(paste0(df_criteria_ba1_2c[1, 4], " optimal")), as.character(paste0(df_criteria_ba1_2c[1, 4], " suboptimal")))
fpm_plot_title <-
  "Soil Physical Properties optimality membership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
print(plot_fpm)


```
</div>

```{r i2_rulebases_soilf01, echo=FALSE, results='asis', eval=soil_f_crit}

cat("### Soil fertility rule bases

")

```

<div class="fold o"> 
```{r i2_rulebases_soilf02, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, warning=FALSE, eval=soil_f_crit}

df_criteria_ba1_2d <-
  subset(df_priorities, grepl("^ba_2d", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cba1_2d <- nrow(df_criteria_ba1_2d)

# df_criteria_ba2d includes all of the soil fertility criteria
# for each criterion we know that the new proposition is the same as the conclusion from the previous rule base

assign(paste0("rbs_", df_criteria_ba1_2d[1, 3], "_list"), c()) # initialise the rule base list
assign(paste0("fp_", df_criteria_ba1_2d[1, 3], "_list"), c()) # initialise the fuzzy partition list
rm(df_prop) # remove previous instances of df_prop
rm(df_conc) # remove previous instances of df_prop
rm(prop)
rm(conc)
for (i in 1:(nrow(df_criteria_ba2d))) {
  if (!is.na(df_criteria_ba2d[i, 18])) {
    # set the proposition name
    Prop_name <-
      paste0(as.character(df_criteria_ba2d[i, 3]), "_o")
    
    # for those criteria with three conclusion values
    # get  the 3 conclusion levels and get the unique values
    prop_levels <-
      c(
        as.character(df_criteria_ba2d[i, 19]),
        as.character(df_criteria_ba2d[i, 20]),
        as.character(df_criteria_ba2d[i, 21])
      )  %>% unique()
    
    
    
    # set the proposition values
    if (!exists("df_prop")) {
      df_prop <- tibble(!!Prop_name := c(prop_levels))
    } else {
      #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
      df_prop <-
        bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
    }
    
    # get a list of the previous rule bases
    assign(paste0("rbs_", df_criteria_ba1_2d[1, 3], "_list"),
           append(get(
             paste0("rbs_", df_criteria_ba1_2d[1, 3], "_list")
           ), paste0("rb_", df_criteria_ba2d[i, 3])))
    
    # get a list of the fuzzy partitions
    assign(paste0("fp_", df_criteria_ba1_2d[1, 3], "_list"),
           append(
             get(paste0("fp_", df_criteria_ba1_2d[1, 3], "_list")),
             paste0(df_criteria_ba2d[i, 3], " = fp_", df_criteria_ba2d[i, 3])
           ))
  } else {
    # set the proposition name
    Prop_name <-
      paste0(as.character(df_criteria_ba2d[i, 3]), "_o")
    
    # for those criteria with two conclusion values
    # get  the 2 conclusion levels and get the unique values
    prop_levels <-
      c(as.character(df_criteria_ba2d[i, 19]),
        as.character(df_criteria_ba2d[i, 20]))  %>% unique()
    
    
    # set the proposition values
    if (!exists("df_prop")) {
      df_prop <- tibble(!!Prop_name := c(prop_levels))
    } else {
      #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
      df_prop <-
        bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
    }
    
    # get a list of the previous rule bases
    assign(paste0("rbs_", df_criteria_ba1_2d[1, 3], "_list"),
           append(get(
             paste0("rbs_", df_criteria_ba1_2d[1, 3], "_list")
           ), paste0("rb_", df_criteria_ba2d[i, 3])))
    
    # get a list of the fuzzy partitions
    assign(paste0("fp_", df_criteria_ba1_2d[1, 3], "_list"),
           append(
             get(paste0("fp_", df_criteria_ba1_2d[1, 3], "_list")),
             paste0(df_criteria_ba2d[i, 3], " = fp_", df_criteria_ba2d[i, 3])
           ))
    
  }
}

# new proposition object is made here
prop <- new("Proposition", table = df_prop %>% cross_df)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here
# needs to more or less replicate the original ifelse construction:

# build the ifelse expression based on number of propositions

x <- 1
z <- NULL
while (x <= n_prop)  {
  z <- paste0(z, "(tbl_prop_cross[", x, "] == \"optimal\") &")
  x <- x + 1
}

z <-
  paste0("ifelse ((", z, " 1 == 1), \"optimal\", \"suboptimal\")")
df_conc <- NULL

# evaluate the ifelse expression to produce a conclusion table and class
df_conc <- eval(parse(text = z)) %>% as_tibble()
names(df_conc) <- df_criteria_ba1_2d[1, 3] # this works
conc <- new("Conclusion", table = df_conc)

# create a rule base
assign(paste0("rb_", df_criteria_ba1_2d[1, 3]), RuleBase(prop, conc)) %>% print()


# add to the list of previous rule bases

assign(paste0("rbs_", df_criteria_ba1_2d[1, 3], "_list"),
       append(get(
         paste0("rbs_", df_criteria_ba1_2d[1, 3], "_list")
       ), paste0("rb_", df_criteria_ba1_2d[1, 3])))

# create the rule base stack from the list

x <-
  paste("stack(", gsub(",$", "", paste0(
    get(paste0("rbs_", df_criteria_ba1_2d[1, 3], "_list")), sep = ",", collapse = ""
  )), ")")

rbs_tmp <-
  assign(paste0("rbs_", df_criteria_ba1_2d[1, 3]), eval(parse(text = x)))

# evaluate the rule base stack

w <-
  paste("predict(",
        "rbs_tmp, newdata = df_irm_i2,",
        gsub(",$", "", paste0(
          get(paste0("fp_", df_criteria_ba1_2d[1, 3], "_list")), sep = ",", collapse = ""
        )),
        ")")

assign(paste0("fpm_", df_criteria_ba1_2d[1, 3]), eval(parse(text = w)))


o_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba1_2d[1, 3]))$optimal)
s_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba1_2d[1, 3]))$suboptimal)
df_irm_i2 <-
  mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba1_2d[1, 3], "_o")) := o_col, .keep = c("all"))
df_irm_i2 <-
  mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba1_2d[1, 3], "_s")) := s_col, .keep = c("all"))

n = 2
fpm_conc_var <-
  c(as.character(paste0(df_criteria_ba1_2d[1, 3], "_o")), as.character(paste0(df_criteria_ba1_2d[1, 3], "_s")), "x" , "y")
fpm_conc_name <-
  c(as.character(paste0(df_criteria_ba1_2d[1, 4], " optimal")), as.character(paste0(df_criteria_ba1_2d[1, 4], " suboptimal")))
fpm_plot_title <-
  "Soil Fertility optimality membership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
print(plot_fpm)


```
</div>

```{r i2_rulebases_lscape01, echo=FALSE, results='asis', eval=lscape_crit}

cat("### Landscape rule bases

")

```

<div class="fold o"> 
```{r i2_rulebases_lscape02, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, warning=FALSE, eval=lscape_crit}

df_criteria_ba1_2e <-
  subset(df_priorities, grepl("^ba_2e", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cba1_2e <- nrow(df_criteria_ba1_2e)

# df_criteria_ba2e includes all of the landscape criteria
# for each criterion we know that the new proposition is the same as the conclusion from the previous rule base

assign(paste0("rbs_", df_criteria_ba1_2e[1, 3], "_list"), c()) # initialise the rule base list
assign(paste0("fp_", df_criteria_ba1_2e[1, 3], "_list"), c()) # initialise the fuzzy partition list
rm(df_prop) # remove previous instances of df_prop
rm(df_conc) # remove previous instances of df_prop
rm(prop)
rm(conc)
for (i in 1:(nrow(df_criteria_ba2e))) {
  if (!is.na(df_criteria_ba2e[i, 18])) {
    # set the proposition name
    Prop_name <-
      paste0(as.character(df_criteria_ba2e[i, 3]), "_o")
    
    # for those criteria with three conclusion values
    # get  the 3 conclusion levels and get the unique values
    prop_levels <-
      c(
        as.character(df_criteria_ba2e[i, 19]),
        as.character(df_criteria_ba2e[i, 20]),
        as.character(df_criteria_ba2e[i, 21])
      )  %>% unique()
    
    
    
    # set the proposition values
    if (!exists("df_prop")) {
      df_prop <- tibble(!!Prop_name := c(prop_levels))
    } else {
      #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
      df_prop <-
        bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
    }
    
    # get a list of the previous rule bases
    assign(paste0("rbs_", df_criteria_ba1_2e[1, 3], "_list"),
           append(get(
             paste0("rbs_", df_criteria_ba1_2e[1, 3], "_list")
           ), paste0("rb_", df_criteria_ba2e[i, 3])))
    
    # get a list of the fuzzy partitions
    assign(paste0("fp_", df_criteria_ba1_2e[1, 3], "_list"),
           append(
             get(paste0("fp_", df_criteria_ba1_2e[1, 3], "_list")),
             paste0(df_criteria_ba2e[i, 3], " = fp_", df_criteria_ba2e[i, 3])
           ))
  } else {
    # set the proposition name
    Prop_name <-
      paste0(as.character(df_criteria_ba2e[i, 3]), "_o")
    
    # for those criteria with two conclusion values
    # get  the 2 conclusion levels and get the unique values
    prop_levels <-
      c(as.character(df_criteria_ba2e[i, 19]),
        as.character(df_criteria_ba2e[i, 20]))  %>% unique()
    
    
    # set the proposition values
    if (!exists("df_prop")) {
      df_prop <- tibble(!!Prop_name := c(prop_levels))
    } else {
      #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
      df_prop <-
        bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
    }
    
    # get a list of the previous rule bases
    assign(paste0("rbs_", df_criteria_ba1_2e[1, 3], "_list"),
           append(get(
             paste0("rbs_", df_criteria_ba1_2e[1, 3], "_list")
           ), paste0("rb_", df_criteria_ba2e[i, 3])))
    
    # get a list of the fuzzy partitions
    assign(paste0("fp_", df_criteria_ba1_2e[1, 3], "_list"),
           append(
             get(paste0("fp_", df_criteria_ba1_2e[1, 3], "_list")),
             paste0(df_criteria_ba2e[i, 3], " = fp_", df_criteria_ba2e[i, 3])
           ))
    
  }
}

# new proposition object is made here
prop <- new("Proposition", table = df_prop %>% cross_df)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here
# needs to more or less replicate the original ifelse construction:

# build the ifelse expression based on number of propositions

x <- 1
z <- NULL
while (x <= n_prop)  {
  z <- paste0(z, "(tbl_prop_cross[", x, "] == \"optimal\") &")
  x <- x + 1
}

z <-
  paste0("ifelse ((", z, " 1 == 1), \"optimal\", \"suboptimal\")")
df_conc <- NULL

# evaluate the ifelse expression to produce a conclusion table and class
df_conc <- eval(parse(text = z)) %>% as_tibble()
names(df_conc) <- df_criteria_ba1_2e[1, 3] # this works
conc <- new("Conclusion", table = df_conc)

# create a rule base
assign(paste0("rb_", df_criteria_ba1_2e[1, 3]), RuleBase(prop, conc)) %>% print()


# add to the list of previous rule bases

assign(paste0("rbs_", df_criteria_ba1_2e[1, 3], "_list"),
       append(get(
         paste0("rbs_", df_criteria_ba1_2e[1, 3], "_list")
       ), paste0("rb_", df_criteria_ba1_2e[1, 3])))

# create the rule base stack from the list

x <-
  paste("stack(", gsub(",$", "", paste0(
    get(paste0("rbs_", df_criteria_ba1_2e[1, 3], "_list")), sep = ",", collapse = ""
  )), ")")

rbs_tmp <-
  assign(paste0("rbs_", df_criteria_ba1_2e[1, 3]), eval(parse(text = x)))

# evaluate the rule base stack

w <-
  paste("predict(",
        "rbs_tmp, newdata = df_irm_i2,",
        gsub(",$", "", paste0(
          get(paste0("fp_", df_criteria_ba1_2e[1, 3], "_list")), sep = ",", collapse = ""
        )),
        ")")

assign(paste0("fpm_", df_criteria_ba1_2e[1, 3]), eval(parse(text = w)))


o_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba1_2e[1, 3]))$optimal)
s_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_ba1_2e[1, 3]))$suboptimal)
df_irm_i2 <-
  mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba1_2e[1, 3], "_o")) := o_col, .keep = c("all"))
df_irm_i2 <-
  mutate(df_irm_i2, !!as.character(paste0(df_criteria_ba1_2e[1, 3], "_s")) := s_col, .keep = c("all"))

n = 2
fpm_conc_var <-
  c(as.character(paste0(df_criteria_ba1_2e[1, 3], "_o")), as.character(paste0(df_criteria_ba1_2e[1, 3], "_s")), "x" , "y")
fpm_conc_name <-
  c(as.character(paste0(df_criteria_ba1_2e[1, 4], " optimal")), as.character(paste0(df_criteria_ba1_2e[1, 4], " suboptimal")))
fpm_plot_title <-
  "Landscape optimality membership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
print(plot_fpm)


```
</div>

```{r i2_rulebases_ba02, echo=FALSE, results='asis', eval=ba_crit}

cat("### Combined Biophysical Aptitude - two class rule bases

")

```

<div class="fold o"> 
```{r i2_rulebases_ba03, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, warning=FALSE, eval=ba_crit}

# need to join the rule base stacks for all biophysical criteria themes 

  df_criteria_suit <-
    subset(df_priorities, grepl("^ba_1", df_priorities$rulebase_number)) # use regular expressions to find criteria
  n_csuit <- nrow(df_criteria_suit)
  
  df_criteria_ba1 <-
    subset(df_priorities, grepl("^ba_1", df_priorities$rulebase_stack)) # use regular expressions to find criteria
  n_cba1 <- nrow(df_criteria_ba1)
  
  assign(paste0("rbs_", df_criteria_ba1[1, 2], "_list"), c()) # initialise the rule base list
  assign(paste0("fp_", df_criteria_ba1[1, 2], "_list"), c()) # initialise the fuzzy partition list    
 
  # need to construct a new rule base for climatic aptitude and add this to the combined rule base stacks and fill the rb and fp lists
  
  
  rm(df_prop) # remove previous instances of df_prop
  rm(df_conc) # remove previous instances of df_prop
  rm(prop)
  rm(conc)
  
  for (i in 1:n_cba1) {
    assign(paste0("rbs_", df_criteria_ba1[1, 2], "_list"),
           append(get(
             paste0("rbs_", df_criteria_ba1[1, 2], "_list")
           ), get(
             paste0("rbs_", df_criteria_ba1[i, 3], "_list")
           )))
    
    assign(paste0("fp_", df_criteria_ba1[1, 2], "_list"),
           append(get(paste0(
             "fp_", df_criteria_ba1[1, 2], "_list"
           )), get(paste0(
             "fp_", df_criteria_ba1[i, 3], "_list"
           ))))
    
    # set the proposition name
    # normally this is just the rule base number, but for ag land this number should be suffixed with "_o"
    if (paste0(as.character(df_criteria_ba1[i, 3])) == "ba_2a") {
      Prop_name <-
        paste0(as.character(df_criteria_ba1[i, 3]), "_o")
    }
    else{
      Prop_name <-
        paste0(as.character(df_criteria_ba1[i, 3]))
    }
    
    # get  the 2 conclusion levels and get the unique values
    prop_levels <-
      c(as.character(df_criteria_ba1[i, 19]),
        as.character(df_criteria_ba1[i, 20]))  %>% unique()
    
    
    # set the proposition values
    if (!exists("df_prop")) {
      df_prop <- tibble(!!Prop_name := c(prop_levels))
    } else {
      #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
      df_prop <-
        bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
    }
  }

 
  # new proposition object is made here
  prop <- new("Proposition", table = df_prop %>% cross_df)
  tbl_prop_cross <- prop@table
  n_prop <- ncol(tbl_prop_cross)
  
  
  # new conclusion object is made here
  # needs to more or less replicate the original ifelse construction:
  
  # build the ifelse expression based on number of propositions
  
  x <- 1
  z <- NULL
  while (x <= n_prop)  {
    z <- paste0(z, "(tbl_prop_cross[", x, "] == \"optimal\") &")
    x <- x + 1
  }
  
  z <-
    paste0("ifelse ((", z, " 1 == 1), \"optimal\", \"suboptimal\")")
  df_conc <- NULL
  
  # evaluate the ifelse expression to produce a conclusion table and class
  df_conc <- eval(parse(text = z)) %>% as_tibble()
  names(df_conc) <- df_criteria_ba1[1, 2] # this works
  conc <- new("Conclusion", table = df_conc)
  
  # create a rule base
assign(paste0("rb_", df_criteria_ba1[1, 2]), RuleBase(prop, conc)) %>% print()
  
  # add to the list of previous rule bases
  
  assign(paste0("rbs_", df_criteria_ba1[1, 2], "_list"),
         append(get(
           paste0("rbs_", df_criteria_ba1[1, 2], "_list")
         ), paste0("rb_", df_criteria_ba1[1, 2])))


  
  # create the rule base stack from the list
  
  # original rbs_tmp_aptitude <- stack(rb_tmp_g_4a, rb_tmp_v_4b, rb_tmp_f_4c, rb_tmp_r_4d, rb_P_3a)
  
  x <-
    paste("stack(", gsub(",$", "", paste0(
      get(paste0("rbs_", df_criteria_ba1[1, 2], "_list")), sep = ",", collapse = ""
    )), ")")
 
  rbs_tmp <-  assign(paste0("rbs_", df_criteria_ba1[1, 2]), eval(parse(text = x)))

   # evaluate the rule base stack

    w <-
      paste("predict(", "rbs_tmp, newdata = df_irm_i2,", gsub(",$", "", paste0(
        get(paste0("fp_", df_criteria_ba1[1, 2], "_list")), sep = ",", collapse = ""
      )), ")")
    
    assign(paste0("fpm_", df_criteria_ba1[1, 2]), eval(parse(text = w)))
  
 
    o_col <- getMembership(get(paste0("fpm_",
                                      df_criteria_ba1[1, 2]))$optimal)
    s_col <- getMembership(get(paste0("fpm_",
                                      df_criteria_ba1[1, 2]))$suboptimal)
    df_irm_i2 <-
      mutate(df_irm_i2,!!as.character(paste0(df_criteria_ba1[1, 2], "_o")) := o_col, .keep = c("all"))
    df_irm_i2 <-
      mutate(df_irm_i2,!!as.character(paste0(df_criteria_ba1[1, 2], "_s")) := s_col, .keep = c("all"))
    
    n = 2
    fpm_conc_var <-
      c(as.character(paste0(df_criteria_ba1[1, 2], "_o")), as.character(paste0(df_criteria_ba1[1, 2], "_s")), "x" , "y")
    fpm_conc_name <-
      c(as.character(paste0(df_criteria_suit[1, 4], " optimal")), as.character(paste0(df_criteria_suit[1, 4], " suboptimal")))
    fpm_plot_title <-
      "Biophysical Aptitude membership"
    
    plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
    print(plot_fpm)
     

```
</div>


```{r i2_rulebases_ba_export01, echo=FALSE, results='asis', eval=ba_crit}

cat("## Export aptitude results

")
```

<div class="fold o">
```{r i2_rulebases_ba_export02, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, warning=FALSE, eval=ba_crit}

vect_apt <- vect(df_irm_i2, geom = c("x", "y"), crs = wkt_lam)
output_vect(vect_apt, paste0("apt_", params$INN2))

``` 
</div>

```{r i2_rulebases_sef01, echo=FALSE, results='asis', eval=sef_crit}

cat("## Socio-economic rule bases

")
```

```{r i2_rulebases_extension_access01, echo=FALSE, results='asis', eval=extaccess_crit}

cat("### Promotional Activities / Extension Access rule bases

This rule base combines two propositions:")
```

```{r i2_rulebases_extension_access02, echo=FALSE, results='asis', eval=extaccess_crit}

cat("

[1] '(1) se_5a is good' or '(1) se_5a is poor'
[1] '(2) se_5b is good' or '(2) se_5b is poor'

")
```


```{r i2_rulebases_extension_access03, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=extaccess_crit}

for (i in 1:(nrow(df_criteria_se4a))) {
  print(paste0(
    df_criteria_se4a[i, 3],
    " (",
    df_criteria_se4a[i, 4],
    "): Weight = ",
    as.character(df_criteria_se4a[i, 5])
  ))
}

``` 

```{r i2_rulebases_extension_access04, echo=FALSE, results='asis', eval=extaccess_crit}

cat("This rule base has four possible rules and three possible outcomes: good, moderate and poor access:

Rule 1: If se_5a is good and se_5b is good then se_4a is good
Rule 2: If se_5a is poor and se_5b is good then se_4a is poor, moderate or good
Rule 3: If se_5a is good and se_5b is poor then se_4a is poor, moderate or good
Rule 4: If se_5a is poor and se_5b is poor then se_4a is poor

Using the weights assigned by AHP the outcomes are the following:")
```

```{r i2_rulebases_extension_access05, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=extaccess_crit}

df_criteria_se5a <-
  subset(df_priorities, grepl("^se_5a", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse5a <- nrow(df_criteria_se5a)

df_criteria_se5b <-
  subset(df_priorities, grepl("^se_5b", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse5b <- nrow(df_criteria_se5b)


#Rule 2: If kebele ext access is good and woreda ext access is poor
rule2 <-   df_criteria_se5a$weight[1] - df_criteria_se5b$weight[1]

#Rule 3: If kebele ext access is poor and woreda ext access is good
rule3 <-   -df_criteria_se5a$weight[1] + df_criteria_se5b$weight[1]


rm(df_conc) # remove previous instances of df_conc

#Rule 1: then ext access is always good
ext_conclusion1 = "good"
cat(paste("rule 1 = ", ext_conclusion1))
cat("\n")
# create table of conclusions
df_conc <- tibble(se_4a = ext_conclusion1)

#Rule 2: then ext access is poor, moderate or good
if (rule2 >= 0.33)  {
  ext_conclusion2 = "good"
}     else if (rule2 > -0.33) {
  ext_conclusion2 = "moderate"
} else {
  ext_conclusion2 = "poor"
}
cat(paste("rule 2 = ", ext_conclusion2))
cat("\n")
df_conc <- add_row(df_conc, se_4a = ext_conclusion2)

#Rule 3: then ext access is poor, moderate or good
if (rule3 >= 0.33)  {
  ext_conclusion3 = "good"
}     else if (rule3 > -0.33) {
  ext_conclusion3 = "moderate"
} else {
  ext_conclusion3 = "poor"
}
cat(paste("rule 3 = ", ext_conclusion3))
cat("\n")
df_conc <- add_row(df_conc, se_4a = ext_conclusion3)

#Rule 8: then ext access is always poor
ext_conclusion4 = "poor"
cat(paste("rule 4 = ", ext_conclusion4))
df_conc <- add_row(df_conc, se_4a = ext_conclusion4)

```

```{r i2_rulebases_extension_access06, echo=FALSE, results='asis', eval=extaccess_crit}

cat("This gives the rule base:")

```

<div class="fold o"> 
```{r i2_rulebases_extension_access07, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=extaccess_crit}

df_criteria_se3a_4a <-
  subset(df_priorities, grepl("^se_4a", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse3a_4a <- nrow(df_criteria_se3a_4a)

# df_criteria_se2b includes all of the ext access criteria
# for each criterion we know that the new proposition is the same as the conclusion from the previous rule base

assign(paste0("rbs_", df_criteria_se3a_4a[1, 3], "_list"), c()) # initialise the rule base list
assign(paste0("fp_", df_criteria_se3a_4a[1, 3], "_list"), c()) # initialise the fuzzy partition list
rm(df_prop) # remove previous instances of df_prop

rm(prop)
rm(conc)
for (i in 1:(nrow(df_criteria_se4a))) {
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_se4a[i, 3]), "_o")
  
  # for those criteria with three conclusion values
  # get  the 3 conclusion levels and get the unique values
  prop_levels <-
    c(as.character(df_criteria_se4a[i, 19]),
      as.character(df_criteria_se4a[i, 20]))  %>% unique()
  
  
  
  # set the proposition values
  if (!exists("df_prop")) {
    df_prop <- tibble(!!Prop_name := c(prop_levels))
  } else {
    #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
    df_prop <-
      bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
  }
  
  # get a list of the previous rule bases
  assign(paste0("rbs_", df_criteria_se3a_4a[1, 3], "_list"),
         append(get(
           paste0("rbs_", df_criteria_se3a_4a[1, 3], "_list")
         ), paste0("rb_", df_criteria_se4a[i, 3])))
  
  # get a list of the fuzzy partitions
  assign(paste0("fp_", df_criteria_se3a_4a[1, 3], "_list"),
         append(
           get(paste0("fp_", df_criteria_se3a_4a[1, 3], "_list")),
           paste0(df_criteria_se4a[i, 3], " = fp_", df_criteria_se4a[i, 3])
         ))
}

# new proposition object is made here
prop <- new("Proposition", table = df_prop %>% cross_df)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here

conc <- new("Conclusion", table = df_conc)

# create a rule base
assign(paste0("rb_", df_criteria_se3a_4a[1, 3]), RuleBase(prop, conc)) %>% print()


# add to the list of previous rule bases

assign(paste0("rbs_", df_criteria_se3a_4a[1, 3], "_list"),
       append(get(
         paste0("rbs_", df_criteria_se3a_4a[1, 3], "_list")
       ), paste0("rb_", df_criteria_se3a_4a[1, 3])))

# create the rule base stack from the list

x <-
  paste("stack(", gsub(",$", "", paste0(
    get(paste0("rbs_", df_criteria_se3a_4a[1, 3], "_list")), sep = ",", collapse = ""
  )), ")")

rbs_tmp <-
  assign(paste0("rbs_", df_criteria_se3a_4a[1, 3]), eval(parse(text = x)))

# evaluate the rule base stack

w <-
  paste("predict(",
        "rbs_tmp, newdata = df_irm_i2,",
        gsub(",$", "", paste0(
          get(paste0("fp_", df_criteria_se3a_4a[1, 3], "_list")), sep = ",", collapse = ""
        )),
        ")")

assign(paste0("fpm_", df_criteria_se3a_4a[1, 3]), eval(parse(text = w)))




g_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se3a_4a[1, 3]))$good)
df_irm_i2 <-
  mutate(df_irm_i2,!!as.character(paste0(df_criteria_se3a_4a[1, 3], "_g")) := g_col, .keep = c("all"))

if (ext_conclusion2 == "moderate" |
    ext_conclusion3 == "moderate") {
  m_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se3a_4a[1, 3]))$moderate)
  df_irm_i2 <-
    mutate(df_irm_i2,!!as.character(paste0(df_criteria_se3a_4a[1, 3], "_m")) := m_col, .keep = c("all"))
  
  ext_rb <- "gmp"
} else
  ext_rb <- "gp"

p_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se3a_4a[1, 3]))$poor)
df_irm_i2 <-
  mutate(df_irm_i2,!!as.character(paste0(df_criteria_se3a_4a[1, 3], "_p")) := p_col, .keep = c("all"))


if (ext_rb == "gmp") {
  n = 3
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se3a_4a[1, 3], "_g")),
      as.character(paste0(df_criteria_se3a_4a[1, 3], "_m")),
      as.character(paste0(df_criteria_se3a_4a[1, 3], "_p")),
      "x" ,
      "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se3a_4a[1, 4], " good")),
      as.character(paste0(df_criteria_se3a_4a[1, 4], " moderate")),
      as.character(paste0(df_criteria_se3a_4a[1, 4], " poor")))
} else {
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se3a_4a[1, 3], "_g")),  as.character(paste0(df_criteria_se3a_4a[1, 3], "_p")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se3a_4a[1, 4], " good")),  as.character(paste0(df_criteria_se3a_4a[1, 4], " poor")))
  
}
fpm_plot_title <-
  "Extension\nAccess\noptimality\nmembership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
print(plot_fpm)

``` 
</div>

```{r i2_rulebases_labour_access01, echo=FALSE, results='asis', eval=lab_crit}

cat("### Labour Availability rule bases

This rule base combines two propositions:")

```

```{r i2_rulebases_labour_access02, echo=FALSE, results='asis', eval=lab_crit}

cat("[1] '(1) se_5c is good' or '(1) se_5c is poor'
[1] '(2) se_5d is good ' or '(2) se_5d is poor)' ")

```

```{r i2_rulebases_labour_access03, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=lab_crit}

for (i in 1:(nrow(df_criteria_se4b))) {
  print(paste0(
    df_criteria_se4b[i, 3],
    " (",
    df_criteria_se4b[i, 4],
    "): Weight = ",
    as.character(df_criteria_se4b[i, 5])
  ))
}

``` 

```{r i2_rulebases_labour_access04, echo=FALSE, results='asis', eval=lab_crit}

cat("This rule base has four possible rules and three possible outcomes: good, moderate and poor access:

Rule 1: If se_5c is poor and se_5d is poor then se_4b is poor
Rule 2: If se_5c is poor and se_5d is good then se_4b is poor, moderate or good
Rule 3: If se_5c is good and se_5d is poor then se_4b is poor, moderate or good
Rule 4: If se_5c is good and se_5d is good then se_4b is good

Using the weights assigned by AHP the outcomes are the following:")

```

```{r i2_rulebases_labour_access05, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=lab_crit}

df_criteria_se5c <-
  subset(df_priorities, grepl("^se_5c", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse5c <- nrow(df_criteria_se5c)

df_criteria_se5d <-
  subset(df_priorities, grepl("^se_5d", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse5d <- nrow(df_criteria_se5d)


#Rule 2: If kebele pop dens is good and kebele hh size is poor
rule2 <-   df_criteria_se5c$weight[1] - df_criteria_se5d$weight[1]

#Rule 3: If kebele pop dens is poor and kebele hh size is good
rule3 <-   -df_criteria_se5c$weight[1] + df_criteria_se5d$weight[1]


rm(df_conc) # remove previous instances of df_conc

#Rule 1: then lab access is always good
lab_conclusion1 = "poor"
cat(paste("rule 1 = ", lab_conclusion1))
cat("\n")
# create table of conclusions
df_conc <- tibble(se_4b = lab_conclusion1)

#Rule 2: then lab access is poor, moderate or good
if (rule2 >= 0.33)  {
  lab_conclusion2 = "good"
}     else if (rule2 > -0.33) {
  lab_conclusion2 = "moderate"
} else {
  lab_conclusion2 = "poor"
}
cat(paste("rule 2 = ", lab_conclusion2))
cat("\n")
df_conc <- add_row(df_conc, se_4b = lab_conclusion2)

#Rule 3: then lab access is poor, moderate or good
if (rule3 >= 0.33)  {
  lab_conclusion3 = "good"
}     else if (rule3 > -0.33) {
  lab_conclusion3 = "moderate"
} else {
  lab_conclusion3 = "poor"
}
cat(paste("rule 3 = ", lab_conclusion3))
cat("\n")
df_conc <- add_row(df_conc, se_4b = lab_conclusion3)

#Rule 8: then lab access is always poor
lab_conclusion4 = "good"
cat(paste("rule 4 = ", lab_conclusion4))
df_conc <- add_row(df_conc, se_4b = lab_conclusion4)

```

```{r i2_rulebases_labour_access06, echo=FALSE, results='asis', eval=lab_crit}

cat("This gives the rule base:")

```

<div class="fold o"> 
```{r i2_rulebases_labour_access07, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=lab_crit}

df_criteria_se3a_4b <-
  subset(df_priorities, grepl("^se_4b", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse3a_4b <- nrow(df_criteria_se3a_4b)

# df_criteria_se2b includes all of the lab access criteria
# for each criterion we know that the new proposition is the same as the conclusion from the previous rule base

assign(paste0("rbs_", df_criteria_se3a_4b[1, 3], "_list"), c()) # initialise the rule base list
assign(paste0("fp_", df_criteria_se3a_4b[1, 3], "_list"), c()) # initialise the fuzzy partition list
rm(df_prop) # remove previous instances of df_prop

rm(prop)
rm(conc)
for (i in 1:(nrow(df_criteria_se4b))) {
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_se4b[i, 3]), "_o")
  
  # for those criteria with three conclusion values
  # get  the 3 conclusion levels and get the unique values
  prop_levels <-
    c(as.character(df_criteria_se4b[i, 19]),
      as.character(df_criteria_se4b[i, 20]))  %>% unique()
  
  
  
  # set the proposition values
  if (!exists("df_prop")) {
    df_prop <- tibble(!!Prop_name := c(prop_levels))
  } else {
    #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
    df_prop <-
      bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
  }
  
  # get a list of the previous rule bases
  assign(paste0("rbs_", df_criteria_se3a_4b[1, 3], "_list"),
         append(get(
           paste0("rbs_", df_criteria_se3a_4b[1, 3], "_list")
         ), paste0("rb_", df_criteria_se4b[i, 3])))
  
  # get a list of the fuzzy partitions
  assign(paste0("fp_", df_criteria_se3a_4b[1, 3], "_list"),
         append(
           get(paste0("fp_", df_criteria_se3a_4b[1, 3], "_list")),
           paste0(df_criteria_se4b[i, 3], " = fp_", df_criteria_se4b[i, 3])
         ))
}

# new proposition object is made here
prop <- new("Proposition", table = df_prop %>% cross_df)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here

conc <- new("Conclusion", table = df_conc)

# create a rule base
assign(paste0("rb_", df_criteria_se3a_4b[1, 3]), RuleBase(prop, conc)) %>% print()


# add to the list of previous rule bases

assign(paste0("rbs_", df_criteria_se3a_4b[1, 3], "_list"),
       append(get(
         paste0("rbs_", df_criteria_se3a_4b[1, 3], "_list")
       ), paste0("rb_", df_criteria_se3a_4b[1, 3])))

# create the rule base stack from the list

x <-
  paste("stack(", gsub(",$", "", paste0(
    get(paste0("rbs_", df_criteria_se3a_4b[1, 3], "_list")), sep = ",", collapse = ""
  )), ")")

rbs_tmp <-
  assign(paste0("rbs_", df_criteria_se3a_4b[1, 3]), eval(parse(text = x)))

# evaluate the rule base stack

w <-
  paste("predict(",
        "rbs_tmp, newdata = df_irm_i2,",
        gsub(",$", "", paste0(
          get(paste0("fp_", df_criteria_se3a_4b[1, 3], "_list")), sep = ",", collapse = ""
        )),
        ")")

assign(paste0("fpm_", df_criteria_se3a_4b[1, 3]), eval(parse(text = w)))




g_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se3a_4b[1, 3]))$good)
df_irm_i2 <-
  mutate(df_irm_i2,!!as.character(paste0(df_criteria_se3a_4b[1, 3], "_g")) := g_col, .keep = c("all"))

if (lab_conclusion2 == "moderate" |
    lab_conclusion3 == "moderate") {
  m_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se3a_4b[1, 3]))$moderate)
  df_irm_i2 <-
    mutate(df_irm_i2,!!as.character(paste0(df_criteria_se3a_4b[1, 3], "_m")) := m_col, .keep = c("all"))
  
  lab_rb <- "gmp"
} else
  lab_rb <- "gp"

p_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se3a_4b[1, 3]))$poor)
df_irm_i2 <-
  mutate(df_irm_i2,!!as.character(paste0(df_criteria_se3a_4b[1, 3], "_p")) := p_col, .keep = c("all"))


if (lab_rb == "gmp") {
  n = 3
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se3a_4b[1, 3], "_g")),
      as.character(paste0(df_criteria_se3a_4b[1, 3], "_m")),
      as.character(paste0(df_criteria_se3a_4b[1, 3], "_p")),
      "x" ,
      "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se3a_4b[1, 4], " good")),
      as.character(paste0(df_criteria_se3a_4b[1, 4], " moderate")),
      as.character(paste0(df_criteria_se3a_4b[1, 4], " poor")))
} else {
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se3a_4b[1, 3], "_g")),  as.character(paste0(df_criteria_se3a_4b[1, 3], "_p")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se3a_4b[1, 4], " good")),  as.character(paste0(df_criteria_se3a_4b[1, 4], " poor")))
  
}
fpm_plot_title <-
  "Labour\nAvailability\noptimality\nmembership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
print(plot_fpm)


``` 
</div>

```{r i2_rulebases_fp_access01, echo=FALSE, results='asis', eval=fp_crit}

cat("### Fertiliser and Pesticide Access rule bases

This rule base combines two propositions:")

```

```{r i2_rulebases_fp_access02, echo=FALSE, results='asis', eval=fp_crit}

cat("[1] '(1) se_5e is good' or '(1) se_5e is poor'
[1] '(2) se_5f is good ' or '(2) se_5f is poor)' ")

```

```{r i2_rulebases_fp_access03, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=fp_crit}

for (i in 1:(nrow(df_criteria_se4c))) {
  print(paste0(
    df_criteria_se4c[i, 3],
    " (",
    df_criteria_se4c[i, 4],
    "): Weight = ",
    as.character(df_criteria_se4c[i, 5])
  ))
}

``` 

```{r i2_rulebases_fp_access04, echo=FALSE, results='asis', eval=fp_crit}

cat("This rule base has four possible rules and three possible outcomes: good, moderate and poor access:

Rule 1: If se_5e is poor and se_5f is poor then se_4c is poor
Rule 2: If se_5e is poor and se_5f is good then se_4c is poor, moderate or good
Rule 3: If se_5e is good and se_5f is poor then se_4c is poor, moderate or good
Rule 4: If se_5e is good and se_5f is good then se_4c is good

Using the weights assigned by AHP the outcomes are the following:")

```

```{r i2_rulebases_fp_access05, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=fp_crit}


df_criteria_se5e <-
  subset(df_priorities, grepl("^se_5e", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse5e <- nrow(df_criteria_se5e)

df_criteria_se5f <-
  subset(df_priorities, grepl("^se_5f", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse5f <- nrow(df_criteria_se5f)


#Rule 2: If  F/P Access at Local Farmer Group is good and F/P Access at woreda is poor
rule2 <-   df_criteria_se5e$weight[1] - df_criteria_se5f$weight[1]

#Rule 3: If F/P Access at Local Farmer Group is poor and F/P Access at woreda is good
rule3 <-   -df_criteria_se5e$weight[1] + df_criteria_se5f$weight[1]


rm(df_conc) # remove previous instances of df_conc

#Rule 1: then fp access is always good
fp_conclusion1 = "good"
cat(paste("rule 1 = ", fp_conclusion1))
cat("\n")
# create table of conclusions
df_conc <- tibble(se_4c = fp_conclusion1)

#Rule 2: then fp access is poor, moderate or good
if (rule2 >= 0.33)  {
  fp_conclusion2 = "good"
}     else if (rule2 > -0.33) {
  fp_conclusion2 = "moderate"
} else {
  fp_conclusion2 = "poor"
}
cat(paste("rule 2 = ", fp_conclusion2))
cat("\n")
df_conc <- add_row(df_conc, se_4c = fp_conclusion2)

#Rule 3: then fp access is poor, moderate or good
if (rule3 >= 0.33)  {
  fp_conclusion3 = "good"
}     else if (rule3 > -0.33) {
  fp_conclusion3 = "moderate"
} else {
  fp_conclusion3 = "poor"
}
cat(paste("rule 3 = ", fp_conclusion3))
cat("\n")
df_conc <- add_row(df_conc, se_4c = fp_conclusion3)

#Rule 8: then fp access is always poor
fp_conclusion4 = "poor"
cat(paste("rule 4 = ", fp_conclusion4))
df_conc <- add_row(df_conc, se_4c = fp_conclusion4)
  
```

```{r i2_rulebases_fp_access06, echo=FALSE, results='asis', eval=fp_crit}

cat("This gives the rule base:")

```

<div class="fold o"> 
```{r i2_rulebases_fp_access07, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=fp_crit}

if (fp_crit == 1) {
  df_criteria_se3b_4c <-
    subset(df_priorities, grepl("^se_4c", df_priorities$rulebase_number)) # use regular expressions to find criteria
  n_cse3b_4c <- nrow(df_criteria_se3b_4c)
  
  # df_criteria_se2b includes all of the fp access criteria
  # for each criterion we know that the new proposition is the same as the conclusion from the previous rule base
  
  assign(paste0("rbs_", df_criteria_se3b_4c[1, 3], "_list"), c()) # initialise the rule base list
  assign(paste0("fp_", df_criteria_se3b_4c[1, 3], "_list"), c()) # initialise the fuzzy partition list
  rm(df_prop) # remove previous instances of df_prop
  
  rm(prop)
  rm(conc)
  for (i in 1:(nrow(df_criteria_se4c))) {
    # set the proposition name
    Prop_name <-
      paste0(as.character(df_criteria_se4c[i, 3]), "_o")
    
    # for those criteria with three conclusion values
    # get  the 3 conclusion levels and get the unique values
    prop_levels <-
      c(as.character(df_criteria_se4c[i, 19]),
        as.character(df_criteria_se4c[i, 20]))  %>% unique()
    
    
    
    # set the proposition values
    if (!exists("df_prop")) {
      df_prop <- tibble(!!Prop_name := c(prop_levels))
    } else {
      #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
      df_prop <-
        bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
    }
    
    # get a list of the previous rule bases
    assign(paste0("rbs_", df_criteria_se3b_4c[1, 3], "_list"),
           append(get(
             paste0("rbs_", df_criteria_se3b_4c[1, 3], "_list")
           ), paste0("rb_", df_criteria_se4c[i, 3])))
    
    # get a list of the fuzzy partitions
    assign(paste0("fp_", df_criteria_se3b_4c[1, 3], "_list"),
           append(
             get(paste0("fp_", df_criteria_se3b_4c[1, 3], "_list")),
             paste0(df_criteria_se4c[i, 3], " = fp_", df_criteria_se4c[i, 3])
           ))
  }
  
  # new proposition object is made here
  prop <- new("Proposition", table = df_prop %>% cross_df)
  tbl_prop_cross <- prop@table
  n_prop <- ncol(tbl_prop_cross)
  
  
  # new conclusion object is made here
  
  conc <- new("Conclusion", table = df_conc)
  
  # create a rule base
  assign(paste0("rb_", df_criteria_se3b_4c[1, 3]), RuleBase(prop, conc)) %>% print()
  
  
  # add to the list of previous rule bases
  
  assign(paste0("rbs_", df_criteria_se3b_4c[1, 3], "_list"),
         append(get(
           paste0("rbs_", df_criteria_se3b_4c[1, 3], "_list")
         ), paste0("rb_", df_criteria_se3b_4c[1, 3])))
  
  # create the rule base stack from the list
  
  x <-
    paste("stack(", gsub(",$", "", paste0(
      get(paste0("rbs_", df_criteria_se3b_4c[1, 3], "_list")), sep = ",", collapse = ""
    )), ")")
  
  rbs_tmp <-
    assign(paste0("rbs_", df_criteria_se3b_4c[1, 3]), eval(parse(text = x)))
  
  # evaluate the rule base stack
  
  w <-
    paste("predict(",
          "rbs_tmp, newdata = df_irm_i2,",
          gsub(",$", "", paste0(
            get(paste0("fp_", df_criteria_se3b_4c[1, 3], "_list")), sep = ",", collapse = ""
          )),
          ")")
  
  assign(paste0("fpm_", df_criteria_se3b_4c[1, 3]), eval(parse(text = w)))
  
  
  
  
  g_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se3b_4c[1, 3]))$good)
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_se3b_4c[1, 3], "_g")) := g_col, .keep = c("all"))
  
  if (fp_conclusion2 == "moderate" |
      fp_conclusion3 == "moderate") {
    m_col <- getMembership(get(paste0("fpm_",
                                      df_criteria_se3b_4c[1, 3]))$moderate)
    df_irm_i2 <-
      mutate(df_irm_i2, !!as.character(paste0(df_criteria_se3b_4c[1, 3], "_m")) := m_col, .keep = c("all"))
    
    fp_rb <- "gmp"
  } else
    fp_rb <- "gp"
  
  p_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se3b_4c[1, 3]))$poor)
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_se3b_4c[1, 3], "_p")) := p_col, .keep = c("all"))
  
  
  if (fp_rb == "gmp") {
    n = 3
    fpm_conc_var <-
      c(as.character(paste0(df_criteria_se3b_4c[1, 3], "_g")),
        as.character(paste0(df_criteria_se3b_4c[1, 3], "_m")),
        as.character(paste0(df_criteria_se3b_4c[1, 3], "_p")),
        "x" ,
        "y")
    fpm_conc_name <-
      c(as.character(paste0(df_criteria_se3b_4c[1, 4], " good")),
        as.character(paste0(df_criteria_se3b_4c[1, 4], " moderate")),
        as.character(paste0(df_criteria_se3b_4c[1, 4], " poor")))
  } else {
    n = 2
    fpm_conc_var <-
      c(as.character(paste0(df_criteria_se3b_4c[1, 3], "_g")),  as.character(paste0(df_criteria_se3b_4c[1, 3], "_p")), "x" , "y")
    fpm_conc_name <-
      c(as.character(paste0(df_criteria_se3b_4c[1, 4], " good")),  as.character(paste0(df_criteria_se3b_4c[1, 4], " poor")))
    
  }
  fpm_plot_title <-
    "Fertiliser\n& Pesticide\nAccess\noptimality\nmembership"
  
  plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
  print(plot_fpm)
  
}

``` 
</div>

```{r i2_rulebases_farm_inputs01, echo=FALSE, results='asis', eval=inpaccess_crit}

cat("### Access to Farm Inputs rule bases

The inputs access rule base (se_3b) combines propositions for access to fertilisers and pesticides (rule base se_4c), access to seeds (rule base se_4d) and access to land (rule base se_4e).

Rule base se_3b has the following propositions:")

```

```{r i2_rulebases_farm_inputs02 , cache = TRUE, cache.whatever=params$Agg, results='asis', eval=inpaccess_crit}

fp_conc_list <- c(fp_conclusion1, fp_conclusion2, fp_conclusion3, fp_conclusion4)

cat(paste("(1) se_4c is", unique(fp_conc_list)))

``` 

```{r i2_rulebases_farm_inputs03, echo=FALSE, results='asis', eval=inpaccess_crit}

cat("[1] '(2) se_4d is good'  '(2) se_4d is poor'
[1] '(3) se_4e is good'  '(3) se_4e is poor'")

```


```{r i2_rulebases_farm_inputs04, cache = TRUE, cache.whatever=params$Agg, results='asis', eval=inpaccess_crit}

df_criteria_se3b <-
  subset(df_priorities, grepl("^se_3b", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cse3b <- nrow(df_criteria_se3b)
print(paste(n_cse3b, "Inputs Access criteria: "))

for (i in 1:(nrow(df_criteria_se3b))) {
  print(paste0(
    df_criteria_se3b[i, 3],
    " (",
    df_criteria_se3b[i, 4],
    "): Weight = ",
    as.character(df_criteria_se3b[i, 5])
  ))
}

``` 

```{r i2_rulebases_farm_inputs05, echo=FALSE, results='asis', eval=inpaccess_crit}

cat("This rule base has twelve possible rules and three possible outcomes: good, moderate and poor access:

Rule 1: If se_4c is good and se_4d is good and se_4e is good then se3b is good
Rule 2: If se_4c is moderate and se_4d is good and se_4e is good then se3b is moderate or good
Rule 3: If se_4c is poor and se_4d is good and se_4e is good then se3b is poor, moderate or good
Rule 4: If se_4c is good and se_4d is poor and se_4e is good then se3b is poor, moderate or good
Rule 5: If se_4c is moderate and se_4d is poor and se_4e is good then se3b is poor, moderate or good
Rule 6: If se_4c is poor and se_4d is poor and se_4e is good then se3b is poor, moderate or good
Rule 7: If se_4c is good and se_4d is good and se_4e is poor then se3b is poor, moderate or good
Rule 8: If se_4c is moderate and se_4d is good and se_4e is poor then se3b is poor, moderate or good
Rule 9: If se_4c is poor and se_4d is good and se_4e is poor then se3b is poor, moderate or good
Rule 10: If se_4c is good  and se_4d is poor and se_4e is poor then se3b is poor, moderate or good
Rule 11: If se_4c is moderate and se_4d is poor and se_4e is poor then se3b is poor or moderate
Rule 12: If se_4c is poor and se_4d is poor and se_4e is poor then se3b is poor


Using the propositions and weights assigned by AHP the outcomes are the following:")

```

```{r i2_rulebases_farm_inputs06, cache = TRUE, cache.whatever=params$Agg, results='asis', eval=inpaccess_crit}

df_criteria_se4c <-
  subset(df_priorities, grepl("^se_4c", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse4c <- nrow(df_criteria_se4c)

df_criteria_se4d <-
  subset(df_priorities, grepl("^se_4d", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse4d <- nrow(df_criteria_se4d)

df_criteria_se4e <-
  subset(df_priorities, grepl("^se_4e", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse4e <- nrow(df_criteria_se4e)


#Rule 2: If f/p access is moderate and seed access is good and land access is good
rule2 <-
  df_criteria_se4d$weight[1] + df_criteria_se4e$weight[1]

#Rule 3: If f/p access is poor and seed access is good and land access is good
rule3 <-
  -df_criteria_se4c$weight[1] + df_criteria_se4d$weight[1] + df_criteria_se4e$weight[1]

#Rule 4: If f/p access is good and seed access is poor and land access is good
rule4  <-
  df_criteria_se4c$weight[1] - df_criteria_se4d$weight[1] + df_criteria_se4e$weight[1]

#Rule 5: If f/p access is moderate and seed access is poor and land access is good
rule5  <-
  -df_criteria_se4d$weight[1] + df_criteria_se4e$weight[1]

#Rule 6: If f/p access is poor and seed access is poor and land access is good
rule6  <-
  -df_criteria_se4c$weight[1] - df_criteria_se4d$weight[1] + df_criteria_se4e$weight[1]

#Rule 7: If f/p access is good and seed access is good and land access is poor
rule7  <-
  df_criteria_se4c$weight[1] + df_criteria_se4d$weight[1] - df_criteria_se4e$weight[1]

#Rule 8: If f/p access is moderate and seed access is good and land access is poor
rule8  <-
  df_criteria_se4d$weight[1] - df_criteria_se4e$weight[1]

#Rule 9: If f/p access is poor and seed access is good and land access is poor
rule9  <-
  -df_criteria_se4c$weight[1] + df_criteria_se4d$weight[1] - df_criteria_se4e$weight[1]

#Rule 10: If f/p access is good and seed access is poor and land access is poor
rule10  <-
  df_criteria_se4c$weight[1] - df_criteria_se4d$weight[1] - df_criteria_se4e$weight[1]

#Rule 11: If f/p access is moderate and seed access is poor and land access is poor
rule11  <-
  -df_criteria_se4d$weight[1] - df_criteria_se4e$weight[1]


rm(df_conc) # remove previous instances of df_conc
rm(df_prop) # remove previous instances of df_prop

inp_conclusion1 = "good" # always poor
cat(paste("rule 1 = ", inp_conclusion1))
cat("\n")

# create table of conclusions
df_prop <-
  tibble(se_4c = "good",
         se_4d_o = "good",
         se_4e_o = "good")
df_conc <- tibble(se_3b = inp_conclusion1)


#Rule 2: then farm inputs access is poor, moderate or good
if (fp_rb == "gmp") {
  # rule 2 only activated when f/p is moderate
  
  if (rule2 >= 0.33)  {
    inp_conclusion2 = "good"
  }     else if (rule2 > -0.33) {
    inp_conclusion2 = "moderate"
  } else {
    inp_conclusion2 = "poor"
  }
  cat(paste("rule 2 = ", inp_conclusion2))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_3b = inp_conclusion2)
  df_prop <-
    add_row(df_prop,
            se_4c = "moderate",
            se_4d_o = "good",
            se_4e_o = "good")
} else
  cat(paste("No rule 2"))
cat("\n")

#Rule 3: then farm inputs access is poor, moderate or good

if (rule3 >= 0.33)  {
  inp_conclusion3 = "good"
}     else if (rule3 > -0.33) {
  inp_conclusion3 = "moderate"
} else {
  inp_conclusion3 = "poor"
}

cat(paste("rule 3 = ", inp_conclusion3))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_3b = inp_conclusion3)
df_prop <-
  add_row(df_prop,
          se_4c = "poor",
          se_4d_o = "good",
          se_4e_o = "good")

#Rule 4: then farm inputs access is poor, moderate or good

if (rule4 >= 0.33)  {
  inp_conclusion4 = "good"
}     else if (rule4 > -0.33) {
  inp_conclusion4 = "moderate"
} else {
  inp_conclusion4 = "poor"
}

cat(paste("rule 4 = ", inp_conclusion4))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_3b = inp_conclusion4)
df_prop <-
  add_row(df_prop,
          se_4c = "good",
          se_4d_o = "poor",
          se_4e_o = "good")



#Rule 5: then farm inputs access is poor, moderate or good

if (fp_rb == "gmp") {
  # rule 5 only activated when f/p is moderate
  if (rule5 >= 0.33)  {
    inp_conclusion5 = "good"
  }     else if (rule5 > -0.33) {
    inp_conclusion5 = "moderate"
  } else {
    inp_conclusion5 = "poor"
  }
  cat(paste("rule 5 = ", inp_conclusion5))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_3b = inp_conclusion5)
  df_prop <-
    add_row(df_prop,
            se_4c = "moderate",
            se_4d_o = "poor",
            se_4e_o = "good")
  
} else
  cat(paste("No rule 5"))
cat("\n")


#Rule 6: then farm inputs access is poor, moderate or good
if (rule6 >= 0.33)  {
  inp_conclusion6 = "good"
}     else if (rule6 > -0.33) {
  inp_conclusion6 = "moderate"
} else {
  inp_conclusion6 = "poor"
}
cat(paste("rule 6 = ", inp_conclusion6))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_3b = inp_conclusion6)
df_prop <-
  add_row(df_prop,
          se_4c = "poor",
          se_4d_o = "poor",
          se_4e_o = "good")

#Rule 7: then farm inputs access is poor, moderate or good
if (rule7 >= 0.33)  {
  inp_conclusion7 = "good"
}     else if (rule7 > -0.33) {
  inp_conclusion7 = "moderate"
} else {
  inp_conclusion7 = "poor"
}
cat(paste("rule 7 = ", inp_conclusion7))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_3b = inp_conclusion7)
df_prop <-
  add_row(df_prop,
          se_4c = "good",
          se_4d_o = "good",
          se_4e_o = "poor")

#Rule 8: then farm inputs access is poor, moderate or good
if (fp_rb == "gmp") {
  # rule 8 only activated when f/p is moderate
  if (rule8 >= 0.33)  {
    inp_conclusion8 = "good"
  }     else if (rule8 > -0.33) {
    inp_conclusion8 = "moderate"
  } else {
    inp_conclusion8 = "poor"
  }
  cat(paste("rule 8 = ", inp_conclusion8))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_3b = inp_conclusion8)
  df_prop <-
    add_row(df_prop,
            se_4c = "moderate",
            se_4d_o = "good",
            se_4e_o = "poor")
} else
  cat(paste("No rule 8"))
cat("\n")

#Rule 9: then farm inputs access is poor, moderate or good

if (rule9 >= 0.33)  {
  inp_conclusion9 = "good"
}     else if (rule9 > -0.33) {
  inp_conclusion9 = "moderate"
} else {
  inp_conclusion9 = "poor"
}

cat(paste("rule 9 = ", inp_conclusion9))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_3b = inp_conclusion9)
df_prop <- add_row(df_prop,
                 se_4c = "poor",
                 se_4d_o = "good",
                 se_4e_o = "poor")


#Rule 10: then farm inputs access is poor, moderate or good

if (rule10 >= 0.33)  {
  inp_conclusion10 = "good"
}     else if (rule10 > -0.33) {
  inp_conclusion10 = "moderate"
} else {
  inp_conclusion10 = "poor"
}

cat(paste("rule 10 = ", inp_conclusion10))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_3b = inp_conclusion10)
df_prop <- add_row(df_prop,
                 se_4c = "good",
                 se_4d_o = "poor",
                 se_4e_o = "poor")


#Rule 11: then farm inputs access is poor, moderate or good
if (fp_rb == "gmp") {
  # rule 10 only activated when f/p is moderate
  
  if (rule11 >= 0.33)  {
    inp_conclusion11 = "good"
  }     else if (rule11 > -0.33) {
    inp_conclusion11 = "moderate"
  } else {
    inp_conclusion11 = "poor"
  }
  cat(paste("rule 11 = ", inp_conclusion11))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_3b = inp_conclusion11)
  df_prop <- add_row(df_prop,
                   se_4c = "moderate",
                   se_4d_o = "poor",
                   se_4e_o = "poor")
} else
  cat(paste("No rule 11"))
cat("\n")


inp_conclusion12 = "poor"
cat(paste("rule 12 = ", inp_conclusion12))
# add to table of conclusions
df_conc <- add_row(df_conc, se_3b = inp_conclusion12)
df_prop <- add_row(df_prop,
                 se_4c = "poor",
                 se_4d_o = "poor",
                 se_4e_o = "poor")


``` 

```{r i2_rulebases_farm_inputs07, echo=FALSE, results='asis', eval=inpaccess_crit}

cat("This gives the rule base:")

```

<div class="fold o"> 
```{r i2_rulebases_farm_inputs08, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=inpaccess_crit}

if (inpaccess_crit == 1) {
  
  # new proposition object is made here
  prop <- new("Proposition", table = df_prop)
  tbl_prop_cross <- prop@table
  n_prop <- ncol(tbl_prop_cross)
  
  
  # new conclusion object is made here
  
  conc <- new("Conclusion", table = df_conc)
  
  # create a rule base
  rb_se_3b <- RuleBase(prop, conc) %>% print()

  
# in this section there are normally three criteria - f/p, seeds and land

# seeds and land are based on one criterion only and each have data, a simple rb (se_4d & se4e) and a fp (se_4d & se4e)

# access to f/p is based on two criteria and has a rb (se_4c) and a rbs (se_4c) which includes the two constituent parts of f/p and their two rb (se_5e & se5f)
# there are four fp in total (se_5e, se_5f, se_4e and se4d)

# in total there will be a new rbs (se_3b) which will contain:
# rb_se_4d
# rb_se_4e
# rb_se_5e in rbs_se_4c_list
# rb_se_5f in rbs_se_4c_list
# rb_se_4c in rbs_se_4c_list

rbs_se_3b <-
  stack(
    rb_se_4d,
    rb_se_4e,
    rb_se_5e,
    rb_se_5f,
    rb_se_4c,
    rb_se_3b
  )


fpm_se_3b <-
  
  predict(
    rbs_se_3b,
    newdata = df_irm_i2,
    se_4d = fp_se_4d,
    se_4e = fp_se_4e,
    se_5e = fp_se_5e,
    se_5f = fp_se_5f
  )

 
  df_criteria_se2a_3b <-
    subset(df_priorities, grepl("^se_3b", df_priorities$rulebase_number)) # use regular expressions to find criteria
  n_cse2a_3b <- nrow(df_criteria_se2a_3b)
  
  g_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se2a_3b[1, 3]))$good)
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_se2a_3b[1, 3], "_g")) := g_col, .keep = c("all"))
  
   
  if (fp_rb == "gmp") {
      inp_rule_num <- 12
  if(inp_conclusion2 == "moderate" |
      inp_conclusion3 == "moderate" |
      inp_conclusion4 == "moderate" |
      inp_conclusion5 == "moderate" |
      inp_conclusion6 == "moderate" | 
      inp_conclusion7 == "moderate" |
      inp_conclusion8 == "moderate" |
      inp_conclusion9 == "moderate" | 
      inp_conclusion10 == "moderate" | 
      inp_conclusion11 == "moderate") {
    m_col <- getMembership(get(paste0("fpm_",
                                      df_criteria_se2a_3b[1, 3]))$moderate)
    df_irm_i2 <-
      mutate(df_irm_i2, !!as.character(paste0(df_criteria_se2a_3b[1, 3], "_m")) := m_col, .keep = c("all"))
    
    inp_rb <- "gmp"

  } else
    inp_rb <- "gp"
  } else { 
  inp_rule_num <- 8
    if( inp_conclusion3 == "moderate" |
      inp_conclusion4 == "moderate" |
      inp_conclusion6 == "moderate" | 
      inp_conclusion7 == "moderate" |
      inp_conclusion9 == "moderate" | 
      inp_conclusion10 == "moderate") {
    m_col <- getMembership(get(paste0("fpm_",
                                      df_criteria_se2a_3b[1, 3]))$moderate)
    df_irm_i2 <-
      mutate(df_irm_i2, !!as.character(paste0(df_criteria_se2a_3b[1, 3], "_m")) := m_col, .keep = c("all"))
    
    inp_rb <- "gmp"
    
  } else
    inp_rb <- "gp"    
 }   
    
    
  p_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se2a_3b[1, 3]))$poor)
  df_irm_i2 <-
    mutate(df_irm_i2, !!as.character(paste0(df_criteria_se2a_3b[1, 3], "_p")) := p_col, .keep = c("all"))
  
    
if  (inp_rb == "gmp" ){   
        n = 3
    fpm_conc_var <-
      c(as.character(paste0(df_criteria_se2a_3b[1, 3], "_g")), as.character(paste0(df_criteria_se2a_3b[1, 3], "_m")), as.character(paste0(df_criteria_se2a_3b[1, 3], "_p")),"x" , "y")
    fpm_conc_name <-
      c(as.character(paste0(df_criteria_se2a_3b[1, 4], " good")), as.character(paste0(df_criteria_se2a_3b[1, 4], " moderate")), as.character(paste0(df_criteria_se2a_3b[1, 4], " poor")))
} else {
  
        n = 2
    fpm_conc_var <-
      c(as.character(paste0(df_criteria_se2a_3b[1, 3], "_g")),  as.character(paste0(df_criteria_se2a_3b[1, 3], "_p")),"x" , "y")
    fpm_conc_name <-
      c(as.character(paste0(df_criteria_se2a_3b[1, 4], " good")),  as.character(paste0(df_criteria_se2a_3b[1, 4], " poor")))  
  
}
        fpm_plot_title <-
      "Farm Inputs\nAccess\noptimality\nmembership"
     
    plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
    print(plot_fpm)
     
  
  
}
``` 
</div>

```{r i2_rulebases_management01, echo=FALSE, results='asis', eval=management_crit}

cat("### Crop and Farm Management rule bases")

```


```{r i2_rulebases_management02, results='asis', warning=FALSE, eval=management_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria

df_criteria_se3a <-
  subset(df_priorities, grepl("^se_3a", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cse3a <- nrow(df_criteria_se3a)

# then determine and print the names of the rule bases in the Crop and Farm Management theme

cat(paste(n_cse3a, "Crop and Farm Management rule bases:"))
for (i in 1:n_cse3a) {
  cat(
    paste0(
      "\n",
      df_criteria_se3a[i, 3],
      " (",
      df_criteria_se3a[i, 4],
      "):\n Weight = ",
      as.character(df_criteria_se3a[i, 5]),
      "\n"
    )
  )
}

```


```{r i2_rulebases_management03, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=management_crit}


ext_conc_list <-
  c(ext_conclusion1,
    ext_conclusion2,
    ext_conclusion3,
    ext_conclusion4)

cat(paste("\n Extension access is", sort(unique(ext_conc_list))))

cat(paste("\n\nRule base 4b has the following conclusions:"))

lab_conc_list <-
  c(lab_conclusion1,
    lab_conclusion2,
    lab_conclusion3,
    lab_conclusion4)

cat(paste("\n Extension access is", sort(unique(lab_conc_list))))

``` 

```{r i2_rulebases_management04, echo=FALSE, results='asis', eval=management_crit}

cat("This rule base has nine possible rules and three possible outcomes: good, moderate and poor access:

Rule 1: If se_4a is good and se_4b is good then se3a is good
Rule 2: If se_4a is moderate and se_4b is good then se3a is moderate or good
Rule 3: If se_4a is poor and se_4b is good then se3a is poor, moderate or good
Rule 4: If se_4a is good and se_4b is moderate then se3a is poor, moderate or good
Rule 5: If se_4a is moderate and se_4b is moderate then se3a is poor, moderate or good
Rule 6: If se_4a is poor and se_4b is moderate then se3a is poor, moderate or good
Rule 7: If se_4a is good and se_4b is poor then se3a is poor, moderate or good
Rule 8: If se_4a is moderate and se_4b is poor then se3a is poor or moderate
Rule 9: If se_4a is poor and se_4b is poor then se3a is poor


Using the propositions and weights assigned by AHP the outcomes are the following:")

```


```{r i2_rulebases_management05, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=management_crit}


df_criteria_se4a <-
  subset(df_priorities, grepl("^se_4a", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse4a <- nrow(df_criteria_se4a)

df_criteria_se4b <-
  subset(df_priorities, grepl("^se_4b", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse4b <- nrow(df_criteria_se4b)




#Rule 2: If ext access is moderate and labour access is good
rule2 <-
  df_criteria_se4b$weight[1]

#Rule 3: If ext access is poor and labour access is good
rule3 <-
  -df_criteria_se4a$weight[1] + df_criteria_se4b$weight[1]

#Rule 4: If ext access is good and labour access is moderate
rule4  <-
  df_criteria_se4a$weight[1]

#Rule 6: If ext access is poor and labour access is moderate
rule6  <-
  -df_criteria_se4a$weight[1]

#Rule 7: If ext access is good and labour access is poor
rule7  <-
  df_criteria_se4a$weight[1] - df_criteria_se4b$weight[1]

#Rule 8: If ext access is moderate and labour access is poor
rule8  <-
  -df_criteria_se4b$weight[1]




rm(df_conc) # remove previous instances of df_conc
rm(df_prop) # remove previous instances of df_prop

#Rule 1: then management is good

mgt_conclusion1 = "good" # always good
cat(paste("rule 1 = ", mgt_conclusion1))
cat("\n")

# create table of conclusions
df_prop <-
  tibble(se_4a = "good",
         se_4b = "good")
df_conc <- tibble(se_3a = mgt_conclusion1)


#Rule 2: then management is moderate or good
if (ext_rb == "gmp") {
  # rule 2 only activated when ext is moderate
  
  if (rule2 >= 0.33)  {
    mgt_conclusion2 = "good"
  }     else if (rule2 > -0.33) {
    mgt_conclusion2 = "moderate"
  } else {
    mgt_conclusion2 = "poor"
  }
  cat(paste("rule 2 = ", mgt_conclusion2))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_3a = mgt_conclusion2)
  df_prop <-
    add_row(df_prop,
            se_4a = "moderate",
            se_4b = "good")
} else{
  cat(paste("No rule 2"))
  cat("\n")
}

#Rule 3: then management is poor, moderate or good

if (rule3 >= 0.33)  {
  mgt_conclusion3 = "good"
}     else if (rule3 > -0.33) {
  mgt_conclusion3 = "moderate"
} else {
  mgt_conclusion3 = "poor"
}

cat(paste("rule 3 = ", mgt_conclusion3))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_3a = mgt_conclusion3)
df_prop <-
  add_row(df_prop,
          se_4a = "poor",
          se_4b = "good")

#Rule 4: then management is poor, moderate or good
if (lab_rb == "gmp") {
  # rule 4 only activated when lab is moderate
  
  if (rule4 >= 0.33)  {
    mgt_conclusion4 = "good"
  }     else if (rule4 > -0.33) {
    mgt_conclusion4 = "moderate"
  } else {
    mgt_conclusion4 = "poor"
  }
  
  cat(paste("rule 4 = ", mgt_conclusion4))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_3a = mgt_conclusion4)
  df_prop <-
    add_row(df_prop,
            se_4a = "good",
            se_4b = "moderate")
} else{
  cat(paste("No rule 4"))
  cat("\n")
}


#Rule 5: then management is moderate
if (ext_rb == "gmp" & lab_rb == "gmp") {
  mgt_conclusion5 = "moderate"
  cat(paste("rule 5 = ", mgt_conclusion5))
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_3a = mgt_conclusion5)
  df_prop <- add_row(df_prop,
                   se_4a = "moderate",
                   se_4b = "moderate")
} else
  cat(paste("No rule 5"))
cat("\n")

#Rule 6: then management is poor, moderate or good

if (lab_rb == "gmp") {
  # rule 6 only activated when ext and lab are moderate
  if (rule6 >= 0.33)  {
    mgt_conclusion6 = "good"
  }     else if (rule6 > -0.33) {
    mgt_conclusion6 = "moderate"
  } else {
    mgt_conclusion6 = "poor"
  }
  cat(paste("rule 6 = ", mgt_conclusion6))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_3a = mgt_conclusion6)
  df_prop <-
    add_row(df_prop,
            se_4a = "poor",
            se_4b = "moderate")
  
} else{
  cat(paste("No rule 6"))
  cat("\n")
}


#Rule 7: then management is poor, moderate or good

if (rule7 >= 0.33)  {
  mgt_conclusion7 = "good"
}     else if (rule7 > -0.33) {
  mgt_conclusion7 = "moderate"
} else {
  mgt_conclusion7 = "poor"
}
cat(paste("rule 7 = ", mgt_conclusion7))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_3a = mgt_conclusion7)
df_prop <-
  add_row(df_prop,
          se_4a = "good",
          se_4b = "poor")


#Rule 8: then farm inputs access is poor, moderate or good

if (ext_rb == "gmp") {
  # rule 8 only activated when f/p is moderate
  if (rule8 >= 0.33)  {
    mgt_conclusion8 = "good"
  }     else if (rule8 > -0.33) {
    mgt_conclusion8 = "moderate"
  } else {
    mgt_conclusion8 = "poor"
  }
  cat(paste("rule 8 = ", mgt_conclusion8))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_3a = mgt_conclusion8)
  df_prop <-
    add_row(df_prop,
            se_4a = "moderate",
            se_4b = "poor")
} else{
  cat(paste("No rule 8"))
  cat("\n")
}

#Rule 9: then management is poor

mgt_conclusion9 = "poor"
cat(paste("rule 9 = ", mgt_conclusion9))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_3a = mgt_conclusion9)
df_prop <- add_row(df_prop,
                 se_4a = "poor",
                 se_4b = "poor")

``` 

```{r i2_rulebases_management06, echo=FALSE, results='asis', eval=fp_crit}

cat("This gives the rule base:")

```

<div class="fold o"> 
```{r i2_rulebases_management07, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=management_crit}

# new proposition object is made here
prop <- new("Proposition", table = df_prop)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here

conc <- new("Conclusion", table = df_conc)

# create a rule base
rb_se_3a <- RuleBase(prop, conc) %>% print()


# in this section there are normally two criteria - ext and labour

# access to extension is based on two criteria and has a rb (se_4a) and a rbs (se_4a) which includes the two constituent parts of extension and their two rb (se_5a & se5b)

# access to labour is based on two criteria and has a rb (se_4b) and a rbs (se_4b) which includes the two constituent parts of labour and their two rb (se_5c & se5d)

# there are four fp in total (se_5a, se_5b, se_5c and se5d)

rbs_se_3a <-
  stack(rb_se_5a,
        rb_se_5b,
        rb_se_4a,
        rb_se_5c,
        rb_se_5d,
        rb_se_4b,
        rb_se_3a)


fpm_se_3a <-
  
  predict(
    rbs_se_3a,
    newdata = df_irm_i2,
    se_5a = fp_se_5a,
    se_5b = fp_se_5b,
    se_5c = fp_se_5c,
    se_5d = fp_se_5d
  )


# write the membership values to df_irm_i2 and plot the maps of the conclusions

df_criteria_se2a_3a <-
  subset(df_priorities, grepl("^se_3a", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse2a_3a <- nrow(df_criteria_se2a_3a)

g_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se2a_3a[1, 3]))$good)
df_irm_i2 <-
  mutate(df_irm_i2,!!as.character(paste0(df_criteria_se2a_3a[1, 3], "_g")) := g_col, .keep = c("all"))




if (ext_rb == "gmp") {
  # there is a moderate conclusion to extension giving up to nine rules and conclusions
  
  if (lab_rb == "gmp") {
    # there is a moderate conclusion to extension and labour giving  nine rules and conclusions
    mgt_rule_num <- 9
    
    if (mgt_conclusion2 == "moderate" |
        mgt_conclusion3 == "moderate" |
        mgt_conclusion4 == "moderate" |
        mgt_conclusion5 == "moderate" |
        mgt_conclusion6 == "moderate" |
        mgt_conclusion7 == "moderate" |
        mgt_conclusion8 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se2a_3a[1, 3]))$moderate)
      df_irm_i2 <-
        mutate(df_irm_i2,!!as.character(paste0(df_criteria_se2a_3a[1, 3], "_m")) := m_col, .keep = c("all"))
      
      mgt_rb <- "gmp"
    } else { mgt_rb  <-  "gp"}
    
  } else {
    # there is a no moderate conclusion to labour giving  six rules and conclusions
    
    mgt_rule_num <- 6
    
    if (mgt_conclusion2 == "moderate" |
        mgt_conclusion3 == "moderate" |
        mgt_conclusion7 == "moderate" |
        mgt_conclusion8 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se2a_3a[1, 3]))$moderate)
      df_irm_i2 <-
        mutate(df_irm_i2,!!as.character(paste0(df_criteria_se2a_3a[1, 3], "_m")) := m_col, .keep = c("all"))
      
      mgt_rb <- "gmp"
    } else { mgt_rb  <-  "gp"}
    
    
  }
} else {
  # there is a no moderate conclusion to extension giving  six rules and conclusions
  
  if (lab_rb == "gmp") {
    #there is a moderate conclusion to labour giving up to six rules and conclusions
    
    mgt_rule_num <- 6
    
    if (mgt_conclusion3 == "moderate" |
        mgt_conclusion4 == "moderate" |
        mgt_conclusion6 == "moderate" |
        mgt_conclusion7 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se2a_3a[1, 3]))$moderate)
      df_irm_i2 <-
        mutate(df_irm_i2,!!as.character(paste0(df_criteria_se2a_3a[1, 3], "_m")) := m_col, .keep = c("all"))
      
      mgt_rb <- "gmp"
    } else { mgt_rb  <-  "gp"}
    
    
  }
  else {
    #there is no moderate conclusion to extension or labour giving four rules and conclusions
    
    mgt_rule_num <- 4
    
    if (mgt_conclusion3 == "moderate" |
        mgt_conclusion7 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se2a_3a[1, 3]))$moderate)
      df_irm_i2 <-
        mutate(df_irm_i2,!!as.character(paste0(df_criteria_se2a_3a[1, 3], "_m")) := m_col, .keep = c("all"))
      
      mgt_rb <- "gmp"
    } else { mgt_rb  <-  "gp"}
  }
}

p_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se2a_3a[1, 3]))$poor)
df_irm_i2 <-
  mutate(df_irm_i2,!!as.character(paste0(df_criteria_se2a_3a[1, 3], "_p")) := p_col, .keep = c("all"))


if (mgt_rb == "gmp") {
  n = 3
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se2a_3a[1, 3], "_g")),
      as.character(paste0(df_criteria_se2a_3a[1, 3], "_m")),
      as.character(paste0(df_criteria_se2a_3a[1, 3], "_p")),
      "x" ,
      "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se2a_3a[1, 4], " good")),
      as.character(paste0(df_criteria_se2a_3a[1, 4], " moderate")),
      as.character(paste0(df_criteria_se2a_3a[1, 4], " poor")))
} else {
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se2a_3a[1, 3], "_g")),  as.character(paste0(df_criteria_se2a_3a[1, 3], "_p")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se2a_3a[1, 4], " good")),  as.character(paste0(df_criteria_se2a_3a[1, 4], " poor")))
  
}
fpm_plot_title <-
  "Management\noptimality\nmembership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
print(plot_fpm)
     
``` 
</div>

```{r i2_rulebases_fpf01, echo=FALSE, results='asis', eval=fpf_crit}

cat("### Farm Production Feasibility

The farm production feasibility rule base (2a) combines propositions for management (rule base 3a), and access to farm inputs (rule base 3b).

Rule base 3a has the following conclusions:")

```


```{r i2_rulebases_fpf02, results='asis', warning=FALSE, eval=fpf_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria

df_criteria_se2a <-
  subset(df_priorities, grepl("^se_2a", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cse2a <- nrow(df_criteria_se2a)

# then determine and print the names of the rule bases in the Farm Production Feasibility theme

cat(paste("\n\n", n_cse2a, "Farm Production Feasibility rule bases:"))
for (i in 1:n_cse2a) {
  cat(
    paste0(
      "\n",
      df_criteria_se2a[i, 3],
      " (",
      df_criteria_se2a[i, 4],
      "):\n Weight = ",
      as.character(df_criteria_se2a[i, 5]),
      "\n"
    )
  )
}

```

```{r i2_rulebases_fpf03, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=fpf_crit}

if (mgt_rule_num == 9) {
  cat(paste("Rule base 3a has the following conclusions:"))
  
  mgt_conc_list <-
    c(
      mgt_conclusion1,
      mgt_conclusion2,
      mgt_conclusion3,
      mgt_conclusion4,
      mgt_conclusion5,
      mgt_conclusion6,
      mgt_conclusion7,
      mgt_conclusion8,
      mgt_conclusion9
    )
} else  if (mgt_rule_num == 6) {
  cat(paste("Rule base 3a has the following conclusions:"))
  
  if (ext_rb == "gmp") {
    mgt_conc_list <-
      c(
        mgt_conclusion1,
        mgt_conclusion2,
        mgt_conclusion3,
        mgt_conclusion7,
        mgt_conclusion8,
        mgt_conclusion9
      )
  } else  {
    mgt_conc_list <-
      c(
        mgt_conclusion1,
        mgt_conclusion3,
        mgt_conclusion4,
        mgt_conclusion6,
        mgt_conclusion7,
        mgt_conclusion9
      )
  }
} else  {
  cat(paste("Rule base 3a has the following conclusions:"))
  
  mgt_conc_list <-
    c(mgt_conclusion1,
      mgt_conclusion3,
      mgt_conclusion7,
      mgt_conclusion9)
}

cat(paste("\n Crop and Farm Management is", sort(unique(mgt_conc_list))))

```

```{r i2_rulebases_fpf04, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=fpf_crit}

if (inp_rb == "gmp" & inp_rule_num == 12) {
  cat(paste("Rule base 3b has the following conclusions:"))
  
  inp_conc_list <-
    c(
      inp_conclusion1,
      inp_conclusion2,
      inp_conclusion3,
      inp_conclusion4,
      inp_conclusion5,
      inp_conclusion6,
      inp_conclusion7,
      inp_conclusion8,
      inp_conclusion9,
      inp_conclusion10,
      inp_conclusion11,
      inp_conclusion12
    )
} else {
  cat(paste("Rule base 3b has the following conclusions:"))
  
  inp_conc_list <-
    c(
      inp_conclusion1,
      inp_conclusion3,
      inp_conclusion4,
      inp_conclusion6,
      inp_conclusion7,
      inp_conclusion9,
      inp_conclusion10,
      inp_conclusion12
    )
}

cat(paste("\n Farm Inputs is", sort(unique(inp_conc_list))))

```

```{r i2_rulebases_fpf05, echo=FALSE, results='asis', eval=fpf_crit}

cat("This rule base has nine possible rules and three possible outcomes: low, moderate and high feasibility:


Rule 1: If se_3a are good and se_3b is good then se_2a is high
Rule 2: If se_3a are moderate and se_3b is good then se_2a is moderate or high
Rule 3: If se_3a are poor and se_3b is good then se_2a is low, moderate or high
Rule 4: If se_3a are good and se_3b is moderate then se_2a is low, moderate or high
Rule 5: If se_3a are moderate and se_3b is moderate then se_2a is moderate
Rule 6: If se_3a are poor and se_3b is moderate then se_2a is low, moderate or high
Rule 7: If se_3a are good and se_3b is poor then se_2a is low, moderate or high
Rule 8: If se_3a are moderate and se_3b is poor then se_2a is low or moderate
Rule 9: If se_3a is poor and se_3b is poor then se_2a is low



Using the weights assigned by AHP the outcomes are the following:")

```


```{r i2_rulebases_fpf06, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=fpf_crit}


df_criteria_se3a <-
  subset(df_priorities, grepl("^se_3a", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse3a <- nrow(df_criteria_se3a)

df_criteria_se3b <-
  subset(df_priorities, grepl("^se_3b", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse3b <- nrow(df_criteria_se3b)



#Rule 2: If management access is moderate and farm inputs is good
rule2 <-
  df_criteria_se3b$weight[1]

#Rule 3: If management access is poor and farm inputs is good
rule3 <-
  -df_criteria_se3a$weight[1] + df_criteria_se3b$weight[1]

#Rule 4: If management access is good and farm inputs is moderate
rule4  <-
  df_criteria_se3a$weight[1]

#Rule 6: If management access is poor and farm inputs is moderate
rule6  <-
  -df_criteria_se3a$weight[1]

#Rule 7: If management access is good and farm inputs is poor
rule7  <-
  df_criteria_se3a$weight[1] - df_criteria_se3b$weight[1]

#Rule 8: If management access is moderate and farm inputs is poor
rule8  <-
  -df_criteria_se3b$weight[1]




rm(df_conc) # remove previous instances of df_conc
rm(df_prop) # remove previous instances of df_prop

#Rule 1: then farm production feasibility is high

fpf_conclusion1 = "high" # always good
cat(paste("rule 1 = ", fpf_conclusion1))
cat("\n")

# create table of conclusions
df_prop <-
  tibble(se_3a = "good",
         se_3b = "good")
df_conc <- tibble(se_2a = fpf_conclusion1)


#Rule 2: then farm production feasibility is moderate or good
if (mgt_rb == "gmp") {
  # rule 2 only activated when mgt is moderate
  
  if (rule2 >= 0.33)  {
    fpf_conclusion2 = "high"
  }     else if (rule2 > -0.33) {
    fpf_conclusion2 = "moderate"
  } else {
    fpf_conclusion2 = "poor"
  }
  cat(paste("rule 2 = ", fpf_conclusion2))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_2a = fpf_conclusion2)
  df_prop <-
    add_row(df_prop,
            se_3a = "moderate",
            se_3b = "good")
} else {
  cat(paste("No rule 2"))
  cat("\n")
}

#Rule 3: then farm production feasibility is low, moderate or high

if (rule3 >= 0.33)  {
  fpf_conclusion3 = "high"
}     else if (rule3 > -0.33) {
  fpf_conclusion3 = "moderate"
} else {
  fpf_conclusion3 = "low"
}

cat(paste("rule 3 = ", fpf_conclusion3))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_2a = fpf_conclusion3)
df_prop <-
  add_row(df_prop,
          se_3a = "poor",
          se_3b = "good")

#Rule 4: then farm production feasibility is low, moderate or high
if (inp_rb == "gmp") {
  # rule 4 only activated when inputs is moderate
  
  if (rule4 >= 0.33)  {
    fpf_conclusion4 = "high"
  }     else if (rule4 > -0.33) {
    fpf_conclusion4 = "moderate"
  } else {
    fpf_conclusion4 = "low"
  }
  
  cat(paste("rule 4 = ", fpf_conclusion4))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_2a = fpf_conclusion4)
  df_prop <-
    add_row(df_prop,
            se_3a = "good",
            se_3b = "moderate")
} else{
  cat(paste("No rule 4"))
  cat("\n")
}


#Rule 5: then farm production feasibility is moderate
if (mgt_rb == "gmp" & inp_rb == "gmp") {
  fpf_conclusion5 = "moderate"
  cat(paste("rule 5 = ", fpf_conclusion5))
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_2a = fpf_conclusion5)
  df_prop <- add_row(df_prop,
                   se_3a = "moderate",
                   se_3b = "moderate")
} else{
  cat(paste("No rule 5"))
  cat("\n")
}

#Rule 6: then farm production feasibility is low, moderate or high

if (inp_rb == "gmp") {
  # rule 6 only activated when mgt and lab are moderate
  if (rule6 >= 0.33)  {
    fpf_conclusion6 = "high"
  }     else if (rule6 > -0.33) {
    fpf_conclusion6 = "moderate"
  } else {
    fpf_conclusion6 = "low"
  }
  cat(paste("rule 6 = ", fpf_conclusion6))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_2a = fpf_conclusion6)
  df_prop <-
    add_row(df_prop,
            se_3a = "poor",
            se_3b = "moderate")
  
} else{
  cat(paste("No rule 6"))
  cat("\n")
}


#Rule 7: then farm production feasibility is low, moderate or high

if (rule7 >= 0.33)  {
  fpf_conclusion7 = "high"
}     else if (rule7 > -0.33) {
  fpf_conclusion7 = "moderate"
} else {
  fpf_conclusion7 = "low"
}
cat(paste("rule 7 = ", fpf_conclusion7))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_2a = fpf_conclusion7)
df_prop <-
  add_row(df_prop,
          se_3a = "good",
          se_3b = "poor")


#Rule 8: then farm production feasibility is low, moderate or high

if (mgt_rb == "gmp") {
  # rule 8 only activated when f/p is moderate
  if (rule8 >= 0.33)  {
    fpf_conclusion8 = "high"
  }     else if (rule8 > -0.33) {
    fpf_conclusion8 = "moderate"
  } else {
    fpf_conclusion8 = "low"
  }
  cat(paste("rule 8 = ", fpf_conclusion8))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_2a = fpf_conclusion8)
  df_prop <-
    add_row(df_prop,
            se_3a = "moderate",
            se_3b = "poor")
} else{
  cat(paste("No rule 8"))
  cat("\n")
}

#Rule 9: then farm production feasibility is low

fpf_conclusion9 = "low"
cat(paste("rule 9 = ", fpf_conclusion9))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_2a = fpf_conclusion9)
df_prop <- add_row(df_prop,
                 se_3a = "poor",
                 se_3b = "poor")

```

```{r i2_rulebases_fpf07, echo=FALSE, results='asis', eval=fpf_crit}

cat("This gives the rule base:")

```

<div class="fold o"> 
```{r i2_rulebases_fpf08, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=fpf_crit}

# new proposition object is made here
prop <- new("Proposition", table = df_prop)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here

conc <- new("Conclusion", table = df_conc)

# create a rule base
rb_se_2a <- RuleBase(prop, conc) %>% print()


# in this section there are normally two criteria - management and inputs

# management is based on two criteria and has a rb (se_3a) and includes extension and labour their two rb (se_4a & se4b).
# Extension includes two further criteria with rule bases (se_5a & se_5b) each with fuzzy partitions.
# Access to labour is based on two criteria and their two rb (se_5c & se5d) each with fuzzy partitions.

# farm inputs is based on three criteria and has a rb (se_3b) and includes access to seeds and land and their two rb (se_4d & se4e) each with fuzzy partitions.
# Access to fertilisers and pesticides has a rb (se_4c) and includes two criteria and their two rb (se_5e & se5f) each with fuzzy partitions.


# there are eight fp in total (se_4d, se_4e, se_5a, se_5b, se_5c, se5d, se_5e and se_5f)

rbs_se_2a <-
  stack(
    rb_se_5a,
    rb_se_5b,
    rb_se_4a,
    rb_se_5c,
    rb_se_5d,
    rb_se_4b,
    rb_se_3a,
    rb_se_5e,
    rb_se_5f,
    rb_se_4c,
    rb_se_4d,
    rb_se_4e,
    rb_se_3b,
    rb_se_2a
  )


fpm_se_2a <-
  
  predict(
    rbs_se_2a,
    newdata = df_irm_i2,
    se_4d = fp_se_4d,
    se_4e = fp_se_4e,
    se_5a = fp_se_5a,
    se_5b = fp_se_5b,
    se_5c = fp_se_5c,
    se_5d = fp_se_5d,
    se_5e = fp_se_5e,
    se_5f = fp_se_5f
  )


# write the membership values to df_irm_i2 and plot the maps of the conclusions

df_criteria_se1_2a <-
  subset(df_priorities, grepl("^se_2a", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse1_2a <- nrow(df_criteria_se1_2a)

h_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se1_2a[1, 3]))$high)
df_irm_i2 <-
  mutate(df_irm_i2,!!as.character(paste0(df_criteria_se1_2a[1, 3], "_h")) := h_col, .keep = c("all"))




if (mgt_rb == "gmp") {
  # there is a moderate conclusion to management giving up to nine rules and conclusions
  
  if (inp_rb == "gmp") {
    # there is a moderate conclusion to management and inputs giving nine rules and conclusions
    fpf_rule_num <- 9
    
    if (fpf_conclusion2 == "moderate" |
        fpf_conclusion3 == "moderate" |
        fpf_conclusion4 == "moderate" |
        fpf_conclusion5 == "moderate" |
        fpf_conclusion6 == "moderate" |
        fpf_conclusion7 == "moderate" |
        fpf_conclusion8 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se1_2a[1, 3]))$moderate)
      df_irm_i2 <-
        mutate(df_irm_i2,!!as.character(paste0(df_criteria_se1_2a[1, 3], "_m")) := m_col, .keep = c("all"))
      
      fpf_rb <- "hml"
    }
    
  } else {
    # there is a no moderate conclusion to labour giving  six rules and conclusions
    
    fpf_rule_num <- 6
    
    if (fpf_conclusion2 == "moderate" |
        fpf_conclusion3 == "moderate" |
        fpf_conclusion7 == "moderate" |
        fpf_conclusion8 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se1_2a[1, 3]))$moderate)
      df_irm_i2 <-
        mutate(df_irm_i2,!!as.character(paste0(df_criteria_se1_2a[1, 3], "_m")) := m_col, .keep = c("all"))
      
      fpf_rb <- "hml"
    }
  }
} else {
  # there is a no moderate conclusion to extension giving  six rules and conclusions
  
  if (inp_rb == "gmp") {
    #there is a moderate conclusion to labour giving up to six rules and conclusions
    
    fpf_rule_num <- 6
    
    if (fpf_conclusion3 == "moderate" |
        fpf_conclusion4 == "moderate" |
        fpf_conclusion6 == "moderate" |
        fpf_conclusion7 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se1_2a[1, 3]))$moderate)
      df_irm_i2 <-
        mutate(df_irm_i2,!!as.character(paste0(df_criteria_se1_2a[1, 3], "_m")) := m_col, .keep = c("all"))
      
      fpf_rb <- "hml"
    }
  } else {
    #there is no moderate conclusion to extension or labour giving four rules and conclusions
    
    fpf_rule_num <- 4
    
    if (fpf_conclusion3 == "moderate" |
        fpf_conclusion7 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se1_2a[1, 3]))$moderate)
      df_irm_i2 <-
        mutate(df_irm_i2,!!as.character(paste0(df_criteria_se1_2a[1, 3], "_m")) := m_col, .keep = c("all"))
      
      fpf_rb <- "hml"
    }
  }
}

l_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se1_2a[1, 3]))$low)
df_irm_i2 <-
  mutate(df_irm_i2,!!as.character(paste0(df_criteria_se1_2a[1, 3], "_l")) := l_col, .keep = c("all"))


if (fpf_rb == "hml") {
  n = 3
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se1_2a[1, 3], "_h")),
      as.character(paste0(df_criteria_se1_2a[1, 3], "_m")),
      as.character(paste0(df_criteria_se1_2a[1, 3], "_l")),
      "x" ,
      "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se1_2a[1, 4], " high")),
      as.character(paste0(df_criteria_se1_2a[1, 4], " moderate")),
      as.character(paste0(df_criteria_se1_2a[1, 4], " low")))
} else {
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se1_2a[1, 3], "_h")),  as.character(paste0(df_criteria_se1_2a[1, 3], "_l")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se1_2a[1, 4], " high")),  as.character(paste0(df_criteria_se1_2a[1, 4], " low")))
  
}
fpm_plot_title <-
  "Farm Production\nFeasibility\noptimality\nmembership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
print(plot_fpm)
  
``` 
</div>

```{r i2_rulebases_market_access01, echo=FALSE, results='asis', eval=mktaccess_crit}

cat("### Market Access

The market access rule base (se_2b) combines propositions for time to kebele markets (rule base se_3c), time to woreda markets (rule base se_3d) and time to zonal centre (wholesalers) (rule base se_3d).

Rule base se_2b has the following propositions:

[1] '(1) se_3c is good'  '(1) se_3c is poor'
[1] '(2) se_3d is good'  '(2) se_3d is poor'
[1] '(3) se_3e is good'  '(3) se_3e is poor'")

```


```{r i2_rulebases_market_access02, cache = TRUE, cache.whatever=params$Agg, results='asis', eval=mktaccess_crit}

for (i in 1:(nrow(df_criteria_se2b))) {
  print(paste0(
    df_criteria_se2b[i, 3],
    " (",
    df_criteria_se2b[i, 4],
    "): Weight = ",
    as.character(df_criteria_se2b[i, 5])
  ))
}

``` 


```{r i2_rulebases_market_access03, echo=FALSE, results='asis', eval=mktaccess_crit}

cat("This rule base has eight rules and three possible outcomes: good, moderate and poor access:

Rule 1: If se_3c  is good and se_3d  is good and se_3e  is good then se_2b is good
Rule 2: If se_3c  is poor and se_3d  is good and se_3e  is good then se_2b is poor, moderate or good
Rule 3: If se_3c  is good and se_3d  is poor and se_3e  is good then se_2b is poor, moderate or good
Rule 4: If se_3c  is poor and se_3d  is poor and se_3e  is good then se_2b is poor, moderate or good
Rule 5: If se_3c  is good and se_3d  is good and se_3e  is poor then se_2b is poor, moderate or good
Rule 6: If se_3c  is poor and se_3d  is good and se_3e  is poor then se_2b is poor, moderate or good
Rule 7: If se_3c  is good and se_3d  is poor and se_3e  is poor then se_2b is poor, moderate or good
Rule 8: If se_3c  is poor and se_3d  is poor and se_3e  is poor then se_2b is poor

Using the weights assigned by AHP the outcomes are the following:")

```

 
```{r i2_rulebases_market_access04, cache = TRUE, cache.whatever=params$Agg, results='asis', eval=mktaccess_crit}

df_criteria_se3c <-
  subset(df_priorities, grepl("^se_3c", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse3c <- nrow(df_criteria_se3c)

df_criteria_se3d <-
  subset(df_priorities, grepl("^se_3d", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse3d <- nrow(df_criteria_se3d)

df_criteria_se3e <-
  subset(df_priorities, grepl("^se_3e", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse3e <- nrow(df_criteria_se3e)



#Rule 2: If kebele market access is poor and woreda market access is good and zonal market access is good
rule2 <-
  -df_criteria_se3c$weight[1] + df_criteria_se3d$weight[1] + df_criteria_se3e$weight[1]

#Rule 3: If kebele market access is good and woreda market access is poor and zonal market access is good
rule3 <-
  df_criteria_se3c$weight[1] - df_criteria_se3d$weight[1] + df_criteria_se3e$weight[1]

#Rule 4: If kebele market access is poor and woreda market access is poor and zonal market access is good
rule4 <-
  -df_criteria_se3c$weight[1] - df_criteria_se3d$weight[1] + df_criteria_se3e$weight[1]

#Rule 5: If kebele market access is good and woreda market access is good and zonal market access is poor
rule5 <-
  df_criteria_se3c$weight[1] + df_criteria_se3d$weight[1] - df_criteria_se3e$weight[1]

#Rule 6: If kebele market access is poor and woreda market access is good and zonal market access is poor
rule6 <-
  -df_criteria_se3c$weight[1] + df_criteria_se3d$weight[1] - df_criteria_se3e$weight[1]

#Rule 7: If kebele market access is good and woreda market access is poor and zonal market access is poor
rule7 <-
  df_criteria_se3c$weight[1] - df_criteria_se3d$weight[1] - df_criteria_se3e$weight[1]


rm(df_conc) # remove previous instances of df_conc

#Rule 1: then market access is always good
ma_conclusion1 = "good"
cat(paste("rule 1 = ", ma_conclusion1))
cat("\n")
# create table of conclusions
df_conc <- tibble(se_2b = ma_conclusion1)

#Rule 2: then market access is poor, moderate or good
if (rule2 >= 0.33)  {
  ma_conclusion2 = "good"
}     else if (rule2 > -0.33) {
  ma_conclusion2 = "moderate"
} else {
  ma_conclusion2 = "poor"
}
cat(paste("rule 2 = ", ma_conclusion2))
cat("\n")
df_conc <- add_row(df_conc, se_2b = ma_conclusion2)

#Rule 3: then market access is poor, moderate or good
if (rule3 >= 0.33)  {
  ma_conclusion3 = "good"
}     else if (rule3 > -0.33) {
  ma_conclusion3 = "moderate"
} else {
  ma_conclusion3 = "poor"
}
cat(paste("rule 3 = ", ma_conclusion3))
cat("\n")
df_conc <- add_row(df_conc, se_2b = ma_conclusion3)

#Rule 4: then market access is poor, moderate or good
if (rule4 >= 0.33)  {
  ma_conclusion4 = "good"
}     else if (rule4 > -0.33) {
  ma_conclusion4 = "moderate"
} else {
  ma_conclusion4 = "poor"
}
cat(paste("rule 4 = ", ma_conclusion4))
cat("\n")
df_conc <- add_row(df_conc, se_2b = ma_conclusion4)

#Rule 5: then market access is poor, moderate or good
if (rule5 >= 0.33)  {
  ma_conclusion5 = "good"
}     else if (rule5 > -0.33) {
  ma_conclusion5 = "moderate"
} else {
  ma_conclusion5 = "poor"
}
cat(paste("rule 5 = ", ma_conclusion5))
cat("\n")
df_conc <- add_row(df_conc, se_2b = ma_conclusion5)

#Rule 6: then market access is poor, moderate or good
if (rule6 >= 0.33)  {
  ma_conclusion6 = "good"
}     else if (rule6 > -0.33) {
  ma_conclusion6 = "moderate"
} else {
  ma_conclusion6 = "poor"
}
cat(paste("rule 6 = ", ma_conclusion6))
cat("\n")
df_conc <- add_row(df_conc, se_2b = ma_conclusion6)

#Rule 7: then market access is poor, moderate or good
if (rule7 >= 0.33)  {
  ma_conclusion7 = "good"
}     else if (rule7 > -0.33) {
  ma_conclusion7 = "moderate"
} else {
  ma_conclusion7 = "poor"
}
cat(paste("rule 7 = ", ma_conclusion7))
cat("\n")
df_conc <- add_row(df_conc, se_2b = ma_conclusion7)

#Rule 8: then market access is always poor
ma_conclusion8 = "poor"
cat(paste("rule 8 = ", ma_conclusion8))
df_conc <- add_row(df_conc, se_2b = ma_conclusion8)

``` 

```{r i2_rulebases_market_access05, echo=FALSE, results='asis', eval=mktaccess_crit}

cat("This gives the rule base:")

```

<div class="fold o"> 
```{r i2_rulebases_market_access06, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=mktaccess_crit}


df_criteria_se1_2b <-
  subset(df_priorities, grepl("^se_2b", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse1_2b <- nrow(df_criteria_se1_2b)

# df_criteria_se2b includes all of the market access criteria
# for each criterion we know that the new proposition is the same as the conclusion from the previous rule base

assign(paste0("rbs_", df_criteria_se1_2b[1, 3], "_list"), c()) # initialise the rule base list
assign(paste0("fp_", df_criteria_se1_2b[1, 3], "_list"), c()) # initialise the fuzzy partition list
rm(df_prop) # remove previous instances of df_prop

rm(prop)
rm(conc)
for (i in 1:(nrow(df_criteria_se2b))) {
  # set the proposition name
  Prop_name <-
    paste0(as.character(df_criteria_se2b[i, 3]), "_o")
  
  # for those criteria with three conclusion values
  # get  the 3 conclusion levels and get the unique values
  prop_levels <-
    c(as.character(df_criteria_se2b[i, 19]),
      as.character(df_criteria_se2b[i, 20]))  %>% unique()
  
  
  
  # set the proposition values
  if (!exists("df_prop")) {
    df_prop <- tibble(!!Prop_name := c(prop_levels))
  } else {
    #new_df_prop <- tibble(!!Prop_name := c(prop_levels))
    df_prop <-
      bind_cols(df_prop, tibble(!!Prop_name := c(prop_levels)))
  }
  
  # get a list of the previous rule bases
  assign(paste0("rbs_", df_criteria_se1_2b[1, 3], "_list"),
         append(get(
           paste0("rbs_", df_criteria_se1_2b[1, 3], "_list")
         ), paste0("rb_", df_criteria_se2b[i, 3])))
  
  # get a list of the fuzzy partitions
  assign(paste0("fp_", df_criteria_se1_2b[1, 3], "_list"),
         append(
           get(paste0("fp_", df_criteria_se1_2b[1, 3], "_list")),
           paste0(df_criteria_se2b[i, 3], " = fp_", df_criteria_se2b[i, 3])
         ))
}

# new proposition object is made here
prop <- new("Proposition", table = df_prop %>% cross_df)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here

conc <- new("Conclusion", table = df_conc)

# create a rule base
assign(paste0("rb_", df_criteria_se1_2b[1, 3]), RuleBase(prop, conc)) %>% print()


# add to the list of previous rule bases

assign(paste0("rbs_", df_criteria_se1_2b[1, 3], "_list"),
       append(get(
         paste0("rbs_", df_criteria_se1_2b[1, 3], "_list")
       ), paste0("rb_", df_criteria_se1_2b[1, 3])))

# create the rule base stack from the list

# original rbs_tmp_aptitude <- stack(rb_tmp_g_4a, rb_tmp_v_4b, rb_tmp_f_4c, rb_tmp_r_4d, rb_P_3a)

x <-
  paste("stack(", gsub(",$", "", paste0(
    get(paste0("rbs_", df_criteria_se1_2b[1, 3], "_list")), sep = ",", collapse = ""
  )), ")")

rbs_tmp <-
  assign(paste0("rbs_", df_criteria_se1_2b[1, 3]), eval(parse(text = x)))

# evaluate the rule base stack

w <-
  paste("predict(",
        "rbs_tmp, newdata = df_irm_i2,",
        gsub(",$", "", paste0(
          get(paste0("fp_", df_criteria_se1_2b[1, 3], "_list")), sep = ",", collapse = ""
        )),
        ")")

assign(paste0("fpm_", df_criteria_se1_2b[1, 3]), eval(parse(text = w)))




g_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se1_2b[1, 3]))$good)
df_irm_i2 <-
  mutate(df_irm_i2,!!as.character(paste0(df_criteria_se1_2b[1, 3], "_g")) := g_col, .keep = c("all"))

if (ma_conclusion2 == "moderate" |
    ma_conclusion3 == "moderate" |
    ma_conclusion4 == "moderate" |
    ma_conclusion5 == "moderate" |
    ma_conclusion6 == "moderate" | ma_conclusion7 == "moderate") {
  m_col <- getMembership(get(paste0("fpm_",
                                    df_criteria_se1_2b[1, 3]))$moderate)
  df_irm_i2 <-
    mutate(df_irm_i2,!!as.character(paste0(df_criteria_se1_2b[1, 3], "_m")) := m_col, .keep = c("all"))
  
  ma_rb <- "gmp"
} else
  ma_rb <- "gp"

p_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se1_2b[1, 3]))$poor)
df_irm_i2 <-
  mutate(df_irm_i2,!!as.character(paste0(df_criteria_se1_2b[1, 3], "_p")) := p_col, .keep = c("all"))


if (ma_rb == "gmp") {
  n = 3
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se1_2b[1, 3], "_g")),
      as.character(paste0(df_criteria_se1_2b[1, 3], "_m")),
      as.character(paste0(df_criteria_se1_2b[1, 3], "_p")),
      "x" ,
      "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se1_2b[1, 4], " good")),
      as.character(paste0(df_criteria_se1_2b[1, 4], " moderate")),
      as.character(paste0(df_criteria_se1_2b[1, 4], " poor")))
} else {
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se1_2b[1, 3], "_g")),  as.character(paste0(df_criteria_se1_2b[1, 3], "_p")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se1_2b[1, 4], " good")),  as.character(paste0(df_criteria_se1_2b[1, 4], " poor")))
  
}
fpm_plot_title <-
  "Market\nAccess\noptimality\nmembership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
print(plot_fpm)

``` 
</div>

```{r i2_rulebases_sef02, echo=FALSE, results='asis', eval=sef_crit}

cat("### Socio-Economic Feasibility

Socio-Economic feasibility rule base (1) combines propositions for farm production feasibility (rule base 2a), and Market Access (rule base 2b).

Rule base 2a has the following conclusions:")

```


```{r i2_rulebases_sef03, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=sef_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria


df_criteria_se1 <-
  subset(df_priorities, grepl("^se_1", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_cse1 <- nrow(df_criteria_se1)

# then determine and print the names of the rule bases in the Socio-Economic Feasibility theme

cat(paste("\n\n", n_cse1, "Socio-Economic Feasibility rule bases:"))
for (i in 1:n_cse1) {
  cat(
    paste0(
      "\n",
      df_criteria_se1[i, 3],
      " (",
      df_criteria_se1[i, 4],
      "):\n Weight = ",
      as.character(df_criteria_se1[i, 5]),
      "\n"
    )
  )
}

```

```{r i2_rulebases_sef04, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=sef_crit}

if (fpf_rule_num == 9) {
  cat(paste("Rule base 2a has the following conclusions:"))
  
  fpf_conc_list <-
    c(
      fpf_conclusion1,
      fpf_conclusion2,
      fpf_conclusion3,
      fpf_conclusion4,
      fpf_conclusion5,
      fpf_conclusion6,
      fpf_conclusion7,
      fpf_conclusion8,
      fpf_conclusion9
    )
} else  if (fpf_rule_num == 6) {
  cat(paste("Rule base 2a has the following conclusions:"))
  
  if (mgt_rb == "gmp") {
    fpf_conc_list <-
      c(
        fpf_conclusion1,
        fpf_conclusion2,
        fpf_conclusion3,
        fpf_conclusion7,
        fpf_conclusion8,
        fpf_conclusion9
      )
  } else  {
    fpf_conc_list <-
      c(
        fpf_conclusion1,
        fpf_conclusion3,
        fpf_conclusion4,
        fpf_conclusion6,
        fpf_conclusion7,
        fpf_conclusion9
      )
  }
} else  {
  cat(paste("Rule base 2a has the following conclusions:"))
  
  fpf_conc_list <-
    c(fpf_conclusion1,
      fpf_conclusion3,
      fpf_conclusion7,
      fpf_conclusion9)
}

cat(paste("\n Farm Production Feasibility is", sort(unique(fpf_conc_list))))

```


```{r i2_rulebases_sef05, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=sef_crit}

ma_conc_list <-
  c(
    ma_conclusion1,
    ma_conclusion2,
    ma_conclusion3,
    ma_conclusion4,
    ma_conclusion5,
    ma_conclusion6,
    ma_conclusion7,
    ma_conclusion8
  )
cat(paste("\n Market Access is", sort(unique(ma_conc_list))))

```


```{r i2_rulebases_sef06, echo=FALSE, results='asis', eval=sef_crit}

cat("This rule base has nine possible rules and three possible outcomes: low, moderate and high feasibility:

Rule 1: If se_3a are high and se_3b is good then se_2a is high
Rule 2: If se_3a are moderate and se_3b is good then se_2a is moderate or high
Rule 3: If se_3a are low and se_3b is good then se_2a is low, moderate or high
Rule 4: If se_3a are high and se_3b is moderate then se_2a is low, moderate or high
Rule 5: If se_3a are moderate and se_3b is moderate then se_2a is moderate
Rule 6: If se_3a are low and se_3b is moderate then se_2a is low, moderate or high
Rule 7: If se_3a are high and se_3b is poor then se_2a is low, moderate or good
Rule 8: If se_3a are moderate and se_3b is poor then se_2a is low or moderate
Rule 9: If se_3a is low and se_3b is poor then se_2a is low

Using the weights assigned by AHP the outcomes are the following:")

```


```{r i2_rulebases_sef07, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=sef_crit}

df_criteria_se2a <-
  subset(df_priorities, grepl("^se_2a", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse2a <- nrow(df_criteria_se2a)

df_criteria_se2b <-
  subset(df_priorities, grepl("^se_2b", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse2b <- nrow(df_criteria_se2b)



#Rule 2: If fp feasibility is moderate and market access is good
rule2 <-
  df_criteria_se2b$weight[1]

#Rule 3: If fp feasibility is low and market access is good
rule3 <-
  -df_criteria_se2a$weight[1] + df_criteria_se2b$weight[1]

#Rule 4: If fp feasibility is high and market access is moderate
rule4  <-
  df_criteria_se2a$weight[1]

#Rule 6: If fp feasibility is low and market access is moderate
rule6  <-
  -df_criteria_se2a$weight[1]

#Rule 7: If fp feasibility is high and market access is poor
rule7  <-
  df_criteria_se2a$weight[1] - df_criteria_se2b$weight[1]

#Rule 8: If fp feasibility is moderate and market access is poor
rule8  <-
  -df_criteria_se2b$weight[1]




rm(df_conc) # remove previous instances of df_conc
rm(df_prop) # remove previous instances of df_prop

#Rule 1: then socio-economic feasibility is high

sef_conclusion1 = "high" # always high
cat(paste("rule 1 = ", sef_conclusion1))
cat("\n")

# create table of conclusions
df_prop <-
  tibble(se_2a = "high",
         se_2b = "good")
df_conc <- tibble(se_1 = sef_conclusion1)


#Rule 2: then socio-economic feasibility is moderate or high
if (fpf_rb == "hml") {
  # rule 2 only activated when fpf is moderate
  
  if (rule2 >= 0.33)  {
    sef_conclusion2 = "high"
  }     else if (rule2 > -0.33) {
    sef_conclusion2 = "moderate"
  } else {
    sef_conclusion2 = "low"
  }
  cat(paste("rule 2 = ", sef_conclusion2))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_1 = sef_conclusion2)
  df_prop <-
    add_row(df_prop,
            se_2a = "moderate",
            se_2b = "good")
} else {
  cat(paste("No rule 2"))
  cat("\n")
}

#Rule 3: then socio-economic feasibility is low, moderate or high

if (rule3 >= 0.33)  {
  sef_conclusion3 = "high"
}     else if (rule3 > -0.33) {
  sef_conclusion3 = "moderate"
} else {
  sef_conclusion3 = "low"
}

cat(paste("rule 3 = ", sef_conclusion3))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_1 = sef_conclusion3)
df_prop <-
  add_row(df_prop,
          se_2a = "low",
          se_2b = "good")

#Rule 4: then socio-economic feasibility is low, moderate or high
if (ma_rb == "gmp") {
  # rule 4 only activated when ma is moderate
  
  if (rule4 >= 0.33)  {
    sef_conclusion4 = "high"
  }     else if (rule4 > -0.33) {
    sef_conclusion4 = "moderate"
  } else {
    sef_conclusion4 = "low"
  }
  
  cat(paste("rule 4 = ", sef_conclusion4))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_1 = sef_conclusion4)
  df_prop <-
    add_row(df_prop,
            se_2a = "high",
            se_2b = "moderate")
} else{
  cat(paste("No rule 4"))
  cat("\n")
}


#Rule 5: then socio-economic feasibility is moderate
if (fpf_rb == "hml" & ma_rb == "gmp") {
  sef_conclusion5 = "moderate"
  cat(paste("rule 5 = ", sef_conclusion5))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_1 = sef_conclusion5)
  df_prop <- add_row(df_prop,
                   se_2a = "moderate",
                   se_2b = "moderate")
} else{
  cat(paste("No rule 5"))
  cat("\n")
}

#Rule 6: then socio-economic feasibility is low, moderate or high

if (ma_rb == "gmp") {
  # rule 6 only activated when fpf and ma are moderate
  if (rule6 >= 0.33)  {
    sef_conclusion6 = "high"
  }     else if (rule6 > -0.33) {
    sef_conclusion6 = "moderate"
  } else {
    sef_conclusion6 = "low"
  }
  cat(paste("rule 6 = ", sef_conclusion6))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_1 = sef_conclusion6)
  df_prop <-
    add_row(df_prop,
            se_2a = "low",
            se_2b = "moderate")
  
} else{
  cat(paste("No rule 6"))
  cat("\n")
}


#Rule 7: then socio-economic feasibility is low, moderate or high

if (rule7 >= 0.33)  {
  sef_conclusion7 = "high"
}     else if (rule7 > -0.33) {
  sef_conclusion7 = "moderate"
} else {
  sef_conclusion7 = "low"
}
cat(paste("rule 7 = ", sef_conclusion7))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_1 = sef_conclusion7)
df_prop <-
  add_row(df_prop,
          se_2a = "high",
          se_2b = "poor")


#Rule 8: then socio-economic feasibility is low, moderate or high

if (fpf_rb == "hml") {
  # rule 8 only activated when fpf is moderate
  if (rule8 >= 0.33)  {
    sef_conclusion8 = "high"
  }     else if (rule8 > -0.33) {
    sef_conclusion8 = "moderate"
  } else {
    sef_conclusion8 = "low"
  }
  cat(paste("rule 8 = ", sef_conclusion8))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, se_1 = sef_conclusion8)
  df_prop <-
    add_row(df_prop,
            se_2a = "moderate",
            se_2b = "poor")
} else{
  cat(paste("No rule 8"))
  cat("\n")
}

#Rule 9: then socio-economic feasibility is low

sef_conclusion9 = "low"
cat(paste("rule 9 = ", sef_conclusion9))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, se_1 = sef_conclusion9)
df_prop <- add_row(df_prop,
                 se_2a = "low",
                 se_2b = "poor")

```

```{r i2_rulebases_sef08, echo=FALSE, results='asis', eval=sef_crit}

cat("This gives the rule base:")

```

<div class="fold o"> 
```{r i2_rulebases_sef09, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=sef_crit}

# new proposition object is made here
prop <- new("Proposition", table = df_prop)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here

conc <- new("Conclusion", table = df_conc)

# create a rule base
rb_se_1 <- RuleBase(prop, conc) %>% print()


# in this section there are normally two criteria - fp feasibility and market access

# fp feasibility is based on two criteria and has a rb (se_2a) and includes management and inputs and their two rb (se_3a & se3b).
# management is based on two criteria: extension and labour their two rb (se_4a & se4b).
# Extension includes two further criteria with rule bases (se_5a & se_5b) each with fuzzy partitions.
# Access to labour is based on two criteria and their two rb (se_5c & se5d) each with fuzzy partitions.

# farm inputs is based on three criteria: access to seeds and land and their two rb (se_4d & se4e) each with fuzzy partitions.
# Access to fertilisers and pesticides has a rb (se_4c) and includes two criteria and their two rb (se_5e & se5f) each with fuzzy partitions.

# market access has a rb (se_2b) and includes three criteria and their three rb (se_3c, se_3d & se3e) each with fuzzy partitions.

# there are eleven fp in total (se_3c, se_3d, se3e, se_4d, se_4e, se_5a, se_5b, se_5c, se5d, se_5e and se_5f)

rbs_se_1 <-
  stack(
    rb_se_5a,
    rb_se_5b,
    rb_se_4a,
    rb_se_5c,
    rb_se_5d,
    rb_se_4b,
    rb_se_3a,
    rb_se_5e,
    rb_se_5f,
    rb_se_4c,
    rb_se_4d,
    rb_se_4e,
    rb_se_3b,
    rb_se_2a,
    rb_se_3c,
    rb_se_3d,
    rb_se_3e,
    rb_se_2b,
    rb_se_1
  )


fpm_se_1 <-
  
  predict(
    rbs_se_1,
    newdata = df_irm_i2,
    se_3c = fp_se_3c,
    se_3d = fp_se_3d,
    se_3e = fp_se_3e,
    se_4d = fp_se_4d,
    se_4e = fp_se_4e,
    se_5a = fp_se_5a,
    se_5b = fp_se_5b,
    se_5c = fp_se_5c,
    se_5d = fp_se_5d,
    se_5e = fp_se_5e,
    se_5f = fp_se_5f
  )


# write the membership values to df_irm_i2 and plot the maps of the conclusions

df_criteria_se1 <-
  subset(df_priorities, grepl("^se_1", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse1 <- nrow(df_criteria_se1)

h_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se1[1, 3]))$high)
df_irm_i2 <-
  mutate(df_irm_i2,!!as.character(paste0(df_criteria_se1[1, 3], "_h")) := h_col, .keep = c("all"))




if (fpf_rb == "hml") {
  # there is a moderate conclusion to fp feasibility giving up to nine rules and conclusions
  
  if (ma_rb == "gmp") {
    # there is a moderate conclusion to fp feasibility and market access giving nine rules and conclusions
    sef_rule_num <- 9
    
    if (sef_conclusion2 == "moderate" |
        sef_conclusion3 == "moderate" |
        sef_conclusion4 == "moderate" |
        sef_conclusion5 == "moderate" |
        sef_conclusion6 == "moderate" |
        sef_conclusion7 == "moderate" |
        sef_conclusion8 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se1[1, 3]))$moderate)
      df_irm_i2 <-
        mutate(df_irm_i2,!!as.character(paste0(df_criteria_se1[1, 3], "_m")) := m_col, .keep = c("all"))
      
      sef_rb <- "hml"
    }
    
  } else {
    # there is a no moderate conclusion to market access giving  six rules and conclusions
    
    sef_rule_num <- 6
    
    if (sef_conclusion2 == "moderate" |
        sef_conclusion3 == "moderate" |
        sef_conclusion7 == "moderate" |
        sef_conclusion8 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se1[1, 3]))$moderate)
      df_irm_i2 <-
        mutate(df_irm_i2,!!as.character(paste0(df_criteria_se1[1, 3], "_m")) := m_col, .keep = c("all"))
      
      sef_rb <- "hml"
    }
  }
} else {
  # there is a no moderate conclusion to fp feasibility giving  six rules and conclusions
  
  if (ma_rb == "gmp") {
    #there is a moderate conclusion to market access giving up to six rules and conclusions
    
    sef_rule_num <- 6
    
    if (sef_conclusion3 == "moderate" |
        sef_conclusion4 == "moderate" |
        sef_conclusion6 == "moderate" |
        sef_conclusion7 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se1[1, 3]))$moderate)
      df_irm_i2 <-
        mutate(df_irm_i2,!!as.character(paste0(df_criteria_se1[1, 3], "_m")) := m_col, .keep = c("all"))
      
      sef_rb <- "hml"
    }
  }  else {
    #there is no moderate conclusion to fp feasibility or market access giving four rules and conclusions
    
    sef_rule_num <- 4
    
    if (sef_conclusion3 == "moderate" |
        sef_conclusion7 == "moderate") {
      m_col <- getMembership(get(paste0("fpm_",
                                        df_criteria_se1[1, 3]))$moderate)
      df_irm_i2 <-
        mutate(df_irm_i2,!!as.character(paste0(df_criteria_se1[1, 3], "_m")) := m_col, .keep = c("all"))
      
      sef_rb <- "hml"
    }
  }
}

l_col <- getMembership(get(paste0("fpm_",
                                  df_criteria_se1[1, 3]))$low)
df_irm_i2 <-
  mutate(df_irm_i2,!!as.character(paste0(df_criteria_se1[1, 3], "_l")) := l_col, .keep = c("all"))


if (sef_rb == "hml") {
  n = 3
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se1[1, 3], "_h")),
      as.character(paste0(df_criteria_se1[1, 3], "_m")),
      as.character(paste0(df_criteria_se1[1, 3], "_l")),
      "x" ,
      "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se1[1, 4], " high")),
      as.character(paste0(df_criteria_se1[1, 4], " moderate")),
      as.character(paste0(df_criteria_se1[1, 4], " low")))
} else {
  n = 2
  fpm_conc_var <-
    c(as.character(paste0(df_criteria_se1[1, 3], "_h")),  as.character(paste0(df_criteria_se1[1, 3], "_l")), "x" , "y")
  fpm_conc_name <-
    c(as.character(paste0(df_criteria_se1[1, 4], " high")),  as.character(paste0(df_criteria_se1[1, 4], " low")))
  
}
fpm_plot_title <-
  "Socio-Economic\nFeasibility\noptimality\nmembership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
print(plot_fpm)

``` 
</div>


```{r i2_rulebases_sef_score01, echo=FALSE, results='asis', eval=sef_crit, eval=adop_crit}

cat("To combine with the biophysical aptitude we will convert the Socio-Economic Feasibility values to optimal and suboptimal scores between 1 and 0.

*Optimal*
High feasibility has a value of 1.
Moderate feasibility has a value of 0.5.
Low feasibility has a value of 0.

*Sub-Optimal*
High feasibility has a value of 0.
Moderate feasibility has a value of 0.5.
Low feasibility has a value of 1.

For example the following feasibility values would give these scores:

High | Moderate | Low |  optimal | suboptimal
---|---|---|---|---|---
0.9 | 0.1 | 0 | 0.95 | 0.05
0.6| 0.2 | 0.2 |  0.7 | 0.3
0.3| 0.3 | 0.4|  0.45 | 0.55
0.2 | 0.3 | 0.5 | 0.35 | 0.65
")

```

<div class="fold o">
```{r i2_rulebases_sef_score02, echo=FALSE, results='asis', eval=sef_crit, eval=adop_crit}

if ("se_1_m" %in% colnames(df_irm_i2)) {
  # calculate scores when moderate sef conclusion exists
  
  df_irm_i2 <-
    mutate(df_irm_i2, se_1_o := (se_1_h + (se_1_m / 2)), .keep = c("all"))
  df_irm_i2 <-
    mutate(df_irm_i2, se_1_s := (se_1_l + (se_1_m / 2)), .keep = c("all"))
}   else {
  # calculate scores when moderate sef conclusion does not exist
  df_irm_i2 <-
    mutate(df_irm_i2, se_1_o := (se_1_h), .keep = c("all"))
  df_irm_i2 <-
    mutate(df_irm_i2, se_1_s := (se_1_l), .keep = c("all"))
}

```
</div>



```{r i2_rulebases_se_export01, echo=FALSE, results='asis', eval=sef_crit}

cat("## Export feasibility results

")
```

<div class="fold o">
```{r i2_rulebases_se_export02, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, warning=FALSE, eval=sef_crit}

vect_se <- vect(df_irm_i2, geom = c("x", "y"), crs = wkt_lam)
output_vect(vect_se, paste0("sf_", params$INN2))

``` 
</div>

```{r i2_rulebases_adoption01, echo=FALSE, results='asis', eval=adop_crit}

cat("### Likelihood for Adoption - three class

Likelihood for Adoption rule base (0) combines propositions for biophysical aptitude (rule base ba_1) and socio-economic feasibility (rule base se_1).

")

```

<div class="fold o"> 
```{r i2_rulebases_adoption02, results='asis', warning=FALSE, eval=adop_crit}

# Each innovation has potentially different criteria and rule bases

# In this chunk we need to know which data to load for the criteria

df_criteria_0 <-
  subset(df_priorities, grepl("^adop_0", df_priorities$rulebase_stack)) # use regular expressions to find criteria
n_c0 <- nrow(df_criteria_0)

# then determine and print the names of the rule bases in the Likelihood of Adoption theme

cat(paste("\n\n", n_c0, "Likelihood of Adoption rule bases:"))
for (i in 1:n_c0) {
  cat(paste0(
    "\n",
    df_criteria_0[i, 3],
    " (",
    df_criteria_0[i, 4],
    "):\n Weight = ",
    as.character(df_criteria_0[i, 5]),
    "\n"
  ))
}

```
</div>

```{r i2_rulebases_adoption03, echo=FALSE, results='asis', eval=adop_crit}

cat("Rule base ba_1 has the following conclusions:")

```

```{r i2_rulebases_adoption04, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=adop_crit}

cat(paste("Rule base ba_1 has the following conclusions:"))

ba_conc_list <-
  c("optimal",
    "suboptimal")
cat(paste("\n Biophysical Aptitude is", sort(unique(ba_conc_list))))

```

```{r i2_rulebases_adoption05, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, results='asis', eval=adop_crit}

if (sef_rule_num == 9) {
  cat(paste("Rule base se_1 has the following conclusions:"))
  
  sef_conc_list <-
    c(
      sef_conclusion1,
      sef_conclusion2,
      sef_conclusion3,
      sef_conclusion4,
      sef_conclusion5,
      sef_conclusion6,
      sef_conclusion7,
      sef_conclusion8,
      sef_conclusion9
    )
} else  if (sef_rule_num == 6) {
  cat(paste("Rule base se_1 has the following conclusions:"))
  
  if (fpf_rb == "hml") {
    sef_conc_list <-
      c(
        sef_conclusion1,
        sef_conclusion2,
        sef_conclusion3,
        sef_conclusion7,
        sef_conclusion8,
        sef_conclusion9
      )
  } else  {
    sef_conc_list <-
      c(
        sef_conclusion1,
        sef_conclusion3,
        sef_conclusion4,
        sef_conclusion6,
        sef_conclusion7,
        sef_conclusion9
      )
  }
} else  {
  cat(paste("Rule base se_1 has the following conclusions:"))
  
  sef_conc_list <-
    c(sef_conclusion1,
      sef_conclusion3,
      sef_conclusion7,
      sef_conclusion9)
}

cat(paste("\n Socio-Economic Feasibility is", sort(unique(sef_conc_list))))

```

```{r i2_rulebases_adoption06, echo=FALSE, results='asis', eval=adop_crit}

cat("Likelihood for Adoption rule base has six possible rules and three possible outcomes: low, moderate and high likelihood for adoption

Rule 1: If Biophysical Aptitude is optimal and Socio-Economic Feasibility is high then Suitability is high
Rule 2: If Biophysical Aptitude is optimal and Socio-Economic Feasibility is moderate then Suitability is moderate or high
Rule 3: If Biophysical Aptitude is optimal and Socio-Economic Feasibility is low then Suitability is low, moderate or high
Rule 4: If Biophysical Aptitude is suboptimal and Socio-Economic Feasibility is high then Suitability is low, moderate or good
Rule 5: If Biophysical Aptitude is suboptimal and Socio-Economic Feasibility is moderate then Suitability is low or moderate
Rule 6: If Biophysical Aptitude is suboptimal and Socio-Economic Feasibility is low then Suitability is low


Using the weights assigned by AHP the outcomes are the following:")

```


```{r i2_rulebases_adoption07, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=adop_crit}



df_criteria_ba1 <-
  subset(df_priorities, grepl("^ba_1", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cba1 <- nrow(df_criteria_ba1)

df_criteria_se1 <-
  subset(df_priorities, grepl("^se_1", df_priorities$rulebase_number)) # use regular expressions to find criteria
n_cse1 <- nrow(df_criteria_se1)


#Rule 2: If ba is suboptimal and se is high
rule2 <-
  -df_criteria_ba1$weight[1] + df_criteria_se1$weight[1]

#Rule 3: If ba is optimal and se is moderate
rule3  <-
  df_criteria_ba1$weight[1]

#Rule 4: If ba is suboptimal and se is moderate
rule4  <-
  -df_criteria_ba1$weight[1]

#Rule 5: If ba is optimal and se is low
rule5  <-
  df_criteria_ba1$weight[1] - df_criteria_se1$weight[1]


rm(df_conc) # remove previous instances of df_conc
rm(df_prop) # remove previous instances of df_prop

#Rule 1: then adoption likelihood is high

adop_conclusion1 = "high" # always high
cat(paste("rule 1 = ", adop_conclusion1))
cat("\n")

# create table of conclusions
df_prop <-
  tibble(ba_1 = "optimal",
         se_1 = "high")
df_conc <- tibble(adop_0 = adop_conclusion1)



#Rule 2: then adoption likelihood is low, moderate or high

if (rule2 >= 0.33)  {
  adop_conclusion2 = "high"
}     else if (rule2 > -0.33) {
  adop_conclusion2 = "moderate"
} else {
  adop_conclusion2 = "low"
}

cat(paste("rule 2 = ", adop_conclusion2))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, adop_0 = adop_conclusion2)
df_prop <-
  add_row(df_prop,
          ba_1 = "suboptimal",
          se_1 = "high")


#Rule 3: then adoption likelihood is moderate or high
if (sef_rb == "hml") {
  # rule 3 only activated when sef is moderate
  
  if (rule3 >= 0.33)  {
    adop_conclusion3 = "high"
  }     else if (rule3 > -0.33) {
    adop_conclusion3 = "moderate"
  } else {
    adop_conclusion3 = "low"
  }
  cat(paste("rule 3 = ", adop_conclusion3))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, adop_0 = adop_conclusion3)
  df_prop <-
    add_row(df_prop,
            ba_1 = "optimal",
            se_1 = "moderate")
} else {
  cat(paste("No rule 3"))
  cat("\n")
}



#Rule 4: then adoption likelihood is moderate or low
if (sef_rb == "hml") {
  # rule 4 only activated when sef is moderate
  
  if (rule4 >= 0.33)  {
    adop_conclusion4 = "high"
  }     else if (rule4 > -0.33) {
    adop_conclusion4 = "moderate"
  } else {
    adop_conclusion4 = "low"
  }
  cat(paste("rule 4 = ", adop_conclusion4))
  cat("\n")
  # add to table of conclusions
  df_conc <- add_row(df_conc, adop_0 = adop_conclusion4)
  df_prop <-
    add_row(df_prop,
            ba_1 = "suboptimal",
            se_1 = "moderate")
} else {
  cat(paste("No rule 4"))
  cat("\n")
}


#Rule 5: then adoption likelihood is low, moderate or high

if (rule5 >= 0.33)  {
  adop_conclusion5 = "high"
}     else if (rule5 > -0.33) {
  adop_conclusion5 = "moderate"
} else {
  adop_conclusion5 = "low"
}

cat(paste("rule 5 = ", adop_conclusion5))
cat("\n")
# add to table of conclusions
df_conc <- add_row(df_conc, adop_0 = adop_conclusion5)
df_prop <-
  add_row(df_prop,
          ba_1 = "optimal",
          se_1 = "low")


#Rule 6: then adoption likelihood is low

adop_conclusion6 = "low" # always low
cat(paste("rule 6 = ", adop_conclusion6))
cat("\n")

# add to table of conclusions
df_conc <- add_row(df_conc, adop_0 = adop_conclusion6)
df_prop <-
  add_row(df_prop,
          ba_1 = "suboptimal",
          se_1 = "low")

```

```{r i2_rulebases_adoption08, echo=FALSE, results='asis', eval=adop_crit}

cat("This gives the rule base:")

```

<div class="fold o"> 
```{r i2_rulebases_adoption09, cache = TRUE, cache.whatever=params$Agg, results='asis', warning=FALSE, eval=adop_crit}

# new proposition object is made here
prop <- new("Proposition", table = df_prop)
tbl_prop_cross <- prop@table
n_prop <- ncol(tbl_prop_cross)


# new conclusion object is made here

conc <- new("Conclusion", table = df_conc)

# create a rule base
rb_adop_0 <- RuleBase(prop, conc) %>% print()


# in this section there are normally two criteria - b aptitude and se feasibility

# biophysical aptitude is based on five criteria and has a rb (ba_1) and includes Land Use Aptitude, Climatic Aptitude, Soil Physical Properties Aptitude, Soil Fertility Aptitude, Landscape Aptitude (ba_2a, ba_2b, ba_2c, ba_2d, ba_2e)





# se feasibility is based on two criteria and has a rb (se_1) and includes fp feasibility and market access and their two rb (se_2a & se2b).

# fp feasibility is based on two criteria and has a rb (se_2a) and includes management and inputs and their two rb (se_3a & se3b).
# management is based on two criteria: extension and labour their two rb (se_4a & se4b).
# Extension includes two further criteria with rule bases (se_5a & se_5b) each with fuzzy partitions.
# Access to labour is based on two criteria and their two rb (se_5c & se5d) each with fuzzy partitions.

# farm inputs is based on three criteria: access to seeds and land and their two rb (se_4d & se4e) each with fuzzy partitions.
# Access to fertilisers and pesticides has a rb (se_4c) and includes two criteria and their two rb (se_5e & se5f) each with fuzzy partitions.

# market access has a rb (se_2b) and includes three criteria and their three rb (se_3c, se_3d & se3e) each with fuzzy partitions.

# there are eleven fp in total (se_3c, se_3d, se3e, se_4d, se_4e, se_5a, se_5b, se_5c, se5d, se_5e and se_5f)

x <-
  paste(
    "stack(",
    gsub(",$", "", paste0(
      get("rbs_ba_1_list"), sep = ",", collapse = ""
    )),
    ",rb_se_5a,rb_se_5b,rb_se_4a,rb_se_5c,rb_se_5d,rb_se_4b,rb_se_3a,rb_se_5e,rb_se_5f,rb_se_4c,rb_se_4d,rb_se_4e,rb_se_3b,rb_se_2a,rb_se_3c,rb_se_3d,rb_se_3e,rb_se_2b,rb_se_1,rb_adop_0)"
  )

fp_adop_0_list <-
  append(
    fp_ba_1_list,
    "se_3c = fp_se_3c,se_3d = fp_se_3d,se_3e = fp_se_3e,se_4d = fp_se_4d,se_4e = fp_se_4e,se_5a = fp_se_5a,se_5b = fp_se_5b,se_5c = fp_se_5c,se_5d = fp_se_5d,se_5e = fp_se_5e,se_5f = fp_se_5f"
  )


rbs_tmp <-  assign(paste0("rbs_adop_0"), eval(parse(text = x)))

# evaluate the rule base stack

w <-
  paste("predict(",
        "rbs_tmp, newdata = df_irm_i2,",
        gsub(",$", "", paste0(
          get(paste0("fp_adop_0_list")), sep = ",", collapse = ""
        )),
        ")")

fpm_adop_0 <- eval(parse(text = w))


# write the membership values to df_irm_i2 and plot the maps of the conclusions

h_col <- getMembership(fpm_adop_0$high)

# add column only if column doesn't already exist in df_irm_i2

if ("adop_0_h" %in% colnames(df_irm_i2)) {
  df_irm_i2 <- df_irm_i2  %>% dplyr::select(-(adop_0_h))
  df_irm_i2 <- mutate(df_irm_i2, adop_0_h := h_col, .keep = c("all"))
}   else {
  df_irm_i2 <- mutate(df_irm_i2, adop_0_h := h_col, .keep = c("all"))
}

if (sef_rb == "hml") {
  # there is a moderate conclusion to se feasibility giving up to six rules and conclusions
  adop_rule_num <- 6
  
  if (adop_conclusion2 == "moderate" |
      adop_conclusion3 == "moderate" |
      adop_conclusion4 == "moderate" |
      adop_conclusion5 == "moderate") {
    m_col <- getMembership(fpm_adop_0$moderate)
    
    # add column only if column doesn't already exist in df_irm_i2
    
    if ("adop_0_m" %in% colnames(df_irm_i2)) {
      df_irm_i2 <- df_irm_i2  %>% dplyr::select(-(adop_0_m))
      df_irm_i2 <- mutate(df_irm_i2, adop_0_m := m_col, .keep = c("all"))
    }   else {
      df_irm_i2 <- mutate(df_irm_i2, adop_0_m := m_col, .keep = c("all"))
    }
    
    adop_rb <- "hml"
  }
  
} else {
  # there is a no moderate conclusion to se feasibility access giving four rules and conclusions
  
  adop_rule_num <- 4
  
  if (adop_conclusion2 == "moderate" |
      adop_conclusion3 == "moderate") {
    m_col <- getMembership(fpm_adop_0$moderate)
    
    # add column only if column doesn't already exist in df_irm_i2
    
    if ("adop_0_m" %in% colnames(df_irm_i2)) {
      df_irm_i2 <- df_irm_i2  %>% dplyr::select(-(adop_0_m))
      df_irm_i2 <- mutate(df_irm_i2, adop_0_m := m_col, .keep = c("all"))
    }   else {
      df_irm_i2 <- mutate(df_irm_i2, adop_0_m := m_col, .keep = c("all"))
    }
    
    adop_rb <- "hml"
  }
}

l_col <- getMembership(fpm_adop_0$low)

# add column only if column doesn't already exist in df_irm_i2

if ("adop_0_l" %in% colnames(df_irm_i2)) {
  df_irm_i2 <- df_irm_i2  %>% dplyr::select(-(adop_0_l))
  df_irm_i2 <- mutate(df_irm_i2, adop_0_l := l_col, .keep = c("all"))
}   else {
  df_irm_i2 <- mutate(df_irm_i2, adop_0_l := l_col, .keep = c("all"))
}

adop_rb <- "hml"


if (adop_rb == "hml") {
  n = 3
  fpm_conc_var <-
    c(
      as.character("adop_0_h"),
      as.character("adop_0_m"),
      as.character("adop_0_l"),
      "x" ,
      "y"
    )
  fpm_conc_name <-
    c(
      as.character("Adoption likelihood high"),
      as.character("Adoption likelihood moderate"),
      as.character("Adoption likelihood low")
    )
} else {
  n = 2
  fpm_conc_var <-
    c(as.character("adop_0_h"),
      as.character("adop_0_l"),
      "x" ,
      "y")
  fpm_conc_name <-
    c(as.character("Adoption likelihood high"),
      as.character("Adoption likelihood low"))
  
}
fpm_plot_title <-
  "Adoption\nLikelihood\n3-class\nmembership"

plot_fpm <- rasterize_plot_fpm(n, fpm_conc_var, fpm_conc_name, df_irm_i2)
print(plot_fpm)

``` 
</div>



```{r i2_rulebases_adop_export01, echo=FALSE, results='asis', eval=adop_crit}

cat("## Export likelihood for adoption results

")
```

<div class="fold o">
```{r i2_rulebases_adop_export02, cache = TRUE, cache.whatever=params$Agg, cache.whatever=params$Agg, warning=FALSE, eval=adop_crit}

vect_adop <- vect(df_irm_i2, geom = c("x", "y"), crs = wkt_lam)
output_vect(vect_adop, paste0("adop_", params$INN2))

``` 
</div>

# Classified Results and Validation

The maps below give the classified adoption map, _i.e._, for each raster cell only the class with the maximum membership value is given.



```{r i2_classified_adop_membership_maps01, echo=FALSE, results='asis', eval=adop_crit}

cat("## Classified Map of Likelihood for Adoption")

```

The first map is _without_, the second map  _with_ triangulation points. These points are either high or low, as indicated by the symbols + and - respectively. The colour of the circles behind these symbols refers to the type of adoption, _i.e._, biophysical (b) and/or socio-economic (s). These classes are constructed from the table below:

<div class="fold o"> 
```{r i2_classified_adop_membership_maps02 , cache = TRUE, cache.whatever=params$Agg, warning=FALSE, timeit = TRUE, eval=adop_crit}
# idem + overlay triangulation adoption points

vect_adop_tri <- vect_triangulation %>%
    mutate(
        adopclass = ifelse(grepl(pattern = "high", x = Adoption, ignore.case = TRUE), "high", ifelse(grepl(pattern = "moderate", x = Adoption, ignore.case = TRUE), "moderate", "low")),
        type = NA
    ) %>%
    dplyr::filter(!is.na(Adoption))


vect_adop_tri$type[grepl(pattern = " AE", x = vect_adop_tri$Adoption, ignore.case = TRUE)] <- "b"
vect_adop_tri$type[grepl(pattern = " EA", x = vect_adop_tri$Adoption, ignore.case = TRUE)] <- "b"
vect_adop_tri$type[grepl(pattern = "bio", x = vect_adop_tri$Adoption, ignore.case = TRUE)] <- "b"
vect_adop_tri$type[grepl(pattern = "SE", x = vect_adop_tri$Adoption, ignore.case = TRUE)] <- "s"
vect_adop_tri$type[grepl(pattern = "soil", x = vect_adop_tri$Adoption, ignore.case = TRUE)] <- "b"
vect_adop_tri$type[grepl(pattern = "lowland", x = vect_adop_tri$Adoption, ignore.case = TRUE)] <- "b"
vect_adop_tri$type[grepl(pattern = " temp", x = vect_adop_tri$Adoption, ignore.case = TRUE)] <- "b"
vect_adop_tri$type[grepl(pattern = " elevation", x = vect_adop_tri$Adoption, ignore.case = TRUE)] <- "b"
vect_adop_tri$type[grepl(pattern = "market", x = vect_adop_tri$Adoption, ignore.case = TRUE)] <- "s"
vect_adop_tri$type[grepl(pattern = "rain", x = vect_adop_tri$Adoption, ignore.case = TRUE)] <- "b"
vect_adop_tri$type[grepl(pattern = "SPAM presence", x = vect_adop_tri$Adoption, ignore.case = TRUE)] <- "b"


vect_adop_tri %>%
    dplyr::select(Adoption, adopclass, type) %>%
    (knitr::kable) %>% kable_styling("striped", full_width = F) %>% scroll_box(height = "300px")
``` 
</div>

```{r i2_classified_adop_membership_maps03, echo=FALSE, results='asis', eval=adop_crit}

cat("### Likelihood for Adoption - two or three classes")

```

<div class="fold o"> 
```{r i2_classified_adop_membership_maps04 , cache = TRUE, cache.whatever=params$Agg,  out.width="100%", message=FALSE, warning=FALSE, timeit = TRUE, eval=adop_crit}
# create classified adoption map 

if (params$RES2 != 2) {
  # new method because of df_irm_i2 dropped no data
  
  if (adop_rb == "hml") {
    vect_adop_3class <-
      df_irm_i2 %>% dplyr::select(adop_0_h, adop_0_m, adop_0_l, x , y) %>% na.omit %>% vect(geom = c("x", "y"))
    rast_adop_3class_h <- rasterize(vect_adop_3class, rast_mask_proj, field = "adop_0_h")
    rast_adop_3class_m <- rasterize(vect_adop_3class, rast_mask_proj, field = "adop_0_m")
    rast_adop_3class_l <- rasterize(vect_adop_3class, rast_mask_proj, field = "adop_0_l")
    rast_adop_3class <- rast(list(rast_adop_3class_h, rast_adop_3class_m, rast_adop_3class_l))
    names(rast_adop_3class) <- c('high', 'moderate', 'low')
    
    # get max value and export
    rast_adop_3class_max <- which.max(rast_adop_3class)
    rast_adop_3class_brick <- rast(list(rast_adop_3class_h, rast_adop_3class_m, rast_adop_3class_l, rast_adop_3class_max))
    names(rast_adop_3class_brick) <- c('high', 'moderate', 'low', 'class')
    output_geotiff(rast_adop_3class_brick, paste0("3class_adop0_", params$INN2))
    
  } else {
    vect_adop_3class <-
      df_irm_i2 %>% dplyr::select(adop_h, adop_l, x , y) %>% na.omit %>% vect(geom = c("x", "y"))
    rast_adop_3class_h <- rasterize(vect_adop_3class, rast_mask_proj, field = "adop_0_h")
    rast_adop_3class_l <- rasterize(vect_adop_3class, rast_mask_proj, field = "adop_0_l")
    rast_adop_3class <- rast(list(rast_adop_3class_h, rast_adop_3class_l))
    names(rast_adop_3class) <- c('high', 'low')
    
    # get max value and export
    rast_adop_3class_max <- which.max(rast_adop_3class)
    rast_adop_3class_brick <- rast(list(rast_adop_3class_h, rast_adop_3class_l, rast_adop_3class_max))
    names(rast_adop_3class_brick) <- c('high', 'low', 'class')
    output_geotiff(rast_adop_3class_brick, paste0("3class_adop0_", params$INN2))
    
  }

  df_adop_3class <- rast_adop_3class %>%
    as.data.frame(xy = TRUE) %>%
    na.omit
  m <- df_adop_3class %>% dplyr::select(-x,-y)
  
  df_adop_3class$class <- names(m)[apply(X = m, MARGIN = 1, FUN = which.max)]
  df_adop_3class$class <-
    factor(df_adop_3class$class,
           levels = c("low", "moderate", "high"),
           ordered = TRUE)
  
  g <- ggplot(data = df_adop_3class) +
    geom_raster(mapping = aes(x = x, y = y, fill = class)) +
#    scale_x_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
#    scale_y_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
    scale_fill_manual(
      name = paste0("Likelihood\nfor Adoption\n", params$INN2),
      values = c(
        high = rgb(0, 158, 115, maxColorValue = 255),
        low  = rgb(213,  94,   0, maxColorValue = 255),
        moderate = rgb(230, 159, 0, maxColorValue = 255)
      ),
      drop = FALSE
    ) +
    coord_sf()
  
g2 <- add_subdiv_proj_simple_plot(g)
g2  
} # end RES if statement 08/12/2019

``` 
</div>

<div class="fold o"> 
```{r i2_classified_adop_membership_maps05 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, message  = FALSE, timeit = TRUE, eval=adop_crit}
# create classified adoption map and validation
# 01/03/2019 A FARROW this chunk split because map not appearing

if (params$RES2 != 2) {
  
g2 + 
    geom_spatvector(
        data = vect_adop_tri, 
        mapping = aes(colour = ifelse(adopclass == "high" , "green", "red")), 
        size = 2
    ) +
    geom_spatvector_text(
        data = vect_adop_tri, 
        mapping = aes(label = ifelse(type == "b", "b", "b/s"))
    ) + 
  scale_colour_identity() 

} # end RES if statement 08/12/2019

``` 
</div>

```{r i2_classified_adop_membership_maps06, echo=FALSE, results='asis', eval=adop_crit}

cat("#### Likelihood for Adoption - three classes Leaflet")

```

<div class="fold o"> 
```{r i2_classified_adop_membership_maps07 , cache = TRUE, cache.whatever=params$Agg, warning=FALSE, timeit = TRUE, eval=adop_crit}


if (params$RES2 != 2) {

  # get the polygons showing the layer with the max value in rast_adop_3class_max

  vect_adop_3class_max1 <- as.polygons(rast_adop_3class_max, dissolve=FALSE)

  vect_adop_3class_max1$class <- df_adop_3class$class
  
  # join the polygons with the aptitude points
  vect_adop_3class_max1[["id"]] <- 1:nrow(vect_adop_3class_max1)
  vect_adop[["id"]] <- 1:nrow(vect_adop)
  pinp_m <- relate(vect_adop_3class_max1, vect_adop, "contains", pairs=TRUE)
  df_pinp <- dplyr::as_tibble(pinp_m)
  vect_adop_3class_max2 <- merge(x = vect_adop_3class_max1, y = df_pinp, by.x = "id", by.y = "id.x", all.x = TRUE)
  vect_adop_3class_max2 <- merge(x = vect_adop_3class_max2, y = vect_adop, by.x = "id.y", by.y = "id", all.x = TRUE)
  
   # project to geo for display in leaflet
  vect_adop_3class_max2_geo <- project(vect_adop_3class_max2, "epsg:4326")
  
  # convert to sf until leaflet properly accepts spatvector
  sf_adop_3class_max2_geo <- st_as_sf(vect_adop_3class_max2_geo)
  
  adop_palette <- (c(
    rgb(0, 158, 115, maxColorValue = 255),
    #high
    rgb(230, 159, 0, maxColorValue = 255),
    #low
    rgb(213,  94,   0, maxColorValue = 255)
  )) #moderate
  
  
  pal <-
    colorFactor(adop_palette, domain = c(1:3), na.color = "#808080")
  
  leaflet_widget <- leaflet(sf_adop_3class_max2_geo, width = "100%") %>%
    addProviderTiles(providers$OpenStreetMap.HOT, group = "OSM (HOT)") %>%
    addPolygons(
      label = ~ stringr::str_c('Adoption =', class),
      labelOptions = labelOptions(direction = 'auto'),
      color = "#03F",
      weight = 1,
      opacity = 0.5,
      fill = layer,
      fillColor = ~ pal(which.max),
      fillOpacity = 0.2,
      dashArray = NULL,
      smoothFactor = 1,
      noClip = FALSE,
      popup = paste(
        'Bio Apt optimal  =',
        sf_adop_3class_max2_geo$ba_1_o,
        '<br>',
        'Bio Apt suboptimal =',
        sf_adop_3class_max2_geo$ba_1_s,
        '<br>',
        '<br>',
        'Climate suboptimal  =',
        sf_adop_3class_max2_geo$ba_2b_s,
        '<br>',
        'Soil Fertility suboptimal  =',
        sf_adop_3class_max2_geo$ba_2d_s,
        '<br>',
        'Landscape suboptimal  =',
        sf_adop_3class_max2_geo$ba_2e_s,
        '<br>',
        'Soil Physical suboptimal  =',
        sf_adop_3class_max2_geo$ba_2c_s,
        '<br>',
        'Land Use suboptimal  =',
        sf_adop_3class_max2_geo$ba_2a_s,
        '<br>',
        '<br>',
        'SE Low  =',
        sf_adop_3class_max2_geo$se_1_l,
        '<br>',
        '<br>',
        'Markets Poor  =',
        sf_adop_3class_max2_geo$se_2a_l,
        '<br>',
        'Farm production Low  =',
        sf_adop_3class_max2_geo$se_2b_p,
        '<br>',
        'Management Poor  =',
        sf_adop_3class_max2_geo$se_3a_p,
        '<br>',
        'Farm Input access Poor =',
        sf_adop_3class_max2_geo$se_3b_p
      ),
      popupOptions = NULL,
      highlightOptions = NULL,
    )
  
  frameWidget(leaflet_widget, height = '500')
  
} # end RES if statement 08/12/2019


# reached here 14/09/2023
``` 
</div>

```{r i2_classified_adop_membership_maps_fao01, echo=FALSE, results='asis', eval=adop_crit}

cat("### Classified Map of Likelihood for Adoption - FAO five classes")

```

<div class="fold o"> 
```{r i2_classified_adop_membership_maps_fao02 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, timeit = TRUE, eval=adop_crit }

if (params$RES2 != 2) {

  df_criteria_0 <-
    subset(df_priorities, grepl("^adop_0", df_priorities$rulebase_stack)) # use regular expressions to find criteria
  n_c0 <- nrow(df_criteria_0)
  
  # then determine and print the names of the rule bases in the Likelihood of Adoption theme
  
  cat(paste("\n\n", n_c0, "Likelihood of Adoption rule bases:"))
  for (i in 1:n_c0) {
    cat(paste0(
      "\n",
      df_criteria_0[i, 3],
      " (",
      df_criteria_0[i, 4],
      "):\n Weight = ",
      as.character(df_criteria_0[i, 5]),
      "\n"
    ))
  }
  # new method because of df_irm_i2 dropped no data
  
  df_adop_fao <-
    df_irm_i2 %>% dplyr::select(paste0(df_criteria_0[1,3],"_o"), paste0(df_criteria_0[2,3],"_o"), x , y) %>% na.omit 
  
  # adoption equals the weighted mean value
  
  expr_adop_fao <- parse(text = paste0("(",df_criteria_0[1,3],"_o * ", df_criteria_0[1,5],") + (", df_criteria_0[2,3],"_o * ", df_criteria_0[2,5],")"))
  
  vect_adop_fao <-
    mutate(df_adop_fao, adop_0_o := eval(expr_adop_fao), .keep = c("all"))  %>% vect(geom = c("x", "y"))
  
  
  rast_adop_fao <- rasterize(vect_adop_fao, rast_mask_proj, field = "adop_0_o")
  names(rast_adop_fao) <- c('FAO')
  
  # classify values and export
  ## from-to-becomes
  # classify the optimal values into five groups
  # all values >= 0 and <= 0.25 become N2, etc.
  m_fao <- c(-Inf, 0.25, 5,
             0.25, 0.4, 4,
             0.4, 0.6, 3,
             0.6, 0.85, 2,
             0.85, Inf, 1)
  rclmat <- matrix(m_fao, ncol = 3, byrow = TRUE)
  rast_adop_fao_bin <- classify(rast_adop_fao, rclmat, include.lowest = TRUE)
  rast_adop_fao_cat <- rast_adop_fao_bin
  df_adop_faocode <- data.frame(id = 1:5, FAO = c("S1", "S2", "S3", "N1", "N2"))
  levels(rast_adop_fao_cat) <- df_adop_faocode
  rast_adop_fao_brick <- rast(list(rast_adop_fao, rast_adop_fao_bin, rast_adop_fao_cat))
  names(rast_adop_fao_brick) <- c('optimal', 'bin', 'FAO')
  output_geotiff(rast_adop_fao_brick, paste0("1faoclass_adop0_", params$INN2))
  
  # export class and optimal value as polygon
  vect_adop_fao_cat <- as.polygons(rast_adop_fao_cat, dissolve = T)
  
  vect_filename <-
    as.character(paste("spatial_data/output/1faoclass_adop0_", params$INN2, ".shp"))
  writeVector(vect_adop_fao_cat, here(vect_filename), overwrite = TRUE)
  
  g <- ggplot() +
    geom_spatraster(data = rast_adop_fao_cat, na.rm = TRUE, aes(fill = FAO)) +
    scale_fill_manual(
    name = paste0("FAO\nAdoption\n", params$INN2),  na.value = "transparent",
    values = c(
      S1 = rgb(51, 160, 44, maxColorValue = 255),
      S2 = rgb(178, 223, 138, maxColorValue = 255),
      S3 = rgb(255, 255, 153, maxColorValue = 255),      
      N1 = rgb(255, 127, 0, maxColorValue = 255),
      N2 = rgb(227, 26, 28, maxColorValue = 255)
    ))
 
  g2 <- add_subdiv_proj_simple_plot(g)
  g2
} # end RES if statement 08/12/2019

``` 
</div>

<div class="fold o"> 
```{r i2_classified_adop_membership_maps_fao03 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, message  = FALSE, timeit = TRUE, eval=adop_crit}
# create classified suitability map and validation
# 01/03/2019 A FARROW this chunk split because map not appearing

if (params$RES2 != 2) {
  
g2 + 
    geom_spatvector(
        data = vect_adop_tri, 
        mapping = aes(colour = ifelse(adopclass == "high" , "green", "red")), 
        size = 2
    ) +
  scale_colour_identity() 

} # end RES if statement 08/12/2019

``` 
</div>

```{r i2_classified_adop_membership_maps_fao04, echo=FALSE, results='asis', eval=adop_crit}

cat("#### Classified Map of Likelihood for Adoption - FAO five classes Leaflet")

```

<div class="fold o"> 
```{r i2_classified_adop_membership_maps_fao05 , cache = TRUE, cache.whatever=params$Agg, warning=FALSE, timeit = TRUE, eval=adop_crit}

if (params$RES2 != 2) {
  
  # convert the spatraster (showing the FAO suitability classes (bin number and class name), and the optimality value) to polygons - do not dissolve
  
  vect_adop_fao_cat2 <- as.polygons(rast_adop_fao_brick, dissolve=FALSE)

  
  # join the polygons (vect_adop_fao_cat2) with the likelihood points (vect_adop_fao)
  
  vect_adop_fao_cat2[["id"]] <- 1:nrow(vect_adop_fao_cat2) # need an id field for p-in-p matrix
  vect_adop[["id"]] <- 1:nrow(vect_adop) # need an id field for p-in-p matrix
  pinp_m <- relate(vect_adop_fao_cat2, vect_adop, "contains", pairs=TRUE) # point in polygon matrix
  df_pinp <- dplyr::as_tibble(pinp_m) # point in polygon tibble
  vect_adop_fao_cat3 <- merge(x = vect_adop_fao_cat2, y = df_pinp, by.x = "id", by.y = "id.x", all.x = TRUE)
  vect_adop_fao_cat4 <- merge(x = vect_adop_fao_cat3, y = vect_adop, by.x = "id.y", by.y = "id", all.x = TRUE)
  
     # project to geo for display in leaflet
  vect_adop_fao_cat4_geo <- project(vect_adop_fao_cat4, "epsg:4326")
  
  # convert to sf until leaflet properly accepts spatvector
  sf_adop_fao_cat4_geo <- st_as_sf(vect_adop_fao_cat4_geo)
  
  
  adop_fao_palette <- (c(
    rgb(51, 160, 44, maxColorValue = 255),#S1
    rgb(178, 223, 138, maxColorValue = 255), #S2
    rgb(255, 255, 153, maxColorValue = 255), #S3
    rgb(255, 127, 0, maxColorValue = 255), #N1
    rgb(227, 26, 28, maxColorValue = 255) #N2
      )) 
  
  pal <-
    colorFactor(adop_fao_palette, domain = c(1:5), na.color = "#808080")
  
  leaflet_widget <- leaflet(sf_adop_fao_cat4_geo, width = "100%") %>%
    addProviderTiles(providers$OpenStreetMap.HOT, group = "OSM (HOT)") %>%
    addPolygons(
      label = ~ stringr::str_c('Likelihood =', FAO),
      labelOptions = labelOptions(direction = 'auto'),
      color = "#03F",
      weight = 1,
      opacity = 0.5,
      fill = T,
      fillColor = ~ pal(bin),
      fillOpacity = 0.2,
      dashArray = NULL,
      smoothFactor = 1,
      noClip = FALSE,
      popup = paste(
        'Adoption FAO Class  =',
        sf_adop_fao_cat4_geo$FAO,
        '<br>',
        '<br>',
        'Adoption optimal  =',
        sf_adop_fao_cat4_geo$optimal,
        '<br>',
        '<br>',
        'Socio-Economic optimal  =',
        sf_adop_fao_cat4_geo$se_1_o,
        '<br>',
        '<br>',
        'Biophysical optimal  =',
        sf_adop_fao_cat4_geo$ba_1_o,
        '<br>',
        '<br>',
        'Climate optimal  =',
        sf_adop_fao_cat4_geo$ba_2b_o,
        '<br>',
        'Soil Fertility optimal  =',
        sf_adop_fao_cat4_geo$ba_2d_o,
        '<br>',
        'Landscape optimal  =',
        sf_adop_fao_cat4_geo$ba_2e_o,
        '<br>',
        'Soil Physical optimal  =',
        sf_adop_fao_cat4_geo$ba_2c_o,
        '<br>',
        'Land Use optimal  =',
        sf_adop_fao_cat4_geo$ba_2a_o
      ),
      popupOptions = NULL,
      highlightOptions = NULL,
    )
  
  frameWidget(leaflet_widget, height = '500')
  
} # end RES if statement 08/12/2019

``` 
</div>


```{r i2_classified_adop_membership_maps_faolimits01, echo=FALSE, results='asis', eval=adop_crit}

cat("### Classified Map of Likelihood for Adoption - FAO limitations classes")

```

<div class="fold o"> 
```{r i2_classified_adop_membership_maps_faolimits02 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, timeit = TRUE, eval=adop_crit }

if (params$RES2 != 2) {
  df_adop_fao <-
    mutate(df_adop_fao, adop_0_o := eval(expr_adop_fao), .keep = c("all"))
  
  df_adop_fao <-
      mutate(df_adop_fao,
             FAO = cut(
               adop_0_o,
               breaks = c(-Inf, 0.25, 0.4, 0.6, 0.8, Inf),
               labels = c("N2", "N1", "S3", "S2", "S1"),
               include.lowest = TRUE
             ))
    
  df_adop_limits <-
    df_irm_i2 %>% dplyr::select(ba_2b_s, ba_2c_s, ba_2d_s, ba_2e_s, se_1_s) %>% na.omit
  df_adop_limits$limit <-
    names(df_adop_limits)[][max.col(df_adop_limits[])]
  
  df_adop_faolimits <- cbind(df_adop_fao, df_adop_limits)
  
  df_adop_faolimits <- df_adop_faolimits %>%
    mutate(
      FAO_adop_limit = case_match(
        limit,
        "ba_2b_s" ~ "Cl",
        "ba_2c_s" ~ "SP",
        "ba_2d_s" ~ "SF",
        "ba_2e_s" ~ "Ls",
        "se_1_s" ~ "SE",
        .default = "missing"
      ),
      .keep = "all"
    )
  
  df_adop_faolimits <- df_adop_faolimits %>%
    mutate(FAO_adop_limit2 = case_when(FAO == "S1" ~ "S1", .default = paste0(FAO, "_", FAO_adop_limit)))
  
  df_adop_faolimits_values  <-  df_adop_faolimits %>% select(FAO_adop_limit2) %>% unique()
  df_adop_faolimits_values  <- df_adop_faolimits_values[order(df_adop_faolimits_values$FAO_adop_limit2), ] %>% data.frame
  names(df_adop_faolimits_values) <- c('FAO_adop_limit_code')
  
  df_adop_faolimits_values  <- mutate(df_adop_faolimits_values, ID = row_number()-1)
  df_adop_faolimits_values  <- df_adop_faolimits_values[, c(2,1)] # re-order for later use as raster categories
  
  df_adop_faolimits_code <-
    data.frame(
      "FAO_code_num" = c(1:21),
      "FAO_code_char" = c(
        'S1',
        'S2_SE',
        'S2_Cl',
        'S2_Ls',
        'S2_SF',
        'S2_SP',
        'S3_SE',
        'S3_Cl',
        'S3_Ls',
        'S3_SF',
        'S3_SP',
        'N1_SE',
        'N1_Cl',
        'N1_Ls',
        'N1_SF',
        'N1_SP',
        'N2_SE',
        'N2_Cl',
        'N2_Ls',
        'N2_SF',
        'N2_SP'
      )
    )
  
  vect_adop_faolimits  <- vect(df_adop_faolimits, geom = c("x", "y"))
    
  rast_adop_faolimits <- rasterize(vect_adop_faolimits, rast_mask_proj, field = "FAO_adop_limit2")
  names(rast_adop_faolimits) <- c('FAO_adop_limit_code')
  levels(rast_adop_faolimits) <- df_adop_faolimits_values
  
  vect_adop_faolimits <-    merge(
    x = vect_adop_faolimits,
    y = df_adop_faolimits_code,
    by.x = "FAO_adop_limit2",
    by.y = "FAO_code_char",
    all.x = TRUE
  )
  
  rast_adop_faolimits_bin <-
    rasterize(vect_adop_faolimits, rast_mask_proj, field = "FAO_code_num")
  
  rast_adop_0_o <-
    rasterize(vect_adop_faolimits, rast_mask_proj, field = "adop_0_o")
  
  rast_adop_faolimits_brick <- rast(list(rast_adop_0_o, rast_adop_faolimits,rast_adop_faolimits_bin))
  
  names(rast_adop_faolimits_brick) <- c('optimal', 'FAO_adop_limits', 'bin')
  output_geotiff(rast_adop_faolimits_brick, paste0("FAO_adop_limits_adop0_", params$INN2))
  
  # export class and optimal value as polygon
  vect_adop_faolimits_cat <- as.polygons(rast_adop_faolimits_brick, dissolve = T)
  
  vect_filename <-
    as.character(paste("spatial_data/output/FAO_adop_limits_adop0_", params$INN2, ".shp"))
  writeVector(vect_adop_faolimits_cat, here(vect_filename), overwrite = TRUE)
  
  g <- ggplot() +
    geom_spatraster(data = rast_adop_faolimits, na.rm = TRUE, aes(fill = FAO_adop_limit_code)) +
    scale_fill_manual(
    name = paste0("FAO\nlimitations\nAdoption\n", params$INN2),  na.value = "transparent",
        breaks = c('S1','S2_SE','S2_Cl','S2_Ls','S2_SF','S3_SE','S2_SP','S3_Cl','S3_Ls','S3_SF',
      'S3_SP','N1_SE','N1_Cl','N1_Ls','N1_SF','N1_SP','N2_SE','N2_Cl','N2_Ls','N2_SF','N2_SP'),
    values = c(
      S1 = rgb(0,102,0, maxColorValue = 255),
      S2_SE = rgb(150,255,127, maxColorValue = 255),
      S2_Cl = rgb(24,252,0, maxColorValue = 255),
      S2_Ls = rgb(60,179,113, maxColorValue = 255),
      S2_SF = rgb(50,205,50, maxColorValue = 255),
      S2_SP = rgb(34,139,34, maxColorValue = 255),
      S3_SE = rgb(255, 255, 0, maxColorValue = 255),
      S3_Cl = rgb(245, 206, 51, maxColorValue = 255),
      S3_Ls = rgb(247, 218, 102, maxColorValue = 255),
      S3_SF = rgb(250, 231, 153, maxColorValue = 255),
      S3_SP = rgb(252, 243, 204, maxColorValue = 255),
      N1_SE = rgb(255, 79, 0, maxColorValue = 255),
      N1_Cl = rgb(255, 127, 0, maxColorValue = 255),
      N1_Ls = rgb(255, 168, 54, maxColorValue = 255),
      N1_SF = rgb(255, 87, 40, maxColorValue = 255),
      N1_SP = rgb(255, 187, 60, maxColorValue = 255),
      N2_SE = rgb(124, 10, 2, maxColorValue = 255),
      N2_Cl = rgb(234, 60, 83, maxColorValue = 255),
      N2_Ls = rgb(180, 55, 87, maxColorValue = 255),
      N2_SF = rgb(66, 13, 9, maxColorValue = 255),
      N2_SP = rgb(240, 128, 128, maxColorValue = 255)
    ))
 
  g2 <- add_subdiv_proj_simple_plot(g)
  g2
} # end RES if statement 08/12/2019

``` 
</div>

<div class="fold o"> 
```{r i2_classified_adop_membership_maps_faolimits03 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, message  = FALSE, timeit = TRUE, eval=adop_crit}
# create classified suitability map and validation
# 01/03/2019 A FARROW this chunk split because map not appearing

if (params$RES2 != 2) {
  
g2 + 
    geom_spatvector(
        data = vect_adop_tri, 
        mapping = aes(colour = ifelse(adopclass == "high" , "green", "red")), 
        size = 2
    ) +
  scale_colour_identity() 

} # end RES if statement 08/12/2019

``` 
</div>

```{r i2_classified_adop_membership_maps_faolimits04, echo=FALSE, results='asis', eval=adop_crit}

cat("#### Classified Map of Likelihood for Adoption - FAO limitations classes Leaflet")

```

<div class="fold o"> 
```{r i2_classified_adop_membership_maps_faolimits05 , cache = TRUE, cache.whatever=params$Agg, warning=FALSE, timeit = TRUE, eval=adop_crit}

if (params$RES2 != 2) {
  
  # convert the spatraster (showing the FAO suitability classes (bin number and class name), and the optimality value) to polygons - do not dissolve
  
  vect_adop_faolimits_cat2 <- as.polygons(rast_adop_faolimits_brick, dissolve=FALSE)

  
  # join the polygons (vect_adop_faolimits_cat2) with the likelihood points (vect_adop_faolimits)
  
  vect_adop_faolimits_cat2[["id"]] <- 1:nrow(vect_adop_faolimits_cat2) # need an id field for p-in-p matrix
  vect_adop[["id"]] <- 1:nrow(vect_adop) # need an id field for p-in-p matrix
  pinp_m <- relate(vect_adop_faolimits_cat2, vect_adop, "contains", pairs=TRUE) # point in polygon matrix
  df_pinp <- dplyr::as_tibble(pinp_m) # point in polygon tibble
  vect_adop_faolimits_cat3 <- merge(x = vect_adop_faolimits_cat2, y = df_pinp, by.x = "id", by.y = "id.x", all.x = TRUE)
  vect_adop_faolimits_cat4 <- merge(x = vect_adop_faolimits_cat3, y = vect_adop, by.x = "id.y", by.y = "id", all.x = TRUE)
  
     # project to geo for display in leaflet
  vect_adop_faolimits_cat4_geo <- project(vect_adop_faolimits_cat4, "epsg:4326")
  
  # convert to sf until leaflet properly accepts spatvector
  sf_adop_faolimits_cat4_geo <- st_as_sf(vect_adop_faolimits_cat4_geo)
  
  
  adop_faolimits_palette <- ( c(
      rgb(0,102,0, maxColorValue = 255),       #S1  
      rgb(150,255,127, maxColorValue = 255),   #S2_SE  
      rgb(24,252,0, maxColorValue = 255),      #S2_Cl  
      rgb(60,179,113, maxColorValue = 255),    #S2_Ls  
      rgb(50,205,50, maxColorValue = 255),     #S2_SF  
      rgb(34,139,34, maxColorValue = 255),     #S2_SP  
      rgb(255, 255, 0, maxColorValue = 255),   #S3_SE 
      rgb(245, 206, 51, maxColorValue = 255),  #S3_Cl 
      rgb(247, 218, 102, maxColorValue = 255), #S3_Ls  
      rgb(250, 231, 153, maxColorValue = 255), #S3_SF  
      rgb(252, 243, 204, maxColorValue = 255), #S3_SP  
      rgb(255, 79, 0, maxColorValue = 255),    #N1_SE  
      rgb(255, 127, 0, maxColorValue = 255),   #N1_Cl  
      rgb(255, 168, 54, maxColorValue = 255),  #N1_Ls  
      rgb(255, 87, 40, maxColorValue = 255),   #N1_SF  
      rgb(255, 187, 60, maxColorValue = 255),  #N1_SP 
      rgb(124, 10, 2, maxColorValue = 255),    #N2_SE  
      rgb(234, 60, 83, maxColorValue = 255),   #N2_Cl  
      rgb(180, 55, 87, maxColorValue = 255),   #N2_Ls  
      rgb(66, 13, 9, maxColorValue = 255),     #N2_SF  
      rgb(240, 128, 128, maxColorValue = 255)  #N2_SP  
    )) 

  pal <-
    colorFactor(adop_faolimits_palette, domain = c(1:21), na.color = "#808080")
  
  leaflet_widget <- leaflet(sf_adop_faolimits_cat4_geo, width = "100%") %>%
    addProviderTiles(providers$OpenStreetMap.HOT, group = "OSM (HOT)") %>%
    addPolygons(
      label = ~ stringr::str_c('Likelihood =', FAO_adop_limits),
      labelOptions = labelOptions(direction = 'auto'),
      color = "#03F",
      weight = 1,
      opacity = 0.5,
      fill = T,
      fillColor = ~ pal(bin),
      fillOpacity = 0.2,
      dashArray = NULL,
      smoothFactor = 1,
      noClip = FALSE,
      popup = paste(
        'Adoption FAO Class  =',
        sf_adop_faolimits_cat4_geo$FAO,
        '<br>',
        '<br>',
        'Adoption optimal  =',
        sf_adop_faolimits_cat4_geo$optimal,
        '<br>',
        '<br>',
        'Socio-Economic optimal  =',
        sf_adop_faolimits_cat4_geo$se_1_o,
        '<br>',
        '<br>',
        'Biophysical optimal  =',
        sf_adop_faolimits_cat4_geo$ba_1_o,
        '<br>',
        '<br>',
        'Climate optimal  =',
        sf_adop_faolimits_cat4_geo$ba_2b_o,
        '<br>',
        'Soil Fertility optimal  =',
        sf_adop_faolimits_cat4_geo$ba_2d_o,
        '<br>',
        'Landscape optimal  =',
        sf_adop_faolimits_cat4_geo$ba_2e_o,
        '<br>',
        'Soil Physical optimal  =',
        sf_adop_faolimits_cat4_geo$ba_2c_o,
        '<br>',
        'Land Use optimal  =',
        sf_adop_faolimits_cat4_geo$ba_2a_o
      ),
      popupOptions = NULL,
      highlightOptions = NULL,
    )
  
  frameWidget(leaflet_widget, height = '500')
  
} # end RES if statement 08/12/2019

``` 
</div>



```{r i2_classified_ba_membership_maps01, echo=FALSE, results='asis', eval=ba_crit}

cat("## Classified Map of Biophysical Aptitude")

```

The first map is _without_, the second map  _with_ triangulation points. These points are either high or low, as indicated by the symbols + and - respectively. The colour of the circles behind these symbols refers to the type of adoption, _i.e._, biophysical (b) and/or socio-economic (s). These classes are constructed from the table below:

<div class="fold o"> 
```{r i2_classified_ba_membership_maps02 , cache = TRUE, cache.whatever=params$Agg, warning=FALSE, timeit = TRUE, eval=ba_crit}

# idem + overlay triangulation aptitude points

vect_ba_tri <- vect_triangulation %>%
    mutate(
        baclass = ifelse(grepl(pattern = "suboptimal", x = eval(parse(text = params$TRI2)), ignore.case = TRUE), "suboptimal", ifelse(grepl(pattern = "optimal", x = eval(parse(text = params$TRI2)), ignore.case = TRUE), "optimal", "other"))#,
        #type = NA  #a Farrow commented out 26/09/2023
    ) %>%
    dplyr::filter(!is.na(params$TRI2))


mutate(df_onset, !!as.character(paste0(period_name,"_l")) :=  eval(parse(text = paste0("df_growth_stages_lengths3$", period_name))), .keep = c("all"))


vect_ba_tri$type[grepl(pattern = " AE", x = paste0("vect_ba_tri$",params$TRI2), ignore.case = TRUE)] <- "b"
vect_ba_tri$type[grepl(pattern = " EA", x = paste0("vect_ba_tri$",params$TRI2), ignore.case = TRUE)] <- "b"
vect_ba_tri$type[grepl(pattern = "bio", x = paste0("vect_ba_tri$",params$TRI2), ignore.case = TRUE)] <- "b"
vect_ba_tri$type[grepl(pattern = "SE", x = paste0("vect_ba_tri$",params$TRI2), ignore.case = TRUE)] <- "s"
vect_ba_tri$type[grepl(pattern = "soil", x = paste0("vect_ba_tri$",params$TRI2), ignore.case = TRUE)] <- "b"
vect_ba_tri$type[grepl(pattern = "lowland", x = paste0("vect_ba_tri$",params$TRI2), ignore.case = TRUE)] <- "b"
vect_ba_tri$type[grepl(pattern = " temp", x = paste0("vect_ba_tri$",params$TRI2), ignore.case = TRUE)] <- "b"
vect_ba_tri$type[grepl(pattern = " elevation", x = paste0("vect_ba_tri$",params$TRI2), ignore.case = TRUE)] <- "b"
vect_ba_tri$type[grepl(pattern = "market", x = paste0("vect_ba_tri$",params$TRI2), ignore.case = TRUE)] <- "s"
vect_ba_tri$type[grepl(pattern = "rain", x = paste0("vect_ba_tri$",params$TRI2), ignore.case = TRUE)] <- "b"
vect_ba_tri$type[grepl(pattern = "SPAM presence", x = paste0("vect_ba_tri$",params$TRI2), ignore.case = TRUE)] <- "b"

vect_ba_tri %>%
    dplyr::select(params$TRI2, baclass, type) %>%
    (knitr::kable) %>% kable_styling("striped", full_width = F) %>% scroll_box(height = "300px")

```
</div>


```{r i2_classified_ba_membership_maps_CRASA01, echo=FALSE, results='asis', eval=ba_crit}

cat("### Biophysical Aptitude - one class (CRASA)")

```

<div class="fold o"> 
```{r i2_classified_ba_membership_maps_CRASA02 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, timeit = TRUE, eval=ba_crit}
# create classified aptitude map 

if (params$RES2 != 2) {
  # new method because of df_irm_i2 dropped no data
  
  vect_ba_1class <-
    df_irm_i2 %>% dplyr::select(ba_1_o, x , y) %>% na.omit %>% vect(geom = c("x", "y"))
  rast_ba_1class_o <- rasterize(vect_ba_1class, rast_mask_proj, field = "ba_1_o")
  rast_ba_1class_bin <- classify(rast_ba_1class_o, matrix(c(-0.5, 0, 0, 0, 1, 3),
        ncol = 3,
        byrow = TRUE)
      )
  names(rast_ba_1class_bin) <- c('optimal')
  
  output_geotiff(rast_ba_1class_bin, paste0("1class_ba1_", params$INN2))

  # export class as polygon
  vect_ba_1class_bin <- as.polygons(rast_ba_1class_bin, dissolve = T)
  
  vect_filename <-
    as.character(paste("spatial_data/output/1class_ba1_", params$INN2, ".shp"))
  writeVector(vect_ba_1class_bin, here(vect_filename), overwrite = TRUE)
  
  
  df_ba_1class_bin <- rast_ba_1class_bin %>%
    as.data.frame(xy = TRUE) %>%
    na.omit
  df_ba_1class_bin_o <- df_ba_1class_bin %>% dplyr::select(-x,-y)
  
 
# project to geo for display in leaflet
  vect_ba_1class_bin_geo <- terra::project(vect_ba_1class_bin, "epsg:4326")
  
  
## for CRASA sourcing pipeline  
  
# for the sourcing pipeline need only a raster of the potential crop areas, with non-N zones having a value of 1

# reclassify rast_ba_1class_bin 
  
v_1class <- c(0, 0.5, 1,
       0.5, 1, 3, NA, NA, 0)
m_1class <- matrix(v_1class, ncol=3, byrow=TRUE)
rast_ba_1class_rcl <- classify(rast_ba_1class_bin$optimal, m_1class, include.lowest=TRUE)
  
rast_ba_1class_rcl_geo <- terra::project(rast_ba_1class_rcl, "epsg:4326", method = "near")

rast_filename <-
  as.character(paste("spatial_data/output/rast_", params$INN2,"_pot-N.tif"))
writeRaster(rast_ba_1class_rcl_geo, here(rast_filename), overwrite=TRUE)

#plot(dB_ba_rcl_geo, main = paste0("Not sub-optimal ", params$INN2," 4 CRASA pipeline"))

levels(rast_ba_1class_rcl_geo) <- data.frame(id = c(0, 1, 3), opt = c("No Cropland", "Unsuitable", "Suitable"))

cols <- c("No Cropland" = NA, "Unsuitable" = "red", "Suitable" = "darkgreen")

g <-  ggplot() +
      geom_spatraster(data = rast_ba_1class_rcl_geo, aes(fill = opt), alpha = 1) +
      geom_spatvector(
        data = unwrap(vect_subdiv),
        fill = NA,
        col = 'black',
        na.rm = TRUE,
        inherit.aes = FALSE
      )  +
      scale_fill_manual(
        values = cols,
        na.translate = F
      ) +
      xlim ((ext(unwrap(vect_subdiv))[1] ), (ext(unwrap(vect_subdiv))[2]) ) +
      ylim ((ext(unwrap(vect_subdiv))[3] ), (ext(unwrap(vect_subdiv))[4]) ) +
      labs(
        fill = paste0(
          "--------------------\nSuitability for\n",
          params$INN2,
          "\n",
          "\n--------------------"
        )
      ) +
      theme(
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank()
      ) +
      coord_sf(expand = FALSE)

g

} # end RES if statement 08/12/2019
``` 
</div>


```{r i2_classified_ba_membership_maps_CRASA03, echo=FALSE, results='asis', eval=ba_crit}

cat("#### Biophysical Aptitude - one class (CRASA) Leaflet")

```


<div class="fold o"> 
```{r i2_classified_ba_membership_maps_CRASA04 , cache = TRUE, cache.whatever=params$Agg, warning=FALSE, timeit = TRUE, eval=ba_crit}


if (params$RES2 != 2) {
  # convert to sf until leaflet properly accepts spatvector
  sf_ba_1class_bin_geo <- st_as_sf(vect_ba_1class_bin_geo)
  
  
  ba_1class_palette <- (c("red", #Unsuitable
                         NA, #No Cropland
                         NA, #No Value
                         "darkgreen")) #Suitable
  
  pal <-
    colorFactor(ba_1class_palette,
                domain = c(0:3),
                na.color = "#808080")
  
  leaflet_widget <- leaflet(sf_ba_1class_bin_geo, width = "100%") %>%
    addProviderTiles(providers$OpenStreetMap.HOT, group = "OSM (HOT)") %>%
    addPolygons(
      label = ~ stringr::str_c('Aptitude =', optimal),
      labelOptions = labelOptions(direction = 'auto'),
      color = "#03F",
      weight = 1,
      opacity = 0.5,
      fillColor = ~ pal(optimal),
      fillOpacity = 0.2,
      dashArray = NULL,
      smoothFactor = 1,
      noClip = FALSE,
      popupOptions = NULL,
      highlightOptions = NULL,
    )
  
  frameWidget(leaflet_widget, height = '500')
  
} # end RES if statement 08/12/2019


``` 
</div>

```{r i2_classified_ba_membership_maps_opt01, echo=FALSE, results='asis', eval=ba_crit}

cat("### Biophysical Aptitude - two classes")

```

<div class="fold o"> 
```{r i2_classified_ba_membership_maps_opt02 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, timeit = TRUE, eval=ba_crit}
# create classified aptitude map 

if (params$RES2 != 2) {
  # new method because of df_irm_i2 dropped no data
  
  vect_ba_2class <-
    df_irm_i2 %>% dplyr::select(ba_1_o, ba_1_s, x , y) %>% na.omit %>% vect(geom = c("x", "y"))
  rast_ba_2class_o <- rasterize(vect_ba_2class, rast_mask_proj, field = "ba_1_o")
  rast_ba_2class_s <- rasterize(vect_ba_2class, rast_mask_proj, field = "ba_1_s")
  rast_ba_2class <- rast(list(rast_ba_2class_o, rast_ba_2class_s))
  names(rast_ba_2class) <- c('optimal', 'suboptimal')
  
  # get max value and export
  rast_ba_2class_max <- which.max(rast_ba_2class)
  rast_ba_2class_brick <- rast(list(rast_ba_2class_o, rast_ba_2class_s, rast_ba_2class_max))
  names(rast_ba_2class_brick) <- c('optimal', 'suboptimal', 'class')
  output_geotiff(rast_ba_2class_brick, paste0("2class_ba1_", params$INN2))
  
  # export class as polygon
  vect_ba_2class_max <- as.polygons(rast_ba_2class_max, dissolve = T)
  
    vect_filename <-
    as.character(paste("spatial_data/output/2class_ba1_", params$INN2, ".shp"))
  writeVector(vect_ba_2class_max, here(vect_filename), overwrite = TRUE)
  
  
  df_ba_2class <- rast_ba_2class %>%
    as.data.frame(xy = TRUE) %>%
    na.omit
  m <- df_ba_2class %>% dplyr::select(-x,-y)
  
  df_ba_2class$class <- names(m)[apply(X = m, MARGIN = 1, FUN = which.max)]
  df_ba_2class$class <-
    factor(df_ba_2class$class,
           levels = c("optimal", "suboptimal"),
           ordered = TRUE)
  
  g <- ggplot(data = df_ba_2class) +
    geom_raster(mapping = aes(x = x, y = y, fill = class)) +
    #    scale_x_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
#    scale_y_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
    scale_fill_manual(
      name = paste0("Biophysical\nAptitude\n", params$INN2),
      values = c(
        optimal = rgb(0, 158, 115, maxColorValue = 255),
        suboptimal  = rgb(213,  94,   0, maxColorValue = 255)
      ),
      drop = FALSE
    ) +
    coord_sf()
  

  g2 <- add_subdiv_proj_simple_plot(g)
  g2
} # end RES if statement 08/12/2019

``` 
</div>

<div class="fold o"> 
```{r i2_classified_ba_membership_maps_opt03 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, message  = FALSE, timeit = TRUE, eval=ba_crit}
# create classified suitability map and validation
# 01/03/2019 A FARROW this chunk split because map not appearing

if (params$RES2 != 2) {
  
g2 + 
    geom_spatvector(
        data = vect_ba_tri, 
        mapping = aes(colour = ifelse(baclass == "optimal" , "green", "red")), 
        size = 2
    ) +
    geom_spatvector_text(
        data = vect_ba_tri, 
        mapping = aes(label = ifelse(type == "b", "b", "b/s"))
    ) + 
  scale_colour_identity() 

} # end RES if statement 08/12/2019

``` 
</div>

```{r i2_classified_ba_membership_maps_opt04, echo=FALSE, results='asis', eval=ba_crit}

cat("#### Biophysical Aptitude - two classes Leaflet")

```

<div class="fold o"> 
```{r i2_classified_ba_membership_maps_opt05 , cache = TRUE, cache.whatever=params$Agg, warning=FALSE, timeit = TRUE, eval=ba_crit}

if (params$RES2 != 2) {
  
  # get the polygons showing the layer with the max value in rast_ba_2class

  vect_ba_2class_max1 <- as.polygons(rast_ba_2class_max, dissolve=FALSE)
  vect_ba_2class_max1$class <- df_ba_2class$class
  
  # join the polygons with the aptitude points
  vect_ba_2class_max1[["id"]] <- 1:nrow(vect_ba_2class_max1)
  vect_apt[["id"]] <- 1:nrow(vect_apt)
  pinp_m <- relate(vect_ba_2class_max1, vect_apt, "contains", pairs=TRUE)
  df_pinp <- dplyr::as_tibble(pinp_m)
  vect_ba_2class_max2 <- merge(x = vect_ba_2class_max1, y = df_pinp, by.x = "id", by.y = "id.x", all.x = TRUE)
  vect_ba_2class_max2 <- merge(x = vect_ba_2class_max2, y = vect_apt, by.x = "id.y", by.y = "id", all.x = TRUE)
  
     # project to geo for display in leaflet
  vect_ba_2class_max2_geo <- project(vect_ba_2class_max2, "epsg:4326")
  
  # convert to sf until leaflet properly accepts spatvector
  sf_ba_2class_max2_geo <- st_as_sf(vect_ba_2class_max2_geo)
  
  
  ba_2class_palette <- (c(
    rgb(0, 158, 115, maxColorValue = 255),
    #optimal
    rgb(230, 159, 0, maxColorValue = 255)
  )) #suboptimal
  
  pal <-
    colorFactor(ba_2class_palette, domain = c(1:2), na.color = "#808080")
  
  leaflet_widget <- leaflet(sf_ba_2class_max2_geo, width = "100%") %>%
    addProviderTiles(providers$OpenStreetMap.HOT, group = "OSM (HOT)") %>%
    addPolygons(
      label = ~ stringr::str_c('Aptitude =', class),
      labelOptions = labelOptions(direction = 'auto'),
      color = "#03F",
      weight = 1,
      opacity = 0.5,
      fill = which.max,
      fillColor = ~ pal(which.max),
      fillOpacity = 0.2,
      dashArray = NULL,
      smoothFactor = 1,
      noClip = FALSE,
      popup = paste(
        'Bio Apt optimal  =',
        sf_ba_2class_max2_geo$ba_1_o,
        '<br>',
        'Bio Apt suboptimal =',
        sf_ba_2class_max2_geo$ba_1_s,
        '<br>',
        '<br>',
        'Climate suboptimal  =',
        sf_ba_2class_max2_geo$ba_2b_s,
        '<br>',
        'Soil Fertility suboptimal  =',
        sf_ba_2class_max2_geo$ba_2d_s,
        '<br>',
        'Landscape suboptimal  =',
        sf_ba_2class_max2_geo$ba_2e_s,
        '<br>',
        'Soil Physical suboptimal  =',
        sf_ba_2class_max2_geo$ba_2c_s,
        '<br>',
        'Land Use suboptimal  =',
        sf_ba_2class_max2_geo$ba_2a_s
      ),
      popupOptions = NULL,
      highlightOptions = NULL,
    )
  
  frameWidget(leaflet_widget, height = '500')
  
} # end RES if statement 08/12/2019

``` 
</div>

```{r i2_classified_ba_membership_maps_fao01, echo=FALSE, results='asis', eval=ba_crit}

cat("### Biophysical Aptitude - FAO five classes classes")

```

<div class="fold o"> 
```{r i2_classified_ba_membership_maps_fao02 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, timeit = TRUE, eval=ba_crit}
# create classified aptitude map 

if (params$RES2 != 2) {
  # new method because of df_irm_i2 dropped no data
  
  vect_ba_fao <-
    df_irm_i2 %>% dplyr::select(ba_1_o, x , y) %>% na.omit %>% vect(geom = c("x", "y"))
  rast_ba_fao <- rasterize(vect_ba_fao, rast_mask_proj, field = "ba_1_o")
  names(rast_ba_fao) <- c('FAO')
  
  # classify values and export
  ## from-to-becomes
  # classify the optimal values into five groups
  # all values >= 0 and <= 0.25 become N2, etc.
  v_ba_fao <- c(-Inf, 0.25, 5,
             0.25, 0.4, 4,
             0.4, 0.6, 3,
             0.6, 0.85, 2,
             0.85, Inf, 1)
  m_ba_fao <- matrix(v_ba_fao, ncol = 3, byrow = TRUE)
  rast_ba_fao_bin <- classify(rast_ba_fao, m_ba_fao, include.lowest = TRUE)
  rast_ba_fao_cat <- rast_ba_fao_bin
  df_ba_fao <- data.frame(id = 1:5, FAO = c("S1", "S2", "S3", "N1", "N2"))
  levels(rast_ba_fao_cat) <- df_ba_fao
  rast_ba_fao_brick <- rast(list(rast_ba_fao, rast_ba_fao_bin, rast_ba_fao_cat))
  names(rast_ba_fao_brick) <- c('optimal', 'bin', 'FAO')
  output_geotiff(rast_ba_fao_brick, paste0("1class_ba1_", params$INN2))
  
  # export class and optimal value as polygon
  vect_ba_fao_cat <- as.polygons(rast_ba_fao_cat, dissolve = T)
  
  vect_filename <-
    as.character(paste("spatial_data/output/1class_ba1_", params$INN2, ".shp"))
  writeVector(vect_ba_fao_cat, here(vect_filename), overwrite = TRUE)
  
  g <- ggplot() +
    geom_spatraster(data = rast_ba_fao_cat, na.rm = TRUE, aes(fill = FAO)) +
    scale_fill_manual(
    name = paste0("FAO\nsuitability\n", params$INN2),  na.value = "transparent",
    values = c(
      S1 = rgb(51, 160, 44, maxColorValue = 255),
      S2 = rgb(178, 223, 138, maxColorValue = 255),
      S3 = rgb(255, 255, 153, maxColorValue = 255),      
      N1 = rgb(255, 127, 0, maxColorValue = 255),
      N2 = rgb(227, 26, 28, maxColorValue = 255)
    ))
 
  g2 <- add_subdiv_proj_simple_plot(g)
  g2
} # end RES if statement 08/12/2019

``` 
</div>

<div class="fold o"> 
```{r i2_classified_ba_membership_maps_fao03 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, message  = FALSE, timeit = TRUE, eval=ba_crit}
# create classified suitability map and validation
# 01/03/2019 A FARROW this chunk split because map not appearing

if (params$RES2 != 2) {
  
g2 + 
    geom_spatvector(
        data = vect_ba_tri, 
        mapping = aes(colour = ifelse(baclass == "optimal" , "green", "red")), 
        size = 1, shape = 21
    ) +
    #geom_spatvector_text(
    #    data = vect_ba_tri, 
    #    mapping = aes(label = ifelse(type == "b", "b", "b/s"))
    #) + 
  scale_colour_identity() 

} # end RES if statement 08/12/2019

``` 
</div>

```{r i2_classified_ba_membership_maps_fao04, echo=FALSE, results='asis', eval=ba_crit}

cat("#### Biophysical Aptitude - FAO five classes Leaflet")

```

<div class="fold o"> 
```{r i2_classified_ba_membership_maps_fao05 , cache = TRUE, cache.whatever=params$Agg, warning=FALSE, timeit = TRUE, eval=ba_crit}

if (params$RES2 != 2) {
  
  # convert the spatraster (showing the FAO suitability classes (bin number and class name), and the optimality value) to polygons - do not dissolve
  
  vect_ba_fao_cat2 <- as.polygons(rast_ba_fao_brick, dissolve=FALSE)

  
  # join the polygons (vect_ba_fao_cat2) with the aptitude points (vect_apt)
  
  vect_ba_fao_cat2[["id"]] <- 1:nrow(vect_ba_fao_cat2) # need an id field for p-in-p matrix
  vect_apt[["id"]] <- 1:nrow(vect_apt) # need an id field for p-in-p matrix
  pinp_m <- relate(vect_ba_fao_cat2, vect_apt, "contains", pairs=TRUE) # point in polygon matrix
  df_pinp <- dplyr::as_tibble(pinp_m) # point in polygon tibble
  vect_ba_fao_cat3 <- merge(x = vect_ba_fao_cat2, y = df_pinp, by.x = "id", by.y = "id.x", all.x = TRUE)
  vect_ba_fao_cat4 <- merge(x = vect_ba_fao_cat3, y = vect_apt, by.x = "id.y", by.y = "id", all.x = TRUE)
  
     # project to geo for display in leaflet
  vect_ba_fao_cat4_geo <- project(vect_ba_fao_cat4, "epsg:4326")
  
  # convert to sf until leaflet properly accepts spatvector
  sf_ba_fao_cat4_geo <- st_as_sf(vect_ba_fao_cat4_geo)
  
  
  ba_fao_palette <- (c(
    rgb(51, 160, 44, maxColorValue = 255),#S1
    rgb(178, 223, 138, maxColorValue = 255), #S2
    rgb(255, 255, 153, maxColorValue = 255), #S3
    rgb(255, 127, 0, maxColorValue = 255), #N1
    rgb(227, 26, 28, maxColorValue = 255) #N2
      )) 
  
  pal <-
    colorFactor(ba_fao_palette, domain = c(1:5), na.color = "#808080")
  
  leaflet_widget <- leaflet(sf_ba_fao_cat4_geo, width = "100%") %>%
    addProviderTiles(providers$OpenStreetMap.HOT, group = "OSM (HOT)") %>%
    addPolygons(
      label = ~ stringr::str_c('Aptitude =', FAO),
      labelOptions = labelOptions(direction = 'auto'),
      color = "#03F",
      weight = 1,
      opacity = 0.5,
      fill = T,
      fillColor = ~ pal(bin),
      fillOpacity = 0.2,
      dashArray = NULL,
      smoothFactor = 1,
      noClip = FALSE,
      popup = paste(
        'Bio Apt FAO Class  =',
        sf_ba_fao_cat4_geo$FAO,
        '<br>',
        '<br>',
        'Bio Apt optimal  =',
        sf_ba_fao_cat4_geo$ba_1_o,
        '<br>',
        '<br>',
        'Climate optimal  =',
        sf_ba_fao_cat4_geo$ba_2b_o,
        '<br>',
        'Soil Fertility optimal  =',
        sf_ba_fao_cat4_geo$ba_2d_o,
        '<br>',
        'Landscape optimal  =',
        sf_ba_fao_cat4_geo$ba_2e_o,
        '<br>',
        'Soil Physical optimal  =',
        sf_ba_fao_cat4_geo$ba_2c_o,
        '<br>',
        'Land Use optimal  =',
        sf_ba_fao_cat4_geo$ba_2a_o
      ),
      popupOptions = NULL,
      highlightOptions = NULL,
    )
  
  frameWidget(leaflet_widget, height = '500')
  
} # end RES if statement 08/12/2019

``` 
</div>


```{r i2_classified_ba_membership_maps_faolimits01, echo=FALSE, results='asis', eval=ba_crit}

cat("### Biophysical Aptitude - FAO limitations classes")

```

<div class="fold o"> 
```{r i2_classified_ba_membership_maps_faolimits02 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, timeit = TRUE, eval=ba_crit}
# create classified aptitude map 

if (params$RES2 != 2) {
  # new method because of df_irm_i2 dropped no data
  
  df_df_irm_i2_ba_fao <-
    df_irm_i2 %>% dplyr::select(x, y, ba_1_o) %>% na.omit %>% mutate(FAO = cut(
      ba_1_o,
      breaks = c(-Inf, 0.25, 0.4, 0.6, 0.8, Inf),
      labels = c("N2", "N1", "S3", "S2", "S1"),
      include.lowest = TRUE
    ))

  df_faolimits <-
    df_irm_i2 %>% dplyr::select(ba_2b_s, ba_2c_s, ba_2d_s, ba_2e_s) %>% na.omit
  df_faolimits$limit <- names(df_faolimits)[][max.col(df_faolimits[])]
  
  df_ba_faolimits <- cbind(df_df_irm_i2_ba_fao, df_faolimits)

  df_ba_faolimits <- df_ba_faolimits %>% 
      mutate(FAO_limit = case_match(limit, "ba_2b_s" ~ "Cl", "ba_2c_s" ~ "SP", "ba_2d_s" ~ "SF", "ba_2e_s" ~ "Ls",
  .default = "missing"), .keep = "all")
  
    df_ba_faolimits <- df_ba_faolimits %>% 
      mutate(FAO_limit2 = case_when(FAO == "S1" ~ "S1", .default = paste0(FAO,"_",FAO_limit)))
    
  df_faolimits_values  <-  df_ba_faolimits %>% select(FAO_limit2) %>% unique()
  df_faolimits_values  <- df_faolimits_values[order(df_faolimits_values$FAO_limit2), ] %>% data.frame
  names(df_faolimits_values) <- c('FAO_limit_code')
  
  df_faolimits_values  <- mutate(df_faolimits_values, ID = row_number()-1)
  df_faolimits_values  <- df_faolimits_values[, c(2,1)] # re-order for later use as raster categories
  
  df_faolimits_code <-
    data.frame(
      "FAO_code_num" = c(1:17),
      "FAO_code_char" = c(
        'S1',
        'S2_Cl',
        'S2_Ls',
        'S2_SF',
        'S2_SP',
        'S3_Cl',
        'S3_Ls',
        'S3_SF',
        'S3_SP',
        'N1_Cl',
        'N1_Ls',
        'N1_SF',
        'N1_SP',
        'N2_Cl',
        'N2_Ls',
        'N2_SF',
        'N2_SP'
      )
    )
  
  vect_ba_faolimits  <- vect(df_ba_faolimits, geom = c("x", "y"))
    
  rast_ba_faolimits <- rasterize(vect_ba_faolimits, rast_mask_proj, field = "FAO_limit2")
  names(rast_ba_faolimits) <- c('FAO_limit_code')
  levels(rast_ba_faolimits) <- df_faolimits_values
  
  vect_ba_faolimits <-    merge(
    x = vect_ba_faolimits,
    y = df_faolimits_code,
    by.x = "FAO_limit2",
    by.y = "FAO_code_char",
    all.x = TRUE
  )
  
  rast_ba_faolimits_bin <-
    rasterize(vect_ba_faolimits, rast_mask_proj, field = "FAO_code_num")
  
  rast_ba_1_o <- rasterize(vect_ba_faolimits, rast_mask_proj, field = "ba_1_o")
  
  rast_ba_faolimits_brick <- rast(list(rast_ba_1_o, rast_ba_faolimits, rast_ba_faolimits_bin))
  names(rast_ba_faolimits_brick) <- c('optimal', 'FAO_limits', 'bin')
  output_geotiff(rast_ba_faolimits_brick, paste0("FAO_limits_ba1_", params$INN2))
  
  # export class and optimal value as polygon
  vect_ba_faolimits_cat <- as.polygons(rast_ba_faolimits_brick, dissolve = T)
  
  vect_filename <-
    as.character(paste("spatial_data/output/FAO_limits_ba1_", params$INN2, ".shp"))
  writeVector(vect_ba_faolimits_cat, here(vect_filename), overwrite = TRUE)
  
  g <- ggplot() +
    geom_spatraster(data = rast_ba_faolimits, na.rm = TRUE, aes(fill = FAO_limit_code)) +
    scale_fill_manual(
    name = "FAO\nlimitations\nrice",  
    breaks = c('S1','S2_Cl','S2_Ls','S2_SF','S2_SP','S3_Cl','S3_Ls','S3_SF',
      'S3_SP','N1_Cl','N1_Ls','N1_SF','N1_SP','N2_Cl','N2_Ls','N2_SF','N2_SP'),
    na.value = "transparent",
    values = c(
      S1 = rgb(0,102,0, maxColorValue = 255),
      S2_Cl = rgb(24,252,0, maxColorValue = 255),
      S2_Ls = rgb(60,179,113, maxColorValue = 255),
      S2_SF = rgb(50,205,50, maxColorValue = 255),
      S2_SP = rgb(34,139,34, maxColorValue = 255),
      S3_Cl = rgb(245, 206, 51, maxColorValue = 255),
      S3_Ls = rgb(247, 218, 102, maxColorValue = 255),
      S3_SF = rgb(250, 231, 153, maxColorValue = 255),
      S3_SP = rgb(252, 243, 204, maxColorValue = 255),
      N1_Cl = rgb(255, 127, 0, maxColorValue = 255),
      N1_Ls = rgb(255, 168, 54, maxColorValue = 255),
      N1_SF = rgb(255, 87, 40, maxColorValue = 255),
      N1_SP = rgb(255, 187, 60, maxColorValue = 255),
      N2_Cl = rgb(234, 60, 83, maxColorValue = 255),
      N2_Ls = rgb(180, 55, 87, maxColorValue = 255),
      N2_SF = rgb(66, 13, 9, maxColorValue = 255),
      N2_SP = rgb(240, 128, 128, maxColorValue = 255)
    ))
 
  g2 <- add_subdiv_proj_simple_plot(g)
  g2
} # end RES if statement 08/12/2019

``` 
</div>

<div class="fold o"> 
```{r i2_classified_ba_membership_maps_faolimits03 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, message  = FALSE, timeit = TRUE, eval=ba_crit}
# create classified suitability map and validation
# 01/03/2019 A FARROW this chunk split because map not appearing

if (params$RES2 != 2) {
  
g2 + 
    geom_spatvector(
        data = vect_triangulation, 
        mapping = aes(colour = ifelse(Adoption == "high" , "green", "red")), 
        size = 2
    ) +
  scale_colour_identity() 

} # end RES if statement 08/12/2019

``` 
</div>

```{r i2_classified_ba_membership_maps_faolimits04, echo=FALSE, results='asis', eval=ba_crit}

cat("#### Biophysical Aptitude - FAO limitations classes Leaflet")

```

<div class="fold o"> 
```{r i2_classified_ba_membership_maps_faolimits05 , cache = TRUE, cache.whatever=params$Agg, warning=FALSE, timeit = TRUE, eval=ba_crit}

if (params$RES2 != 2) {
  
  # convert the spatraster (showing the FAO suitability classes (bin number and class name), and the optimality value) to polygons - do not dissolve
  
  vect_ba_faolimits_cat2 <- as.polygons(rast_ba_faolimits_brick, dissolve=FALSE)

  
  # join the polygons (vect_ba_faolimits_cat2) with the likelihood points (vect_ba_faolimits)
  
  vect_ba_faolimits_cat2[["id"]] <- 1:nrow(vect_ba_faolimits_cat2) # need an id field for p-in-p matrix
  vect_adop[["id"]] <- 1:nrow(vect_adop) # need an id field for p-in-p matrix
  pinp_m <- relate(vect_ba_faolimits_cat2, vect_adop, "contains", pairs=TRUE) # point in polygon matrix
  df_pinp <- dplyr::as_tibble(pinp_m) # point in polygon tibble
  vect_ba_faolimits_cat3 <- merge(x = vect_ba_faolimits_cat2, y = df_pinp, by.x = "id", by.y = "id.x", all.x = TRUE)
  vect_ba_faolimits_cat4 <- merge(x = vect_ba_faolimits_cat3, y = vect_adop, by.x = "id.y", by.y = "id", all.x = TRUE)
  
     # project to geo for display in leaflet
  vect_ba_faolimits_cat4_geo <- project(vect_ba_faolimits_cat4, "epsg:4326")
  
  # convert to sf until leaflet properly accepts spatvector
  sf_ba_faolimits_cat4_geo <- st_as_sf(vect_ba_faolimits_cat4_geo)
  
  
  ba_faolimits_palette <- ( c(
      rgb(0,102,0, maxColorValue = 255),       #S1  
      rgb(24,252,0, maxColorValue = 255),      #S2_Cl  
      rgb(60,179,113, maxColorValue = 255),    #S2_Ls  
      rgb(50,205,50, maxColorValue = 255),     #S2_SF  
      rgb(34,139,34, maxColorValue = 255),     #S2_SP 
      rgb(245, 206, 51, maxColorValue = 255),  #S3_Cl 
      rgb(247, 218, 102, maxColorValue = 255), #S3_Ls  
      rgb(250, 231, 153, maxColorValue = 255), #S3_SF  
      rgb(252, 243, 204, maxColorValue = 255), #S3_SP  
      rgb(255, 127, 0, maxColorValue = 255),   #N1_Cl  
      rgb(255, 168, 54, maxColorValue = 255),  #N1_Ls  
      rgb(255, 87, 40, maxColorValue = 255),   #N1_SF  
      rgb(255, 187, 60, maxColorValue = 255),  #N1_SP  
      rgb(234, 60, 83, maxColorValue = 255),   #N2_Cl  
      rgb(180, 55, 87, maxColorValue = 255),   #N2_Ls  
      rgb(66, 13, 9, maxColorValue = 255),     #N2_SF  
      rgb(240, 128, 128, maxColorValue = 255)  #N2_SP  
    )) 

  pal <-
    colorFactor(ba_faolimits_palette, domain = c(1:17), na.color = "#808080")
  
  leaflet_widget <- leaflet(sf_ba_faolimits_cat4_geo, width = "100%") %>%
    addProviderTiles(providers$OpenStreetMap.HOT, group = "OSM (HOT)") %>%
    addPolygons(
      label = ~ stringr::str_c('Likelihood =', FAO_limits),
      labelOptions = labelOptions(direction = 'auto'),
      color = "#03F",
      weight = 1,
      opacity = 0.5,
      fill = T,
      fillColor = ~ pal(bin),
      fillOpacity = 0.2,
      dashArray = NULL,
      smoothFactor = 1,
      noClip = FALSE,
      popup = paste(
        'Adoption FAO Class  =',
        sf_ba_faolimits_cat4_geo$FAO,
        '<br>',
        '<br>',
        'Adoption optimal  =',
        sf_ba_faolimits_cat4_geo$optimal,
        '<br>',
        '<br>',
        'Biophysical optimal  =',
        sf_ba_faolimits_cat4_geo$ba_1_o,
        '<br>',
        '<br>',
        'Climate optimal  =',
        sf_ba_faolimits_cat4_geo$ba_2b_o,
        '<br>',
        'Soil Fertility optimal  =',
        sf_ba_faolimits_cat4_geo$ba_2d_o,
        '<br>',
        'Landscape optimal  =',
        sf_ba_faolimits_cat4_geo$ba_2e_o,
        '<br>',
        'Soil Physical optimal  =',
        sf_ba_faolimits_cat4_geo$ba_2c_o,
        '<br>',
        'Land Use optimal  =',
        sf_ba_faolimits_cat4_geo$ba_2a_o
      ),
      popupOptions = NULL,
      highlightOptions = NULL,
    )
  
  frameWidget(leaflet_widget, height = '500')
  
} # end RES if statement 08/12/2019

``` 
</div>


```{r i2_classified_se_membership_maps01, echo=FALSE, results='asis', eval=sef_crit}

cat("## Classified Map of Socioeconomic Feasibility")

```

<div class="fold o"> 
```{r i2_classified_se_membership_maps02 , cache = TRUE, cache.whatever=params$Agg, warning=FALSE, timeit = TRUE, eval=sef_crit}
# idem + overlay triangulation aptitude points


#vect_se_tri <- sfc_as_cols(vect_triangulation) %>%
  vect_se_tri <- vect_triangulation %>%
    mutate(
        seclass = ifelse(grepl(pattern = "high", x = Feasibility, ignore.case = TRUE), "high", ifelse(grepl(pattern = "moderate", x = Feasibility, ignore.case = TRUE), "moderate", "low")),
        type = NA
    ) %>%
    dplyr::filter(!is.na(Feasibility))


vect_se_tri$type[grepl(pattern = " AE", x = vect_se_tri$Feasibility, ignore.case = TRUE)] <- "b"
vect_se_tri$type[grepl(pattern = " EA", x = vect_se_tri$Feasibility, ignore.case = TRUE)] <- "b"
vect_se_tri$type[grepl(pattern = "bio", x = vect_se_tri$Feasibility, ignore.case = TRUE)] <- "b"
vect_se_tri$type[grepl(pattern = "SE", x = vect_se_tri$Feasibility, ignore.case = TRUE)] <- "s"
vect_se_tri$type[grepl(pattern = "soil", x = vect_se_tri$Feasibility, ignore.case = TRUE)] <- "b"
vect_se_tri$type[grepl(pattern = "lowland", x = vect_se_tri$Feasibility, ignore.case = TRUE)] <- "b"
vect_se_tri$type[grepl(pattern = " temp", x = vect_se_tri$Feasibility, ignore.case = TRUE)] <- "b"
vect_se_tri$type[grepl(pattern = " elevation", x = vect_se_tri$Feasibility, ignore.case = TRUE)] <- "b"
vect_se_tri$type[grepl(pattern = "market", x = vect_se_tri$Feasibility, ignore.case = TRUE)] <- "s"
vect_se_tri$type[grepl(pattern = "rain", x = vect_se_tri$Feasibility, ignore.case = TRUE)] <- "b"

vect_se_tri %>%
    dplyr::select(Feasibility, seclass, type) %>%
    (knitr::kable) %>% kable_styling("striped", full_width = F) %>% scroll_box(height = "300px")
``` 
</div>

```{r i2_classified_se_membership_maps03, echo=FALSE, results='asis', eval=sef_crit}

cat("### Socioeconomic Feasibility - three classes")

```

<div class="fold o"> 
```{r i2_classified_se_membership_maps04 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, timeit = TRUE, eval=sef_crit}
# create classified feasibility map

# new method because of df_irm_i2 dropped no data

if (sef_rb == "hml") {
  vect_se_3class <-
    df_irm_i2 %>% dplyr::select(se_1_h, se_1_m, se_1_l, x , y) %>% na.omit %>% vect(geom = c("x", "y"))
  rast_se_3class_h <- rasterize(vect_se_3class, rast_mask_proj, field = "se_1_h")
  rast_se_3class_m <- rasterize(vect_se_3class, rast_mask_proj, field = "se_1_m")
  rast_se_3class_l <- rasterize(vect_se_3class, rast_mask_proj, field = "se_1_l")
  rast_se_3class <- rast(list(rast_se_3class_h, rast_se_3class_m, rast_se_3class_l))
  names(rast_se_3class) <- c('high', 'moderate', 'low')

  # get max value and export
  rast_se_3class_max <- which.max(rast_se_3class)
  rast_se_3class_brick <- rast(list(rast_se_3class_h, rast_se_3class_m, rast_se_3class_l, rast_se_3class_max))
  names(rast_se_3class_brick) <- c('high', 'moderate', 'low', 'class')
  output_geotiff(rast_se_3class_brick, paste0("3class_se1_", params$INN2))

} else {
  vect_se_3class <-
    df_irm_i2 %>% dplyr::select(se_1_h, se_1_l, x , y) %>% na.omit %>% vect(geom = c("x", "y"))
  rast_se_3class_h <- rasterize(vect_se_3class, rast_mask_proj, field = "se_1_h")
  rast_se_3class_l <- rasterize(vect_se_3class, rast_mask_proj, field = "se_1_l")
  rast_se_3class <- rast(list(d1, d2))
  names(rast_se_3class) <- c('high', 'low')

  # get max value and export
  rast_se_3class_max <- which.max(rast_se_3class)
rast_se_3class_brick <- rast(list(rast_se_3class_h, rast_se_3class_l, rast_se_3class_max))
  names(rast_se_3class_brick) <- c('high', 'low', 'class')
  output_geotiff(rast_se_3class_brick, paste0("3class_se1_", params$INN2))
}

df_se_3class <- rast_se_3class %>%
  as.data.frame(xy = TRUE) %>%
  na.omit
m <- df_se_3class %>% dplyr::select(-x,-y)

df_se_3class$class <- names(m)[apply(X = m, MARGIN = 1, FUN = which.max)]
df_se_3class$class <-
  factor(df_se_3class$class,
         levels = c("low", "moderate", "high"),
         ordered = TRUE)

g <- ggplot(data = df_se_3class) +
  geom_raster(mapping = aes(x = x, y = y, fill = class)) +
  #    scale_x_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
#    scale_y_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
  scale_fill_manual(
    name = paste0("Socio-economic\nFeasibility\n", params$INN2),
    values = c(
      high = rgb(0, 158, 115, maxColorValue = 255),
      low  = rgb(213,  94,   0, maxColorValue = 255),
      moderate = rgb(230, 159, 0, maxColorValue = 255)
    ),
    drop = FALSE
  ) +
  coord_sf()


  g2 <- add_subdiv_proj_simple_plot(g)
g2 
``` 
</div>

<div class="fold o"> 
```{r i2_classified_se_membership_maps05 , cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, message  = FALSE, timeit = TRUE, eval=sef_crit}
# create classified suitability map and validation
# 01/03/2019 A FARROW this chunk split because map not appearing

if (params$RES2 != 2) {
  
g2 + 
    geom_spatvector(
        data = vect_se_tri, 
        mapping = aes(colour = ifelse(seclass == "optimal" , "green", "red")), 
        size = 2
    ) +
    geom_spatvector_text(
        data = vect_se_tri, 
        mapping = aes(label = ifelse(type == "s", "s", "s/b"))
    ) + 
  scale_colour_identity() 

} # end RES if statement 08/12/2019

``` 
</div>

```{r i2_classified_se_membership_maps06, echo=FALSE, results='asis', eval=sef_crit}

cat("#### Socioeconomic Feasibility - three classes Leaflet")

```

<div class="fold o"> 
```{r i2_classified_se_membership_maps07 , cache = TRUE, cache.whatever=params$Agg, warning=FALSE, timeit = TRUE, eval=sef_crit}

if (params$RES2 != 2) {
  
  vect_se_3class_max1 <- as.polygons(rast_se_3class_max , dissolve=FALSE)
  vect_se_3class_max1$class <- df_se_3class$class
  
  # join the polygons with the aptitude points
  vect_se_3class_max1[["id"]] <- 1:nrow(vect_se_3class_max1)
  vect_se[["id"]] <- 1:nrow(vect_se)
  pinp_m <- relate(vect_se_3class_max1, vect_se, "contains", pairs=TRUE)
  df_pinp <- dplyr::as_tibble(pinp_m)
  vect_se_3class_max2 <- merge(x = vect_se_3class_max1, y = df_pinp, by.x = "id", by.y = "id.x", all.x = TRUE)
  vect_se_3class_max2 <- merge(x = vect_se_3class_max2, y = vect_se, by.x = "id.y", by.y = "id", all.x = TRUE)
  
     # project to geo for display in leaflet
  vect_se_3class_max2_geo <- project(vect_se_3class_max2, "epsg:4326")
  
  # convert to sf until leaflet properly accepts spatvector
  sf_se_3class_max2_geo <- st_as_sf(vect_se_3class_max2_geo)
  
  # get the polygons showing the layer with the max value in dB_se
  # sf method of raster to stars then to sf
  #maxse1_poly1 <- st_transform(st_as_sf(st_as_stars(maxse1)), crs_lam)
  
  # join the polygons with the aptitude points
  #maxse1_poly2 <- st_join(maxse1_poly1, se_sf)
  
  #maxse1_poly3 <-
  #  cbind(maxse1_poly2, d_se$class) # add the adaptation class from d_se
  
  # project to geo for display in leaflet
  #maxse1_poly3_geo <- st_transform(maxse1_poly3, crs = 4326)
  
  
  se_3class_palette <- (c(
    rgb(0, 158, 115, maxColorValue = 255),
    #high
    rgb(230, 159, 0, maxColorValue = 255),
    #low
    rgb(213,  94,   0, maxColorValue = 255)
  )) #moderate
  
  pal <-
    colorFactor(se_3class_palette, domain = c(1:3), na.color = "#808080")
  
  leaflet_widget <- leaflet(sf_se_3class_max2_geo, width = "100%") %>%
    addProviderTiles(providers$OpenStreetMap.HOT, group = "OSM (HOT)") %>%
    addPolygons(
      label = ~ stringr::str_c('Feasibility =', class),
      labelOptions = labelOptions(direction = 'auto'),
      color = "#03F",
      weight = 1,
      opacity = 0.5,
      fill = layer,
      fillColor = ~ pal(which.max),
      fillOpacity = 0.2,
      dashArray = NULL,
      smoothFactor = 1,
      noClip = FALSE,
      popup = paste(
        'Markets Poor  =',
        sf_se_3class_max2_geo$se_2a_l,
        '<br>',
        'Farm production Low  =',
        sf_se_3class_max2_geo$se_2b_p,
        '<br>',
        'Management Poor  =',
        sf_se_3class_max2_geo$se_3a_p,
        '<br>',
        'Farm Input access Poor =',
        sf_se_3class_max2_geo$se_3b_p
      ),
      popupOptions = NULL,
      highlightOptions = NULL,
    )
  
  frameWidget(leaflet_widget, height = '500')
  
} # end RES if statement 08/12/2019

``` 
</div>

# Subdivision Area Statistics

```{r i2_statistics_adop_01, echo=FALSE, results='asis', eval=adop_crit}

cat("## Adoption Subdivision Area Statistics

### Likelihood for Adoption - three classes - total area (ha)

The table and maps shows the area in hectares within each subdivision of each likelihood for adoption class.")

```

<div class="fold o"> 
```{r i2_statistics_adop_02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=adop_crit}

if (params$RES2 != 2) {
  df_extr <- terra::extract(rast_adop_3class, vect_subdiv_proj, fun = sum, na.rm = TRUE)
  
  df_extr <-
    (df_extr * Stat_factor_ha) # calculates area depending on the aggregation level
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
 
  output_vect(vect_subdiv, paste0("adop_subdiv_area_", params$INN2)) # save as a geojson file
  
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
  
  
  fill_var_list <-  c("high", "moderate", "low")
  pal_col <- c("Greens","Oranges" ,"Reds")
  
  plot_subdiv_maps(3, fill_var_list, pal_col)
  
}

``` 
</div>


```{r i2_statistics_adop_fao_01, echo=FALSE, results='asis', eval=adop_crit}

cat("###  Likelihood for Adoption - FAO five classes - total area (ha)

The table and maps shows the area in hectares within each subdivision of each FAO likelihood for adoption class")

```

<div class="fold o"> 
```{r i2_statistics_adop_fao_02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=adop_crit}
# create subdiv level statistics
# 03/03/2019 A FARROW adde

if (params$RES2 != 1) {
  
  # need to subset the rast_adop_fao_bin to separate rasters for each of the five classes
  
  rast_adop_fao_S1 <- ifel(rast_adop_fao_cat == "S1", 1, 0)
  rast_adop_fao_S2 <- ifel(rast_adop_fao_cat == "S2", 1, 0)
  rast_adop_fao_S3 <- ifel(rast_adop_fao_cat == "S3", 1, 0)
  rast_adop_fao_N1 <- ifel(rast_adop_fao_cat == "N1", 1, 0)
  rast_adop_fao_N2 <- ifel(rast_adop_fao_cat == "N2", 1, 0)
  
  rast_adop_fao_trans <- rast(list(rast_adop_fao_S1, rast_adop_fao_S2, rast_adop_fao_S3, rast_adop_fao_N1, rast_adop_fao_N2))
  names(rast_adop_fao_trans) <- c("S1", "S2", "S3", "N1", "N2")
  
  df_extr <- terra::extract(rast_adop_fao_trans, vect_subdiv_proj, fun = sum, na.rm = TRUE)
  
  df_extr <-
    (df_extr * Stat_factor_ha) # calculates area depending on the aggregation level
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
  

  output_vect(vect_subdiv, paste0("adop_fao_subdiv_area_", params$INN2)) # save as a geojson file
  output_csv(as_tibble(vect_subdiv), paste0("adop_fao_subdiv_area_", params$INN2)) # save as a csv file
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
  
  
  fill_var_list <-  c("S1", "S2", "S3", "N1", "N2")
  pal_col <- c("Greens", "Blues", "Purples", "Oranges", "Reds")
  
  plot_subdiv_maps(5, fill_var_list, pal_col)
  
}

```

```{r i2_statistics_adop_faolimits_01, echo=FALSE, results='asis', eval=ba_crit}

cat("### Likelihood for Adoption - FAO twenty-one classes - total area (ha)

The table and maps shows the area in hectares within each subdivision of each FAO suitability classification with limiting criteria.")

```

<div class="fold o"> 
```{r i2_statistics_adop_faolimits_02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=ba_crit}
# create subdiv level statistics
# 03/03/2019 A FARROW adde

if (params$RES2 != 1) {
  
  # need to subset the rast_adop_fao_bin to separate rasters for each of the five classes
  
  rast_adop_faolimits_S1 <- ifel(rast_adop_faolimits == "S1", 1, 0)
  rast_adop_faolimits_S2_SE <- ifel(rast_adop_faolimits == "S2_SE", 1, 0)
  rast_adop_faolimits_S2_Cl <- ifel(rast_adop_faolimits == "S2_Cl", 1, 0)
  rast_adop_faolimits_S2_Ls <- ifel(rast_adop_faolimits == "S2_Ls", 1, 0)
  rast_adop_faolimits_S2_SF <- ifel(rast_adop_faolimits == "S2_SF", 1, 0)
  rast_adop_faolimits_S2_SP <- ifel(rast_adop_faolimits == "S2_SP", 1, 0)
  rast_adop_faolimits_S3_SE <- ifel(rast_adop_faolimits == "S3_SE", 1, 0)
  rast_adop_faolimits_S3_Cl <- ifel(rast_adop_faolimits == "S3_Cl", 1, 0)
  rast_adop_faolimits_S3_Ls <- ifel(rast_adop_faolimits == "S3_Ls", 1, 0)
  rast_adop_faolimits_S3_SF <- ifel(rast_adop_faolimits == "S3_SF", 1, 0)
  rast_adop_faolimits_S3_SP <- ifel(rast_adop_faolimits == "S3_SP", 1, 0)
  rast_adop_faolimits_N1_SE <- ifel(rast_adop_faolimits == "N1_SE", 1, 0)  
  rast_adop_faolimits_N1_Cl <- ifel(rast_adop_faolimits == "N1_Cl", 1, 0)
  rast_adop_faolimits_N1_Ls <- ifel(rast_adop_faolimits == "N1_Ls", 1, 0)
  rast_adop_faolimits_N1_SF <- ifel(rast_adop_faolimits == "N1_SF", 1, 0)
  rast_adop_faolimits_N1_SP <- ifel(rast_adop_faolimits == "N1_SP", 1, 0)
  rast_adop_faolimits_N2_SE <- ifel(rast_adop_faolimits == "N2_SE", 1, 0)  
  rast_adop_faolimits_N2_Cl <- ifel(rast_adop_faolimits == "N2_Cl", 1, 0)
  rast_adop_faolimits_N2_Ls <- ifel(rast_adop_faolimits == "N2_Ls", 1, 0)
  rast_adop_faolimits_N2_SF <- ifel(rast_adop_faolimits == "N2_SF", 1, 0)
  rast_adop_faolimits_N2_SP <- ifel(rast_adop_faolimits == "N2_SP", 1, 0)
  

  rast_adop_faolimits_trans <- rast(
    list(
      rast_adop_faolimits_S1 ,
      rast_adop_faolimits_S2_SE,
      rast_adop_faolimits_S2_Cl,
      rast_adop_faolimits_S2_Ls,
      rast_adop_faolimits_S2_SF,
      rast_adop_faolimits_S2_SP,
      rast_adop_faolimits_S3_SE,
      rast_adop_faolimits_S3_Cl,
      rast_adop_faolimits_S3_Ls,
      rast_adop_faolimits_S3_SF,
      rast_adop_faolimits_S3_SP,
      rast_adop_faolimits_N1_SE,
      rast_adop_faolimits_N1_Cl,
      rast_adop_faolimits_N1_Ls,
      rast_adop_faolimits_N1_SF,
      rast_adop_faolimits_N1_SP,
      rast_adop_faolimits_N2_SE,
      rast_adop_faolimits_N2_Cl,
      rast_adop_faolimits_N2_Ls,
      rast_adop_faolimits_N2_SF,
      rast_adop_faolimits_N2_SP
    )
  )
  names(rast_adop_faolimits_trans) <- c("S1", "S2_SE", "S2_Cl", "S2_Ls","S2_SF","S2_SP","S3_SE","S3_Cl","S3_Ls","S3_SF","S3_SP","N1_SE","N1_Cl","N1_Ls","N1_SF","N1_SP","N2_SE","N2_Cl","N2_Ls","N2_SF","N2_SP")
  
  df_extr <- terra::extract(rast_adop_faolimits_trans, vect_subdiv_proj, fun = sum, na.rm = TRUE)
  
  df_extr <-
    (df_extr * Stat_factor_ha) # calculates area depending on the aggregation level
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
  

  output_vect(vect_subdiv, paste0("adop_faolimits_subdiv_area_", params$INN2)) # save as a geojson file
  output_csv(as_tibble(vect_subdiv), paste0("adop_faolimits_subdiv_area_", params$INN2)) # save as a csv file
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
  
  
  fill_var_list <-  c("S1", "S2_SE", "S2_Cl", "S2_Ls","S2_SF","S2_SP","S3_SE","S3_Cl","S3_Ls","S3_SF","S3_SP","N1_SE","N1_Cl","N1_Ls","N1_SF","N1_SP","N2_SE","N2_Cl","N2_Ls","N2_SF","N2_SP")
  pal_col <- c("Greens", "PuBu","GnBu", "BuGn", "Blues","PuBu","Greys" , "YlGn", "YlGnBu","BuPu", "PuBuGn","PuBu", "Purples", "Oranges","PuRd"  ,"OrRd" ,"YlOrBr" ,"YlOrRd" ,"RdPu" ,"OrRd" ,"Reds")
  
  plot_subdiv_maps(21, fill_var_list, pal_col)
  
}

```

</div>



```{r i2_statistics_adop_05, echo=FALSE, results='asis', eval=adop_crit}

cat("### Likelihood for Adoption - three classes - (%)

The table and maps shows the percentage of each subdivision of each likelihood for adoption class.")

```

<div class="fold o"> 
```{r i2_statistics_adop_06, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=adop_crit}
# create subdiv level statistics
# 03/03/2019 A FARROW adde

if (params$RES2 != 2) {
  df_extr <- terra::extract(rast_adop_3class, vect_subdiv_proj, fun = mean, na.rm = TRUE)
  
  df_extr <- (df_extr * 100) # calculates % of the total area
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
  

  output_vect(vect_subdiv, paste0("adop_subdiv_pc_", params$INN2)) # save as a geojson file
  
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
  
  
  fill_var_list <-  c("high", "moderate", "low")
  pal_col <- c("Greens","Oranges" ,"Reds")
  
  plot_subdiv_maps(3, fill_var_list, pal_col)
  
}

``` 
</div>


```{r i2_statistics_adop_faolimits_03, echo=FALSE, results='asis', eval=adop_crit}

cat("### Likelihood for Adoption - FAO twenty-one classes - total area (%)

The table and maps shows the the percentage of each subdivision of each FAO suitability classification with limiting criteria.")

```

<div class="fold o"> 
```{r i2_statistics_adop_faolimits_04, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=adop_crit}
# create subdiv level statistics

if (params$RES2 != 1) {
  df_extr <- terra::extract(rast_adop_faolimits_trans, vect_subdiv_proj, fun = mean, na.rm = TRUE)
  
  df_extr <- (df_extr * 100) # calculates % of the total area
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
  

  output_vect(vect_subdiv, paste0("adop_faolimits_subdiv_pc_", params$INN2)) # save as a geojson file
  output_csv(as_tibble(vect_subdiv), paste0("adop_faolimits_subdiv_pc_", params$INN2)) # save as a csv file  
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
  
  
  
  fill_var_list <-  c("S1", "S2_SE", "S2_Cl", "S2_Ls","S2_SF","S2_SP","S3_SE","S3_Cl","S3_Ls","S3_SF","S3_SP","N1_SE","N1_Cl","N1_Ls","N1_SF","N1_SP","N2_SE","N2_Cl","N2_Ls","N2_SF","N2_SP")
  pal_col <- c("Greens", "PuBu","GnBu", "BuGn", "Blues","PuBu","Greys" , "YlGn", "YlGnBu","BuPu", "PuBuGn","PuBu", "Purples", "Oranges","PuRd"  ,"OrRd" ,"YlOrBr" ,"YlOrRd" ,"RdPu" ,"OrRd" ,"Reds")
  
  plot_subdiv_maps(21, fill_var_list, pal_col)
  
}

``` 

</div>


```{r i2_statistics_ba_01, echo=FALSE, results='asis', eval=ba_crit}

cat("## Aptitude Subdivision Area Statistics

### Biophysical Aptitude - two classes - total area (ha)

The table and maps shows the area in hectares within each subdivision of each aptitude classification.")

```

<div class="fold o"> 
```{r i2_statistics_ba_02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=ba_crit}
# create subdiv level statistics
# 03/03/2019 A FARROW adde

if (params$RES2 != 2) {
  df_extr <- terra::extract(rast_ba_2class, vect_subdiv_proj, fun = sum, na.rm = TRUE)
  
  df_extr <-
    (df_extr * Stat_factor_ha) # calculates area depending on the aggregation level
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
  

  output_vect(vect_subdiv, paste0("ba_subdiv_area_", params$INN2)) # save as a geojson file
  output_csv(as_tibble(vect_subdiv), paste0("ba_subdiv_area_", params$INN2)) # save as a csv file  
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
  
  
  fill_var_list <-  c("optimal", "suboptimal")
  pal_col <- c("YlGn", "Reds")
  
  plot_subdiv_maps(2, fill_var_list, pal_col)
  
}

``` 
</div>


```{r i2_statistics_ba_fao_01, echo=FALSE, results='asis', eval=ba_crit}

cat("### Biophysical Aptitude - FAO five classes - total area (ha)

The table and maps shows the area in hectares within each subdivision of each FAO suitability classification.")

```

<div class="fold o"> 
```{r i2_statistics_ba_fao_02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=ba_crit}
# create subdiv level statistics
# 03/03/2019 A FARROW adde

if (params$RES2 != 1) {
  
  # need to subset the rast_fao_bin to separate rasters for each of the five classes
  
  rast_fao_S1 <- ifel(rast_ba_fao_cat == "S1", 1, 0)
  rast_fao_S2 <- ifel(rast_ba_fao_cat == "S2", 1, 0)
  rast_fao_S3 <- ifel(rast_ba_fao_cat == "S3", 1, 0)
  rast_fao_N1 <- ifel(rast_ba_fao_cat == "N1", 1, 0)
  rast_fao_N2 <- ifel(rast_ba_fao_cat == "N2", 1, 0)
  
  rast_fao_trans <- rast(list(rast_fao_S1, rast_fao_S2, rast_fao_S3, rast_fao_N1, rast_fao_N2))
  names(rast_fao_trans) <- c("S1", "S2", "S3", "N1", "N2")
  
  df_extr <- terra::extract(rast_fao_trans, vect_subdiv_proj, fun = sum, na.rm = TRUE)
  
  df_extr <-
    (df_extr * Stat_factor_ha) # calculates area depending on the aggregation level
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
  

  output_vect(vect_subdiv, paste0("ba_fao_subdiv_area_", params$INN2)) # save as a geojson file
  output_csv(as_tibble(vect_subdiv), paste0("ba_fao_subdiv_area_", params$INN2)) # save as a csv file
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
  
  
  fill_var_list <-  c("S1", "S2", "S3", "N1", "N2")
  pal_col <- c("Greens", "Blues", "Purples", "Oranges", "Reds")
  
  plot_subdiv_maps(5, fill_var_list, pal_col)
  
}

``` 

```{r i2_statistics_ba_faolimits_01, echo=FALSE, results='asis', eval=ba_crit}

cat("### Biophysical Aptitude - FAO seventeen classes - total area (ha)

The table and maps shows the area in hectares within each subdivision of each FAO suitability classification with limiting criteria.")

```

<div class="fold o"> 
```{r i2_statistics_ba_faolimits_02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=ba_crit}
# create subdiv level statistics
# 03/03/2019 A FARROW adde

if (params$RES2 != 1) {
  
  # need to subset the rast_fao_bin to separate rasters for each of the five classes
  
  rast_ba_faolimits_S1 <- ifel(rast_ba_faolimits == "S1", 1, 0)
  rast_ba_faolimits_S2_Cl <- ifel(rast_ba_faolimits == "S2_Cl", 1, 0)
  rast_ba_faolimits_S2_Ls <- ifel(rast_ba_faolimits == "S2_Ls", 1, 0)
  rast_ba_faolimits_S2_SF <- ifel(rast_ba_faolimits == "S2_SF", 1, 0)
  rast_ba_faolimits_S2_SP <- ifel(rast_ba_faolimits == "S2_SP", 1, 0)
  rast_ba_faolimits_S3_Cl <- ifel(rast_ba_faolimits == "S3_Cl", 1, 0)
  rast_ba_faolimits_S3_Ls <- ifel(rast_ba_faolimits == "S3_Ls", 1, 0)
  rast_ba_faolimits_S3_SF <- ifel(rast_ba_faolimits == "S3_SF", 1, 0)
  rast_ba_faolimits_S3_SP <- ifel(rast_ba_faolimits == "S3_SP", 1, 0)
  rast_ba_faolimits_N1_Cl <- ifel(rast_ba_faolimits == "N1_Cl", 1, 0)
  rast_ba_faolimits_N1_Ls <- ifel(rast_ba_faolimits == "N1_Ls", 1, 0)
  rast_ba_faolimits_N1_SF <- ifel(rast_ba_faolimits == "N1_SF", 1, 0)
  rast_ba_faolimits_N1_SP <- ifel(rast_ba_faolimits == "N1_SP", 1, 0)
  rast_ba_faolimits_N2_Cl <- ifel(rast_ba_faolimits == "N2_Cl", 1, 0)
  rast_ba_faolimits_N2_Ls <- ifel(rast_ba_faolimits == "N2_Ls", 1, 0)
  rast_ba_faolimits_N2_SF <- ifel(rast_ba_faolimits == "N2_SF", 1, 0)
  rast_ba_faolimits_N2_SP <- ifel(rast_ba_faolimits == "N2_SP", 1, 0)
  

  rast_ba_faolimits_trans <- rast(
    list(
      rast_ba_faolimits_S1 ,
      rast_ba_faolimits_S2_Cl,
      rast_ba_faolimits_S2_Ls,
      rast_ba_faolimits_S2_SF,
      rast_ba_faolimits_S2_SP,
      rast_ba_faolimits_S3_Cl,
      rast_ba_faolimits_S3_Ls,
      rast_ba_faolimits_S3_SF,
      rast_ba_faolimits_S3_SP,
      rast_ba_faolimits_N1_Cl,
      rast_ba_faolimits_N1_Ls,
      rast_ba_faolimits_N1_SF,
      rast_ba_faolimits_N1_SP,
      rast_ba_faolimits_N2_Cl,
      rast_ba_faolimits_N2_Ls,
      rast_ba_faolimits_N2_SF,
      rast_ba_faolimits_N2_SP
    )
  )
  names(rast_ba_faolimits_trans) <- c("S1", "S2_Cl", "S2_Ls","S2_SF","S2_SP","S3_Cl","S3_Ls","S3_SF","S3_SP","N1_Cl","N1_Ls","N1_SF","N1_SP","N2_Cl","N2_Ls","N2_SF","N2_SP")
  
  df_extr <- terra::extract(rast_ba_faolimits_trans, vect_subdiv_proj, fun = sum, na.rm = TRUE)
  
  df_extr <-
    (df_extr * Stat_factor_ha) # calculates area depending on the aggregation level
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
  

  output_vect(vect_subdiv, paste0("ba_faolimits_subdiv_area_", params$INN2)) # save as a geojson file
  output_csv(as_tibble(vect_subdiv), paste0("ba_faolimits_subdiv_area_", params$INN2)) # save as a csv file
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
  
  
  fill_var_list <-  c("S1", "S2_Cl", "S2_Ls","S2_SF","S2_SP","S3_Cl","S3_Ls","S3_SF","S3_SP","N1_Cl","N1_Ls","N1_SF","N1_SP","N2_Cl","N2_Ls","N2_SF","N2_SP")
  pal_col <- c("Greens", "GnBu", "BuGn", "Blues","Greys" , "YlGn", "YlGnBu","BuPu", "PuBuGn", "Purples", "Oranges","PuRd"  ,"OrRd" ,"YlOrBr" ,"YlOrRd" ,"RdPu" ,"OrRd" ,"Reds")
  
  plot_subdiv_maps(17, fill_var_list, pal_col)
  
}

```

```{r i2_statistics_ba_03, echo=FALSE, results='asis', eval=ba_crit}

cat("### Biophysical Aptitude - two classes - (%)

The table and maps shows the percentage of each subdivision of each aptitude classification.")

```

<div class="fold o"> 
```{r i2_statistics_ba_04, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=ba_crit}
# create subdiv level statistics
# 03/03/2019 A FARROW adde

if (params$RES2 != 2) {
  df_extr <- terra::extract(rast_ba_2class, vect_subdiv_proj, fun = mean, na.rm = TRUE)
  
  df_extr <- (df_extr * 100) # calculates % of the total area
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
  

  output_vect(vect_subdiv, paste0("ba_subdiv_pc_", params$INN2)) # save as a geojson file
  output_csv(as_tibble(vect_subdiv), paste0("ba_subdiv_pc_", params$INN2)) # save as a csv file
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
  
  
  fill_var_list <-  c("optimal", "suboptimal")
  pal_col <- c("YlGn", "Reds")
  
  plot_subdiv_maps(2, fill_var_list, pal_col)
  
}

``` 
</div>


```{r i2_statistics_ba_faolimits_03, echo=FALSE, results='asis', eval=ba_crit}

cat("### Biophysical Aptitude - seventeen classes - (%)

The table and maps shows the the percentage of each subdivision of each FAO suitability classification with limiting criteria.")

```

<div class="fold o"> 
```{r i2_statistics_ba_faolimits_04, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=ba_crit}
# create subdiv level statistics
# 03/03/2019 A FARROW adde

if (params$RES2 != 1) {
  df_extr <- terra::extract(rast_ba_faolimits_trans, vect_subdiv_proj, fun = mean, na.rm = TRUE)
  
  df_extr <- (df_extr * 100) # calculates % of the total area
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
  

  output_vect(vect_subdiv, paste0("ba_faolimits_subdiv_pc_", params$INN2)) # save as a geojson file
  output_csv(as_tibble(vect_subdiv), paste0("ba_faolimits_subdiv_pc_", params$INN2)) # save as a csv file  
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
  
  
  
  fill_var_list <-  c("S1", "S2_Cl", "S2_Ls","S2_SF","S2_SP","S3_Cl","S3_Ls","S3_SF","S3_SP","N1_Cl","N1_Ls","N1_SF","N1_SP","N2_Cl","N2_Ls","N2_SF","N2_SP")
  pal_col <- c("Greens", "GnBu", "BuGn", "Blues","Greys" , "YlGn", "YlGnBu","BuPu", "PuBuGn", "Purples", "Oranges","PuRd"  ,"OrRd" ,"YlOrBr" ,"YlOrRd" ,"RdPu" ,"OrRd" ,"Reds")
  
  plot_subdiv_maps_pc(17, fill_var_list, pal_col)
  
}

``` 

</div>

```{r i2_statistics_se_01, echo=FALSE, results='asis', eval=sef_crit}

cat("## Feasibility Subdivision Area Statistics

### Socioeconomic Feasibility - three classes - total area (ha)

The table and maps shows the area in hectares within each subdivision of each socioeconomic feasibility class.")

```

<div class="fold o"> 
```{r i2_statistics_se_02, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=sef_crit}
# create subdiv level statistics
# 03/03/2019 A FARROW adde

if (params$RES2 != 2) {
  df_extr <- terra::extract(rast_se_3class, vect_subdiv_proj, fun = sum, na.rm = TRUE)
  
  df_extr <-
    (df_extr * Stat_factor_ha) # calculates area depending on the aggregation level
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
  

  output_vect(vect_subdiv, paste0("se_subdiv_area_", params$INN2)) # save as a geojson file
  
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
 
   
  fill_var_list <-  c("high", "moderate", "low")
  pal_col <- c("Greens","Oranges" ,"Reds")
  
  plot_subdiv_maps(3, fill_var_list, pal_col)
  
}

``` 
</div>


```{r i2_statistics_se_03, echo=FALSE, results='asis', eval=sef_crit}

cat("### Socioeconomic Feasibility - three classes - (%)

The table and maps shows the percentage of each subdivision of each socioeconomic feasibility class.")

```

<div class="fold o"> 
```{r i2_statistics_se_04, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", warning=FALSE, eval=sef_crit}
# create subdiv level statistics
# 03/03/2019 A FARROW adde

if (params$RES2 != 2) {
  df_extr <- terra::extract(rast_se_3class, vect_subdiv_proj, fun = mean, na.rm = TRUE)
  
  df_extr <- (df_extr * 100) # calculates % of the total area
  
  for (i in seq_len(ncol(df_extr)))
    vect_subdiv[[colnames(df_extr)[i]]] <- df_extr[, i]
  

  output_vect(vect_subdiv, paste0("se_subdiv_pc_", params$INN2)) # save as a geojson file
  
  
  # where: n is the number of maps to produce (the number of values for the aptitude)
  #        fill_var_list is a vector of the possible values for aptitude
  #        pal_col is a vector of the names of the colour palette
  
  
  fill_var_list <-  c("high", "moderate", "low")
  pal_col <- c("Greens","Oranges" ,"Reds")
  
  plot_subdiv_maps(3, fill_var_list, pal_col)
  
}

``` 
</div>

# Calculate yields and production

## Yield proportion

The IRM script already calculates the optimality of the individual criteria as well as the climatic, landscape, soil fertility and soil physical properties groups of criteria.

The first method of calculating yield will calculate the product of the optimality of selected criteria.


```{r i2_calc_yield_1, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", include = TRUE, echo=FALSE, message=FALSE, warning=FALSE, eval=ba_crit}

# get the criteria that contribute to yield

df_yield_rb_1 <- dplyr::select(df_priorities, "rulebase_number","criterion","yield") %>% dplyr::filter(!is.na(yield))

df_yield_rb_1 %>% kable(digits = 3) %>% kable_styling("striped", full_width = T)  %>%  scroll_box(height = "500px")
# make an expression using the rule base numbers

yield_expr <- paste("df_irm_i2$yieldpc <- (")

for (i in seq(from = 1,
              to = nrow(df_yield_rb_1),
              by = 1)) {
  yield_expr <- paste0(yield_expr, "df_irm_i2$" , as.character(df_yield_rb_1[i, 1]), "_o * ")
  
}
yield_expr <- paste(yield_expr, " 100)")
yield_expr

# evaluate the expression
eval(str2expression(yield_expr))
str(df_irm_i2$yieldpc)
if (summarise(df_irm_i2, Average = mean(yieldpc, na.rm = T)) > 0) {

# df_irm_i2 <- dplyr::select(df_irm_i2,-yield)

vect_yieldpc <- select(df_irm_i2, x, y, yieldpc) %>% na.omit %>% vect(geom = c("x", "y"))

rast_yieldpc <- rasterize(vect_yieldpc, rast_mask_proj, field="yieldpc")
names(rast_yieldpc) <- c('yieldpc')

# export
output_geotiff(rast_yieldpc, paste0("yieldpc_", params$INN2))

#  dy <- rast_yield %>%
#    as.data.frame(xy = TRUE) %>%
#    na.omit

  
  gy <- ggplot() +
    geom_spatraster(data = rast_yieldpc, aes(fill = yieldpc)) +
    scale_fill_stepsn(
      paste0("Yield % \n", params$INN2),
      n.breaks = 10,
      limits = c(0, 100),
      colours = hcl.colors(palette = "Greens", 10, rev = TRUE),
      guide = "legend",  na.value = "transparent"
    ) +
#    scale_x_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
#    scale_y_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
    coord_sf()
  
  gy2 <- add_subdiv_proj_simple_plot(gy)
gy2
}
```

## Calculate yield

The IRM script converts yield proportion to yield using the yield values for sole crop or intercrop.


```{r i2_calc_yield_2, cache = TRUE, cache.whatever=params$Agg, out.width="100%", include = TRUE, echo=FALSE, message=FALSE, warning=FALSE, eval=ba_crit}

# get the criteria that contribute to yield

filename_yield <-
  as.character(paste("tab_data/input/yield_", params$INN2, ".csv", sep = ""))
df_yield_values <- read.csv(here(filename_yield), na.strings = c("NA"))

df_yield_values %>% kable(digits = 3) %>% kable_styling("striped", full_width = T)  %>%  scroll_box(height = "100px")


if (params$INN2 == "NA") {
  df_irm_i2$yield <- df_irm_i2$yieldpc / 100 * df_yield_values$YA
  cat("Sole crop yield")
} else {
  if (params$SYS == "comparison") {
    df_irm_i2$yield <- df_irm_i2$yieldpc / 100 * df_yield_values$YA
    cat("Sole crop 1 yield (comparison)")
  } else {
    if (params$SYS == "intercrop") {
      df_irm_i2$yield <- df_irm_i2$yieldpc / 100 * df_yield_values$YI
      cat("Intercrop 1 yield")
    } else {
      if (params$SYS == "rotation") {
        df_irm_i2$yield <- df_irm_i2$yieldpc / 100 * df_yield_values$YA
        cat("Rotation crop 1 yield")
      }
    }
  }
}

if (summarise(df_irm_i2, Average = mean(yield, na.rm = T)) > 0) {
  
  vect_yield <-
    select(df_irm_i2, x, y, yield) %>% na.omit %>% vect(geom = c("x", "y"))
  
  rast_yield <- rasterize(vect_yield, rast_mask_proj, field = "yield")
  names(rast_yield) <-  c('yield')

# export
output_geotiff(rast_yield, paste0("yield_", params$INN2))

#dyd <- dByd %>%
#  as.data.frame(xy = TRUE) %>%
#  na.omit


gyd <- ggplot() +
  geom_spatraster(data = rast_yield, aes(fill = yield)) +
  scale_fill_stepsn(
    paste0("Yield (kg/ha) \n", params$INN2),
    n.breaks = 10,
    colours = hcl.colors(palette = "OrRd", 10, rev = TRUE),
    guide = "legend",
    labels = comma,  na.value = "transparent"
  ) +
#  scale_x_continuous(
#    name = "",
#    labels = function(x) {
#      1.0e-3 * x
#    }
#  ) +
#  scale_y_continuous(
#    name = "",
#    labels = function(x) {
#      1.0e-3 * x
#    }
#  ) +
  coord_sf()

  gyd2 <- add_subdiv_proj_simple_plot(gyd)
gyd2
}
```

## Calculate production

The IRM script converts yield proportion to production using the yield values for sole crop or intercrop.


```{r i2_calc_yield_3, cache = TRUE, cache.whatever=params$Agg, out.width="100%", include = TRUE, echo=FALSE, message=FALSE, warning=FALSE, eval=ba_crit}

# get the criteria that contribute to yield

#yield_filename <-
#  as.character(paste("tab_data/input/yield_", params$INN2, ".csv", sep = ""))
#yield_tab <- read.csv(here(yield_filename), na.strings = c("NA"))

#yield_tab %>% kable(digits = 3) %>% kable_styling("striped", full_width = T)  %>%  scroll_box(height = "150px")

df_irm_i2$production <- df_irm_i2$yieldpc *  Stat_factor_ha

if (summarise(df_irm_i2, Average = mean(production, na.rm = T)) > 0) {
  vect_production <-
    select(df_irm_i2, x, y, production) %>% na.omit %>% vect(geom = c("x", "y"))
  
  rast_production <-
    rasterize(vect_production, rast_mask_proj, field = "production")
  names(rast_production) <- c('production')
  
  # export
  output_geotiff(rast_production, paste0("production_", params$INN2))
  
  #  dp <- dBp %>%
  #    as.data.frame(xy = TRUE) %>%
  #    na.omit
  
  gp <- ggplot() +
    geom_spatraster(data = rast_production, aes(fill = production)) +
    scale_fill_stepsn(
      paste0("Production (kg) \n", params$INN2),
      n.breaks = 10,
      colours = hcl.colors(palette = "BuPu", 10, rev = TRUE),
      guide = "legend",
      labels = comma,
      na.value = "transparent"
    ) +
#    scale_x_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
#    scale_y_continuous(
#      name = "",
#      labels = function(x) {
#        1.0e-3 * x
#      }
#    ) +
    coord_sf()
  
  gp2 <- add_subdiv_proj_simple_plot(gp)
  gp2
}
```

# Compare the innovations

## Yield comparison

<div class="fold o"> 
```{r classified compare_score_maps1, cache = TRUE, cache.whatever=params$Agg,  out.width="100%", message=FALSE, warning=FALSE, timeit = TRUE}

yield_pc_i1_df <-
  df_irm %>% dplyr::select(yieldpc, x , y) %>% na.omit #%>% vect(geom = c("x", "y"))

yield_pc_i2_df <-
  df_irm_i2 %>% dplyr::select(yieldpc) %>% na.omit %>%
  dplyr::rename(yieldpc_i2 = yieldpc)

yield_pc_diff_df <- cbind(yield_pc_i1_df, yield_pc_i2_df)

# complementary score
#yield_pc_diff_df$compl <-
#  (yield_pc_diff_df$yieldpc + yield_pc_diff_df$yieldpc_i2)

# relative difference score
yield_pc_diff_df$diff <-
  yield_pc_diff_df$yieldpc - yield_pc_diff_df$yieldpc_i2

# absolute difference score
#yield_pc_diff_df$absdiff <-
#  abs(yield_pc_diff_df$yieldpc - yield_pc_diff_df$yieldpc_i2)

# decimal difference score for plotting
yield_pc_diff_df$diff_dec <- yield_pc_diff_df$diff / 100

# max innovation name
yield_pc_diff_df$max_inn_name <-
  ifelse(
    yield_pc_diff_df$yieldpc > yield_pc_diff_df$yieldpc_i2,
    paste(params$INN1),
    ifelse(
      yield_pc_diff_df$yieldpc < yield_pc_diff_df$yieldpc_i2,
      paste(params$INN2) ,
      "equal"
    )
  )

# max innovation id for plotting
yield_pc_diff_df$max_inn_id <- as.integer(ifelse(
  yield_pc_diff_df$yieldpc > yield_pc_diff_df$yieldpc_i2,
  1,
  ifelse(yield_pc_diff_df$yieldpc < yield_pc_diff_df$yieldpc_i2, 2 , 0)
))

vect_yield_pc_diff <-
  yield_pc_diff_df %>% na.omit %>% vect(geom = c("x", "y"))

rast_yield_pc_diff <-
  rasterize(vect_yield_pc_diff,
            rast_mask_proj,
            field = c("diff", "diff_dec", "max_inn_id"))

rast_yield_pc_diff_cat <- rast_yield_pc_diff
df_int <-
  data.frame(id = 0:2,
             max_inn_id = c("equal", "potato", "superpotato"))
levels(rast_yield_pc_diff_cat$max_inn_id) <- df_int

names(rast_yield_pc_diff_cat) <- c('difference', 'decimal difference', 'innovation')

# export
output_geotiff(rast_yield_pc_diff_cat, paste0("difference_", params$INN1,"_", params$INN2))


colour_breaks <- c(-1, 0, 1)
colours <- c("#004D40", "#FFC107", "#D81B60")

gc <- ggplot() +
  geom_spatraster(data = rast_yield_pc_diff,
                  na.rm = TRUE,
                  aes(fill = diff_dec, alpha = after_stat(abs(value)))) +
  scale_fill_gradientn(
    name = "most suitable\ninnovation",
    na.value = "transparent",
    limits  = c(-1, 1),
    colours = colours[c(1, seq_along(colours), length(colours))],
    breaks = c(-1, 0, 1),
    labels = c(paste(params$INN2), "equal", paste(params$INN1))
  ) +
  scale_alpha(guide = 'none')


gc2 <- add_subdiv_proj_simple_plot(gc)

gc2


```
</div>

<div class="fold o">
```{r classified combine_score_maps1, cache = TRUE, cache.whatever=params$Agg, out.width="100%", message=FALSE, warning=FALSE, timeit = TRUE}

if (params$SYS != "comparison") {
      
#complementary score
yield_pc_diff_df$compl <-
  (yield_pc_diff_df$yieldpc + yield_pc_diff_df$yieldpc_i2)

vect_yield_pc_diff <-
  yield_pc_diff_df %>% na.omit %>% vect(geom = c("x", "y"))

rast_yield_pc_compl <-
  rasterize(vect_yield_pc_diff,
            rast_mask_proj,
            field = c("compl"))

names(rast_yield_pc_compl) <- c('complementary')

# export
output_geotiff(rast_yield_pc_compl, paste0("complementary_", params$INN1,"_", params$INN2))
        

gcsum <- ggplot() +
  geom_spatraster(data = rast_yield_pc_compl,
                  na.rm = TRUE,
                  aes(fill = complementary)) +
  scale_fill_stepsn(
    na.value = "transparent",
    n.breaks = 10,
    colours = hcl.colors(palette = "PiYG", 10, rev = FALSE),
    guide = "legend") +
  labs(fill = "Combined yield %")



  gcsum2 <- add_subdiv_proj_simple_plot(gcsum)
  
gcsum2

}
```
</div>



```{r}

if (params$INT == 1)
  shiny::setProgress(0.99, message = "Finished - just writing html file")  # set progress to 99%
```
  
# Session Information
  
<div class="fold o"> 
```{r}

sessionInfo()

``` 
</div>

# Acknowledgements

Javascript code and css style used in this script by Martin Schmelzer

https://stackoverflow.com/questions/37755037/how-to-add-code-folding-to-output-chunks-in-rmarkdown-html-documents


Timing for chunks by Yihui Xie
https://stackoverflow.com/questions/24595280/timing-for-chunks

 

